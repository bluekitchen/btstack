/* BEGIN_HEADER */
#include "mbedtls/base64.h"
#include "mbedtls/pem.h"
#include "mbedtls/des.h"
#include "mbedtls/aes.h"
#include "mbedtls/legacy_or_psa.h"

/* END_HEADER */

/* BEGIN_CASE depends_on:MBEDTLS_PEM_WRITE_C */
void mbedtls_pem_write_buffer(char *start, char *end, data_t *buf,
                              char *result_str)
{
    unsigned char *check_buf = NULL;
    int ret;
    size_t olen = 0, olen2 = 0;


    ret = mbedtls_pem_write_buffer(start, end, buf->x, buf->len, NULL, 0, &olen);
    TEST_ASSERT(ret == MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL);

    check_buf = (unsigned char *) mbedtls_calloc(1, olen);
    TEST_ASSERT(check_buf != NULL);

    ret = mbedtls_pem_write_buffer(start, end, buf->x, buf->len, check_buf, olen, &olen2);

    TEST_ASSERT(olen2 <= olen);
    TEST_ASSERT(olen > strlen((char *) result_str));
    TEST_ASSERT(ret == 0);
    TEST_ASSERT(strncmp((char *) check_buf, (char *) result_str, olen) == 0);

exit:
    mbedtls_free(check_buf);
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_PEM_PARSE_C */
void mbedtls_pem_read_buffer(char *header, char *footer, char *data,
                             char *pwd, int res, data_t *out)
{
    mbedtls_pem_context ctx;
    int ret;
    size_t use_len = 0;
    size_t pwd_len = strlen(pwd);
    const unsigned char *buf;

    mbedtls_pem_init(&ctx);

    ret = mbedtls_pem_read_buffer(&ctx, header, footer, (unsigned char *) data,
                                  (unsigned char *) pwd, pwd_len, &use_len);
    TEST_ASSERT(ret == res);
    if (ret != 0) {
        goto exit;
    }

    use_len = 0;
    buf = mbedtls_pem_get_buffer(&ctx, &use_len);
    TEST_EQUAL(use_len, out->len);
    TEST_ASSERT(memcmp(out->x, buf, out->len) == 0);

exit:
    mbedtls_pem_free(&ctx);
}
/* END_CASE */
