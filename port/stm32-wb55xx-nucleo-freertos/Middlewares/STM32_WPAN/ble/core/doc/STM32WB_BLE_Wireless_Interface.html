<html><head><style>
html {overflow-y:scroll;}

body {font-size:13px;color:#000000;color:#404040;
background-color:#f1f1f1;margin:20px;}

p,td,ul {
	line-height:130%;
}

body,p,h1,h2,h3,h4,table,td,th,ul,ol,textarea,input {
	font-family:verdana,helvetica,arial,sans-serif;
}

iframe 	{margin:0px;}
img		{border:0;}

table,th,td,input,textarea {
	font-size:100%;
}

h1 {font-size:28px;margin-top:0px;font-weight:normal;page-break-before: always}
h2 {font-size:22px;margin-top:10px;margin-bottom:10px;font-weight:normal;page-break-before: always}
h3 {font-size:17px;font-weight:normal}
h4 {font-size:12px;}
h5 {font-size:11px;}
h6 {font-size:10px;}

h1,h2,h3,h4,h5,h6 {
	background-color:transparent;color:#000000;
}

#top {width:1220px;margin:auto;height:60px;}

#topLogo {text-align:left;float:left;margin-top:20px;margin-left:10px;}

#searchSection {height:60px;margin-right:0px;margin-top:5px;text-align:left;}

#searchText {color:#777777;font-size:11px;font-style:italic;padding-top:3px;}

#translateSection {height:30px;}

#topnav {height:25px;background-color:#d3d3d3;}

#topnavTut {height:20px;width:1190px;margin:auto;word-spacing:12px;font-size:12px;padding-left:10px;padding-right:20px;padding-top:5px;background-color:#d3d3d3;}

a.topnav:link,a.topnav:visited {color:#555555;text-decoration:none;}
a.topnav:hover,a.topnav:active {color:#ff4800;text-decoration:none;}

#topnavSpace {margin-left:290px;}

#belowTopnav {width:1220px;margin:auto;}

#page {width:1024px;float:left;margin-left:10px;margin-top:10px;padding-top:10px;padding-bottom:20px;box-shadow: 0px 0px 20px 3px #d3d3d3;border-radius:4px;background-color:#ffffff;}

div.topLeftRectangle {float:left;width:170px;height:90px;margin-top:10px;margin-right:4px;margin-left:10px;overflow:hidden;}

#mainLeaderboard {width:728px;height:90px;float:none;margin-top:0px;margin-left:0px;overflow:hidden;margin-bottom:15px;}

#pageads {height:100px;margin-bottom:10px;}

#leftcolumn {width:170px;float:left;margin-right:4px;margin-left:10px;}

#leftcolumn h2 {font-size:16px;font-weight:normal;color:#8AC007;}

#leftcolumn hr {color:#e5eecc;background-color:#e5eecc;margin-right:20px;}

#leftcolumn a:link,#leftcolumn a:visited,#leftcolumn a:hover,#leftcolumn a:active {
	display:block;font-size:13px;padding-bottom:4px;background-color:#ffffff;color:#555555;color:#404040;text-decoration:none;
}
#leftcolumn a:hover,#leftcolumn a:active {
	background-color:#ffffff;color:#000000;text-decoration:underline;
}

#main {width:822px;float:left;padding:7px;padding-top:0px;overflow:hidden;}

#rightcolumn h2{font-size:13px;font-weight:normal;color:#8AC007;margin-top:3px;margin-bottom:2px;}

#rightcolumn {width:160px;float:left;font-size:11px;padding-left:5px;margin-left:5px;}

#rightcolumn .rightad a:link,#rightcolumn .rightad a:visited,#rightcolumn .rightad a:hover,#rightcolumn .rightad a:active{
	text-decoration:none;display:block;color:#555555;margin-bottom:3px;padding-top:3px;
}

#rightcolumn .rightad a:hover,#rightcolumn .rightad a:active{
	text-decoration:underline;
}

#rightcolumn .rightad, #rightshare{
	width:150px;border:1px solid #d4d4d4;border-radius:4px;margin-bottom:8px;padding:5px;padding-bottom:10px;text-align:center;background-color:#ffffff;
}

#rightshare {margin-top:8px;}
#rightshare h2{font-size:13px;font-weight:normal;color:#8AC007;margin-top:3px;margin-bottom:2px;}

#sharelist{position:relative;height:16px;margin:0;margin-left:19px;}
#sharelist li{margin:0;padding:0;list-style:none;position:absolute;top:0;}
#sharelist li, #sharelist a{height:16px;display:block;}
#facebook{left:0px;width:16px;background:url('/images/share.png') -16px 0;}
#twitter{left:19px;width:16px;background:url('/images/share.png') -32px 0;}
#email{left:38px;width:16px;background:url('/images/share.png') -80px 0;}
#googleplus{left:57px;width:16px;background:url('/images/share.png') 0 0;}
#linkedin{left:76px;width:16px;background:url('/images/share.png') -48px 0;}
#reddit{left:95px;width:16px;background:url('/images/share.png') -64px 0;}

div.wideSkyscraper {width:160px;height:600px;margin:auto;margin-top:0;overflow:hidden;}

.footer {width:1040px;margin:auto;color:#909090;font-size:11px;text-align:center;padding-left:30px;padding-right:150px;}

#footerImg {float:left;width:200px;text-align:left;padding-left:3px;padding-top:11px;}

#footerAbout {word-spacing:6px;font-size:10px;padding-right:62px;padding-top:19px;float:right;text-align:right;}

#footerText{padding-top:13px;color:#404040;clear:both;color:#555555;margin-right:50px;}

.footer a:link,.footer a:visited {text-decoration:none;color:#404040;background-color:transparent}
.footer a:hover,.footer a:active {text-decoration:underline;color:#404040;background-color:transparent}

div.example {
/*	width:auto;color:#000000;background-color:#e5eecc;margin:0px;padding:5px;border:1px solid #d4d4d4;background-image:linear-gradient( #ffffff , #e5eecc 100px);*/
	width:auto;color:#000000;background-color:#e3e3e3;background-color:#f1f1f1;border: 1px solid #ebebeb; margin:0px;padding:10px;border-radius:4px;
}

div.example_code {
/*	width:auto;background-color:#ffffff;padding:5px;border:1px solid #d4d4d4;font-size:14px;font-family:"courier new";*/
	width:auto;background-color:#ffffff;padding:4px;padding-left:7px;border-left:4px solid #8AC007;font-size:14px;font-family:"courier new";border-radius:4px;
}

div.example_result {
/*	background-color:#ffffff;padding:4px;border:1px solid #d4d4d4;width:auto;*/
	background-color:#ffffff;padding:4px;border-radius:4px;width:auto;
}

div.code {
	width:auto;border:1px solid #d4d4d4;background-color:#f1f1f1;color:#444444;padding:5px;margin:0;
}

div.code div {font-size:14px;}

div.example_code p,div.code p,div.code div {
	font-family:"courier new";
}

div.tryit_ex
{
clear:both;
width:600px;
height:50px;
margin-bottom:5px
}

div.tryit_ex img
{
border:0;
float:left;
margin-right:10px
}

div.tryit_ex h2
{
padding-top:5px
}

table { page-break-inside:auto }
tr    { page-break-inside:avoid; page-break-after:auto }

table.lamp
{
width:100%;
padding:0px;
border:1px solid #d4d4d4;
}

table.lamp th
{
color:#000000;
background-color:white;
padding:10px;
padding-right:5px;
}

table.lamp td
{
padding:4px;
padding-left:0px;
padding-right:10px;
background-color:#ffffff;
}
table.tecspec th,table.tecspec td{
	border:1px solid #d4d4d4;padding:5px;padding-top:7px;padding-bottom:7px;vertical-align:top;text-align:left;
}

table.reference,table.tecspec{
	border-collapse:collapse;width:100%;
        table-layout: auto;
        page-break-inside:auto;
}

table.reference tr:nth-child(odd)	{background-color:#f1f1f1;page-break-inside:avoid; page-break-after:auto}
table.reference tr:nth-child(even)	{background-color:#ffffff;page-break-inside:avoid; page-break-after:auto}

table.reference tr.fixzebra			{background-color:#f1f1f1;}

table.reference th{
	color:#ffffff;background-color:#3390FF;border:1px solid #555555;padding:3px;vertical-align:top;text-align:left;
}

table.reference th a:link,table.reference th a:visited{
	color:#ffffff;
}

table.reference th a:hover,table.reference th a:active{
	color:#EE872A;
}

table.reference td{
	border:1px solid #d4d4d4;padding:5px;padding-top:7px;padding-bottom:7px;vertical-align:top;
}

table.reference td.example_code
{
vertical-align:bottom;
}

table.summary
{
border:1px solid #d4d4d4;
padding:5px;
font-size:100%;
color:#555555;
background-color:#fafad2;
}

h2.example,h2.example_head
{
color:#444444;
/*color:#617f10;*/
background-color:transparent;
margin-top:0px;
}

h2.example {font-weight:normal;font-size:16px;}
h2.example_head {font-size:16px;}

h2.home
{
margin-top:0px;
margin-bottom:5px;
font-size:14px;
padding-top:1px;
padding-bottom:1px;
padding-left:1px;
color:#900B09;
background-color:#ffffff;
}

h2.left
{
color:#404040;
background-color:#ffffff;
font-size:14px;
margin-bottom:4px;
padding-bottom:0px;
margin-top:0px;
padding-top:0px;
font-weight:bold;
}

span.marked 	{color:#e80000;background-color:transparent;}
span.deprecated {color:#e80000;background-color:transparent;}

div.tutintro
{
width:auto;min-height:132px;
}

div.tutintro img
{
float:left;
margin-right:20px;
margin-bottom:10px;
}
div.tutintro p
{
margin-top:0px;
font-size:14px;
}

p.intro
{
font-size:14px;
color:#404040;
background-color:transparent;
margin-top:10px;
}

pre
{
font-family:"courier new";
font-size:13px;
margin-left:0;
margin-bottom:0;
}

img.float {float:left;}
img.navup
{
vertical-align:middle;
height:22px;
width:18px;
border:0px;
}

hr
{
background-color:#d4d4d4;
color:#d4d4d4;
height:1px;
border:0px;
clear:both;
}

a.example {font-weight:bold}

a:link,a:visited {color:#B72801; background-color:transparent}
a:hover,a:active {color:#E97700; background-color:transparent}

a:link,a:visited {color:#000000; background-color:transparent}
a:hover,a:active {color:#B72801; background-color:transparent}


a.plain:link,a.plain:visited {text-decoration:none;color:#900B09;background-color:transparent}
a.plain:hover,a.plain:active {text-decoration:underline;color:#FF0000;background-color:transparent}

a.header:link,a.header:visited {text-decoration:none;color:black;background-color:transparent}
a.header:hover,a.header:active {text-decoration:underline;color:black;background-color:transparent}

table.sitemap a:link,table.sitemap a:visited {text-decoration:none;color:black;background-color:transparent}
table.sitemap a:hover,table.sitemap a:active {text-decoration:underline;color:black;background-color:transparent}


.toprect_txt a:link,.toprect_txt a:visited {text-decoration:none;color:#900B09;background-color:transparent}
.toprect_txt a:hover,.toprect_txt a:active {text-decoration:underline;color:#FF0000;background-color:transparent}


a.m_item:link,a.m_item:visited {text-decoration:none;color:white; background-color:transparent}
a.m_item:hover,a.m_item:active {text-decoration:underline;color:white; background-color:transparent}

a.chapter:link    {text-decoration:none;color:#8AC007;background-color:transparent}
a.chapter:visited {text-decoration:none;color:#8AC007;background-color:transparent}
a.chapter:hover   {text-decoration:underline;color:#8AC007;background-color:transparent}
a.chapter:active  {text-decoration:none;color:#8AC007;background-color:transparent}

a.tryitbtn,a.tryitbtn:link,a.tryitbtn:visited,a.showbtn,a.showbtn:link,a.showbtn:visited
{
display:inline-block;
color:#FFFFFF;
background-color:#8AC007;
font-weight:bold;
font-size:12px;
text-align:center;
padding-left:10px;
padding-right:10px;
padding-top:3px;
padding-bottom:4px;
text-decoration:none;
margin-left:0;
/*margin-left:5px;*/
margin-top:0px;
margin-bottom:5px;
border:1px solid #aaaaaa;
border:1px solid #8AC007;
border-radius:5px;
white-space:nowrap;
}

a.tryitbtn:hover,a.tryitbtn:active,a.showbtn:hover,a.showbtn:active
{
background-color:#ffffff;color:#8AC007;
}

a.playitbtn,a.playitbtn:link,a.playitbtn:visited
{
display:inline-block;
color:#ffffff;
background-color:#FFAD33;
border:1px solid #FFAD33;
font-weight:bold;
font-size:11px;
text-align:center;
padding:10px;
padding-top:1px;
padding-bottom:2px;
text-decoration:none;
margin-left:1px;
border-radius:5px;
white-space:nowrap;
}

a.playitbtn:hover,a.playitbtn:active
{
background-color:#ffffff;color:#FFAD33;
}

a.tryitbtnsyntax:link,a.tryitbtnsyntax:visited,a.tryitbtnsyntax:active,a.tryitbtnsyntax:hover
{
font-family:verdana;
float:right;
padding-top:0px;
padding-bottom:1px;
background-color:#8AC007;
/*border:1px solid #aaaaaa;*/
border:1px solid #8AC007;
}

a.tryitbtnsyntax:active,a.tryitbtnsyntax:hover
{
color:#8AC007;;
background-color:#ffffff;
}

div.chapter,div.nav
{
font-size:17px;margin:0px;padding:0px;width:auto;height:20px;
}

div.chapter div.prev {width:40%;float:left;text-align:left;}
div.chapter div.next {width:48%;float:right;text-align:right;}

div.nav div.prev {width:33%;float:left;text-align:left;}
div.nav div.home {width:33%;float:left;text-align:center;}
div.nav div.next {width:33%;float:right;text-align:right;}

span.color_h1 {color:#8AC007;}
span.left_h2 {color:#8AC007;}

span.new
{
float:right;
color:#FFFFFF;
background-color:#8AC007;
font-weight:bold;
padding-left:1px;
padding-right:1px;
border:1px solid #ffffff;
outline:1px solid #8AC007;
}

.notsupported,.notsupported:hover,.notsupported:active,.notsupported:visited,.notsupported:link
{
color:rgb(197,128,128)
}

#err_form, #err_sent
{
color:#000000;
background-color:#f1f1f1;
border:1px solid #d4d4d4;
background-repeat:repeat-x;
padding:10px;
padding-bottom:0px;
width:auto;
z-index:1;
margin-left:auto;
margin-right:auto;
margin-top:10px;
display:none;
position:relative;
}

#err_form h2, #err_sent h2
{
margin-top:0px;	
}
#err_form label
{
display:block;
margin-bottom:3px;
}
#err_form input
{
border:1px solid gray;
width:590px;
height:16px;
display:block;
padding:4px;
}
#err_form textarea
{
border:1px solid gray;
width:590px;
height:100px;
padding:4px;
display:block;
}
#err_form .submit input
{
border:1px solid gray;
width:100px;
height:18px;
padding:0px;
padding-bottom:2px;
}
.err_close
{
width:68px;
padding:0px;
position:absolute;
top:5px;
right:5px;
text-decoration:underline;
cursor:pointer;
}

table#bottomlinks
{
border:none;
width:100%;
}

#bottomlinks td
{
text-align:left;
padding:10px;
vertical-align:top;
}

.bottomlinksraquo
{
font-weight:bold;
color:#ff4800;
}

#bottomlinks h3
{
font-size:14px;
font-weight:bold;
color:#555555;
}

#bottomlinks a
{
font-size:11px;
color:#555555;
text-decoration:none;
}

.html5badge {background-image:url('/images/html5_badge20.png'); background-repeat:no-repeat; background-position:right; }

.expandingMenu
{
width:170px;
overflow:hidden;
}

.expandingMenuItem
{
width:158px;
padding-left:12px;
margin-top:1px;
margin-bottom:0px;
}

.expandingMenuSelected
{
background-image:url('images/minus_arrow.gif');
background-repeat:no-repeat;
background-position:1px 7px;
}

.expandingMenuNotSelected
{
background-image:url('images/plus_arrow.gif');
background-repeat:no-repeat;
background-position:1px 7px;
}

#leftcolumn .expandingMenuHeader{
	cursor:pointer;margin-left:11px;margin-top:1px;margin-bottom:0px;padding:2px;
}
#leftcolumn .expandingMenuHeader:hover{
	text-decoration:underline;color:#000000;
}


#leftcolumn div.expandingMenuSelected .expandingMenuItem {
	width:170px;padding-left:0px;
}

div#google_translate_element .goog-te-gadget-simple
{
margin-top:2px;height:25px;padding:0px;border:1px solid #d9d9d9;
}

#google_translate_element a
{
font-size:11px;
color:#808080;
font-family:verdana;
}

#google_translate_element a:hover
{
color:#000000;
}

div.cse .gsc-control-cse, div.gsc-control-cse {
background-color: transparent;
border: none;
padding:0px;
margin:0px;
}

td.gsc-search-button input.gsc-search-button {
border-color: #555555;
background-color: #555555;
}

div.goog-te-gadget-simple {
font-size: 11pt;width:160px;
}

img.goog-te-gadget-icon {
margin-top: 3px;
}

td.gsc-search-button input.gsc-search-button-v2 {
width: 13px;
height: 13px;
margin-top: 4px;
padding: 6px 8px;
}

form.gsc-search-box-tools table.gsc-search-box td.gsc-input {
padding-right: 0px;
}

td.gsib_a {padding:0px;padding-top:4px;padding-left:3px;}
</style></head><body><font face="arial"><h1>STM32WB  BLE Wireless Interface</h1><p>This document describes the STM32WB  BLE Application Commands Interface (ACI) and Host Commands Interface (HCI).</p><p><a href="https://www.st.com/en/microcontrollers/stm32wb-series.html">STM32WB Series website</a></p><h2>Revision history</h2><p>December 2018 -  Rev 1.0  -  Rational: 1st Release for interface 1.0 </p><p>February 2019 - Rev 1.1 - Modified hci_hardware_event comments</p><p>March 2019 - Rev 1.2 - Removed hal datapump event documentation </p><p>March 2019 - Rev 1.3 - Modification ACI_HAL_FW_ERROR_EVENT error code</p><p>March 2019 - Rev 1.4 - Change default mask of HCI_SET_EVENT_MASK </p><p>May 2019   - Rev 1.5 - ACI_GATT_NOTIFICATION_EXT_EVENT added</p><p>June 2019  - Rev 1.6 - Change comment on usage of Char Handles in multiple ACI_GATT commands + Added ACI_GATT_NOTIFICATION_EXT_EVENT</p><p>June 2019 - Rev 1.7 - Change descriptions of ACI_ATT_READ_BY_TYPE_REQ and ACI_GATT_READ_USING_CHAR_UUID</p><p>July 2019 - Rev 1.8 - Reworked error codes section + Added GAP_ prefix to the GAP procedure bitmap definitions</p><h2>Contents</h2><p><a href="#HCI/ACI commands_anchor">HCI/ACI commands</a></p><p><a href="#HCI/ACI events_anchor">HCI/ACI events</a></p><p><a href="#Status error codes_anchor">Status error codes</a></p><h1><a name="HCI/ACI commands_anchor">HCI/ACI commands</a></h1><p><a href="#HCI commands_anchor">HCI commands</a></p><p><a href="#HCI TESTING commands_anchor">HCI TESTING commands</a></p><p><a href="#ACI HAL commands_anchor">ACI HAL commands</a></p><p><a href="#ACI GAP commands_anchor">ACI GAP commands</a></p><p><a href="#ACI GATT/ATT commands_anchor">ACI GATT/ATT commands</a></p><p><a href="#ACI L2CAP commands_anchor">ACI L2CAP commands</a></p><h2><a name="HCI commands_anchor">HCI commands</a></h2><h3>HCI commands</h3><table width="800" border="1" class="reference">
<tr><th>Command</th><th>OpCode</th></tr>
<tr><td><a href="#HCI_DISCONNECT_anchor">HCI_DISCONNECT</a></td><td><p>0x0406</p>
</td></tr>
<tr><td><a href="#HCI_READ_REMOTE_VERSION_INFORMATION_anchor">HCI_READ_REMOTE_VERSION_INFORMATION</a></td><td><p>0x041D</p>
</td></tr>
<tr><td><a href="#HCI_SET_EVENT_MASK_anchor">HCI_SET_EVENT_MASK</a></td><td><p>0x0C01</p>
</td></tr>
<tr><td><a href="#HCI_RESET_anchor">HCI_RESET</a></td><td><p>0x0C03</p>
</td></tr>
<tr><td><a href="#HCI_READ_TRANSMIT_POWER_LEVEL_anchor">HCI_READ_TRANSMIT_POWER_LEVEL</a></td><td><p>0x0C2D</p>
</td></tr>
<tr><td><a href="#HCI_SET_CONTROLLER_TO_HOST_FLOW_CONTROL_anchor">HCI_SET_CONTROLLER_TO_HOST_FLOW_CONTROL</a></td><td><p>0x0C31</p>
</td></tr>
<tr><td><a href="#HCI_HOST_BUFFER_SIZE_anchor">HCI_HOST_BUFFER_SIZE</a></td><td><p>0x0C33</p>
</td></tr>
<tr><td><a href="#HCI_HOST_NUMBER_OF_COMPLETED_PACKETS_anchor">HCI_HOST_NUMBER_OF_COMPLETED_PACKETS</a></td><td><p>0x0C35</p>
</td></tr>
<tr><td><a href="#HCI_READ_LOCAL_VERSION_INFORMATION_anchor">HCI_READ_LOCAL_VERSION_INFORMATION</a></td><td><p>0x1001</p>
</td></tr>
<tr><td><a href="#HCI_READ_LOCAL_SUPPORTED_COMMANDS_anchor">HCI_READ_LOCAL_SUPPORTED_COMMANDS</a></td><td><p>0x1002</p>
</td></tr>
<tr><td><a href="#HCI_READ_LOCAL_SUPPORTED_FEATURES_anchor">HCI_READ_LOCAL_SUPPORTED_FEATURES</a></td><td><p>0x1003</p>
</td></tr>
<tr><td><a href="#HCI_READ_BD_ADDR_anchor">HCI_READ_BD_ADDR</a></td><td><p>0x1009</p>
</td></tr>
<tr><td><a href="#HCI_READ_RSSI_anchor">HCI_READ_RSSI</a></td><td><p>0x1405</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_EVENT_MASK_anchor">HCI_LE_SET_EVENT_MASK</a></td><td><p>0x2001</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_BUFFER_SIZE_anchor">HCI_LE_READ_BUFFER_SIZE</a></td><td><p>0x2002</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_LOCAL_SUPPORTED_FEATURES_anchor">HCI_LE_READ_LOCAL_SUPPORTED_FEATURES</a></td><td><p>0x2003</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_RANDOM_ADDRESS_anchor">HCI_LE_SET_RANDOM_ADDRESS</a></td><td><p>0x2005</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_ADVERTISING_PARAMETERS_anchor">HCI_LE_SET_ADVERTISING_PARAMETERS</a></td><td><p>0x2006</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_ADVERTISING_CHANNEL_TX_POWER_anchor">HCI_LE_READ_ADVERTISING_CHANNEL_TX_POWER</a></td><td><p>0x2007</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_ADVERTISING_DATA_anchor">HCI_LE_SET_ADVERTISING_DATA</a></td><td><p>0x2008</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_SCAN_RESPONSE_DATA_anchor">HCI_LE_SET_SCAN_RESPONSE_DATA</a></td><td><p>0x2009</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_ADVERTISE_ENABLE_anchor">HCI_LE_SET_ADVERTISE_ENABLE</a></td><td><p>0x200A</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_SCAN_PARAMETERS_anchor">HCI_LE_SET_SCAN_PARAMETERS</a></td><td><p>0x200B</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_SCAN_ENABLE_anchor">HCI_LE_SET_SCAN_ENABLE</a></td><td><p>0x200C</p>
</td></tr>
<tr><td><a href="#HCI_LE_CREATE_CONNECTION_anchor">HCI_LE_CREATE_CONNECTION</a></td><td><p>0x200D</p>
</td></tr>
<tr><td><a href="#HCI_LE_CREATE_CONNECTION_CANCEL_anchor">HCI_LE_CREATE_CONNECTION_CANCEL</a></td><td><p>0x200E</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_WHITE_LIST_SIZE_anchor">HCI_LE_READ_WHITE_LIST_SIZE</a></td><td><p>0x200F</p>
</td></tr>
<tr><td><a href="#HCI_LE_CLEAR_WHITE_LIST_anchor">HCI_LE_CLEAR_WHITE_LIST</a></td><td><p>0x2010</p>
</td></tr>
<tr><td><a href="#HCI_LE_ADD_DEVICE_TO_WHITE_LIST_anchor">HCI_LE_ADD_DEVICE_TO_WHITE_LIST</a></td><td><p>0x2011</p>
</td></tr>
<tr><td><a href="#HCI_LE_REMOVE_DEVICE_FROM_WHITE_LIST_anchor">HCI_LE_REMOVE_DEVICE_FROM_WHITE_LIST</a></td><td><p>0x2012</p>
</td></tr>
<tr><td><a href="#HCI_LE_CONNECTION_UPDATE_anchor">HCI_LE_CONNECTION_UPDATE</a></td><td><p>0x2013</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_HOST_CHANNEL_CLASSIFICATION_anchor">HCI_LE_SET_HOST_CHANNEL_CLASSIFICATION</a></td><td><p>0x2014</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_CHANNEL_MAP_anchor">HCI_LE_READ_CHANNEL_MAP</a></td><td><p>0x2015</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_REMOTE_USED_FEATURES_anchor">HCI_LE_READ_REMOTE_USED_FEATURES</a></td><td><p>0x2016</p>
</td></tr>
<tr><td><a href="#HCI_LE_ENCRYPT_anchor">HCI_LE_ENCRYPT</a></td><td><p>0x2017</p>
</td></tr>
<tr><td><a href="#HCI_LE_RAND_anchor">HCI_LE_RAND</a></td><td><p>0x2018</p>
</td></tr>
<tr><td><a href="#HCI_LE_START_ENCRYPTION_anchor">HCI_LE_START_ENCRYPTION</a></td><td><p>0x2019</p>
</td></tr>
<tr><td><a href="#HCI_LE_LONG_TERM_KEY_REQUEST_REPLY_anchor">HCI_LE_LONG_TERM_KEY_REQUEST_REPLY</a></td><td><p>0x201A</p>
</td></tr>
<tr><td><a href="#HCI_LE_LONG_TERM_KEY_REQUESTED_NEGATIVE_REPLY_anchor">HCI_LE_LONG_TERM_KEY_REQUESTED_NEGATIVE_REPLY</a></td><td><p>0x201B</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_SUPPORTED_STATES_anchor">HCI_LE_READ_SUPPORTED_STATES</a></td><td><p>0x201C</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_DATA_LENGTH_anchor">HCI_LE_SET_DATA_LENGTH</a></td><td><p>0x2022</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH_anchor">HCI_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH</a></td><td><p>0x2023</p>
</td></tr>
<tr><td><a href="#HCI_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH_anchor">HCI_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH</a></td><td><p>0x2024</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_anchor">HCI_LE_READ_LOCAL_P256_PUBLIC_KEY</a></td><td><p>0x2025</p>
</td></tr>
<tr><td><a href="#HCI_LE_GENERATE_DHKEY_anchor">HCI_LE_GENERATE_DHKEY</a></td><td><p>0x2026</p>
</td></tr>
<tr><td><a href="#HCI_LE_ADD_DEVICE_TO_RESOLVING_LIST_anchor">HCI_LE_ADD_DEVICE_TO_RESOLVING_LIST</a></td><td><p>0x2027</p>
</td></tr>
<tr><td><a href="#HCI_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST_anchor">HCI_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST</a></td><td><p>0x2028</p>
</td></tr>
<tr><td><a href="#HCI_LE_CLEAR_RESOLVING_LIST_anchor">HCI_LE_CLEAR_RESOLVING_LIST</a></td><td><p>0x2029</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_RESOLVING_LIST_SIZE_anchor">HCI_LE_READ_RESOLVING_LIST_SIZE</a></td><td><p>0x202A</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_PEER_RESOLVABLE_ADDRESS_anchor">HCI_LE_READ_PEER_RESOLVABLE_ADDRESS</a></td><td><p>0x202B</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_LOCAL_RESOLVABLE_ADDRESS_anchor">HCI_LE_READ_LOCAL_RESOLVABLE_ADDRESS</a></td><td><p>0x202C</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_ADDRESS_RESOLUTION_ENABLE_anchor">HCI_LE_SET_ADDRESS_RESOLUTION_ENABLE</a></td><td><p>0x202D</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT_anchor">HCI_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT</a></td><td><p>0x202E</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_MAXIMUM_DATA_LENGTH_anchor">HCI_LE_READ_MAXIMUM_DATA_LENGTH</a></td><td><p>0x202F</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_PHY_anchor">HCI_LE_READ_PHY</a></td><td><p>0x2030</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_DEFAULT_PHY_anchor">HCI_LE_SET_DEFAULT_PHY</a></td><td><p>0x2031</p>
</td></tr>
<tr><td><a href="#HCI_LE_SET_PHY_anchor">HCI_LE_SET_PHY</a></td><td><p>0x2032</p>
</td></tr>
</table><h2><a name="HCI_DISCONNECT_anchor">HCI_DISCONNECT</a></h2><h3>Description</h3><p>The <a href="#HCI_DISCONNECT_anchor">HCI_DISCONNECT</a> is used to terminate an existing connection. The
Connection_Handle command parameter indicates which connection is to be
disconnected. The Reason command parameter indicates the reason for ending
the connection. The remote Controller will receive the Reason command
parameter in the <a href="#HCI_DISCONNECTION_COMPLETE_EVENT_anchor">HCI_DISCONNECTION_COMPLETE_EVENT</a> event. All synchronous connections
on a physical link should be disconnected before the ACL connection on the
same physical connection is disconnected.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.1.6)
It is important to leave an 100 ms blank window before sending any new command (including system hardware reset),
since immediately after <a href="#HCI_DISCONNECTION_COMPLETE_EVENT_anchor">HCI_DISCONNECTION_COMPLETE_EVENT</a> event, system could save important information in non volatile memory.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Reason</p>
</td><td><p>1</p>
</td><td><p>The reason for ending the connection.</p>
</td><td><li>0x05: Authentication Failure</li><li>0x13: Remote User Terminated Connection</li><li>0x14: Remote Device Terminated Connection due to Low Resources</li><li>0x15: Remote Device Terminated Connection due to Power Off</li><li>0x1A: Unsupported Remote Feature</li><li>0x3B: Unacceptable Connection Parameters</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_DISCONNECTION_COMPLETE_EVENT_anchor">HCI_DISCONNECTION_COMPLETE_EVENT</a></li><h2><a name="HCI_READ_REMOTE_VERSION_INFORMATION_anchor">HCI_READ_REMOTE_VERSION_INFORMATION</a></h2><h3>Description</h3><p>This command will obtain the values for the version information for the remote
device identified by the Connection_Handle parameter. The Connection_Handle
must be a Connection_Handle for an ACL or LE connection.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.1.23)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies which Connection_Handle's version information to get.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT_anchor">HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT</a></li><h2><a name="HCI_SET_EVENT_MASK_anchor">HCI_SET_EVENT_MASK</a></h2><h3>Description</h3><p>The Set_Event_Mask command is used to control which events are generated
by the HCI for the Host.

If the bit in the Event_Mask is set to a one, then the
event associated with that bit will be enabled. For an LE Controller, the LE
Meta Event bit in the Event_Mask shall enable or disable all LE events in the
LE Meta Event (see Section 7.7.65). The Host has to deal with each event that
occurs. The event mask allows the Host to control how much it is interrupted.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.3.1)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Event_Mask</p>
</td><td><p>8</p>
</td><td><p>Event mask. Default: 0x20001FFFFFFFFFFF</p>
</td><td><p>Bitmask of:</p><br><li>0x0000000000000000: No events specified</li><li>0x0000000000000001: Inquiry Complete Event</li><li>0x0000000000000002: Inquiry Result Event</li><li>0x0000000000000004: Connection Complete Event</li><li>0x0000000000000008: Connection Request Event</li><li>0x0000000000000010: Disconnection Complete Event</li><li>0x0000000000000020: Authentication Complete Event</li><li>0x0000000000000040: Remote Name Request Complete Event</li><li>0x0000000000000080: Encryption Change Event</li><li>0x0000000000000100: Change Connection Link Key Complete Event</li><li>0x0000000000000200: Master Link Key Complete Event</li><li>0x0000000000000400: Read Remote Supported Features Complete Event</li><li>0x0000000000000800: Read Remote Version Information Complete Event</li><li>0x0000000000001000: QoS Setup Complete Event</li><li>0x0000000000008000: Hardware Error Event</li><li>0x0000000000010000: Flush Occurred Event</li><li>0x0000000000020000: Role Change Event</li><li>0x0000000000080000: Mode Change Event</li><li>0x0000000000100000: Return Link Keys Event</li><li>0x0000000000200000: PIN Code Request Event</li><li>0x0000000000400000: Link Key Request Event</li><li>0x0000000000800000: Link Key Notification Event</li><li>0x0000000001000000: Loopback Command Event</li><li>0x0000000002000000: Data Buffer Overflow Event</li><li>0x0000000004000000: Max Slots Change Event</li><li>0x0000000008000000: Read Clock Offset Complete Event</li><li>0x0000000010000000: Connection Packet Type Changed Event</li><li>0x0000000020000000: QoS Violation Event</li><li>0x0000000040000000: Page Scan Mode Change Event</li><li>0x0000000080000000: Page Scan Repetition Mode Change Event</li><li>0x0000000100000000: Flow Specification Complete Event</li><li>0x0000000200000000: Inquiry Result with RSSI Event</li><li>0x0000000400000000: Read Remote Extended Features Complete Event</li><li>0x0000080000000000: Synchronous Connection Complete Event</li><li>0x0000100000000000: Synchronous Connection Changed Event</li><li>0x0000200000000000: Sniff Subrating Event</li><li>0x0000400000000000: Extended Inquiry Result Event</li><li>0x0000800000000000: Encryption Key Refresh Complete Event</li><li>0x0001000000000000: IO Capability Request Event</li><li>0x0002000000000000: IO Capability Request Reply Event</li><li>0x0004000000000000: User Confirmation Request Event</li><li>0x0008000000000000: User Passkey Request Event</li><li>0x0010000000000000: Remote OOB Data Request Event</li><li>0x0020000000000000: Simple Pairing Complete Event</li><li>0x0080000000000000: Link Supervision Timeout Changed Event</li><li>0x0100000000000000: Enhanced Flush Complete Event</li><li>0x0400000000000000: User Passkey Notification Event</li><li>0x0800000000000000: Keypress Notification Event</li><li>0x1000000000000000: Remote Host Supported Features Notification Event</li><li>0x2000000000000000: LE Meta-Event</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_RESET_anchor">HCI_RESET</a></h2><h3>Description</h3><p>The Reset command will reset the Link Layer on an LE
Controller.

The Reset command shall not affect the used HCI transport layer since the HCI transport
layers may have reset mechanisms of their own. After the reset is completed,
the current operational state will be lost, the Controller will enter standby mode
and the Controller will automatically revert to the default values for the parameters
for which default values are defined in the specification.
Note: The Reset command will not necessarily perform a hardware reset. This
is implementation defined. 
The Host shall not send additional HCI commands before the Command Complete
event related to the Reset command has been received.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.3.2)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_READ_TRANSMIT_POWER_LEVEL_anchor">HCI_READ_TRANSMIT_POWER_LEVEL</a></h2><h3>Description</h3><p>This command reads the values for the Transmit_Power_Level parameter for
the specified Connection_Handle. The Connection_Handle shall be a Connection_Handle
for an ACL connection.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.3.35)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Specifies which Connection_Handle's Transmit Power Level setting to read.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Type</p>
</td><td><p>1</p>
</td><td><p>Current or maximum transmit power level.</p>
</td><td><li>0x00: Read Current Transmit Power Level.</li><li>0x01: Read Maximum Transmit Power Level.</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Transmit_Power_Level</p>
</td><td><p>1</p>
</td><td><p>Size: 1 Octet (signed integer)
Units: dBm</p>
</td><td><li>-30 ... 20</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_SET_CONTROLLER_TO_HOST_FLOW_CONTROL_anchor">HCI_SET_CONTROLLER_TO_HOST_FLOW_CONTROL</a></h2><h3>Description</h3><p>This command is used by the Host to turn flow control on or off for data and/or
voice sent in the direction from the Controller to the Host. If flow control is turned
off, the Host should not send the Host_Number_Of_Completed_Packets
command. That command will be ignored by the Controller if it is sent by the
Host and flow control is off. If flow control is turned on for HCI ACL Data Packets
and off for HCI synchronous Data Packets,
Host_Number_Of_Completed_Packets commands sent by the Host should only
contain Connection_Handles for ACL connections. If flow control is turned off for
HCI ACL Data Packets and on for HCI synchronous Data Packets,
Host_Number_Of_Completed_Packets commands sent by the Host should only
contain Connection_Handles for synchronous connections. If flow control is
turned on for HCI ACL Data Packets and HCI synchronous Data Packets, the
Host will send Host_Number_Of_Completed_Packets commands both for ACL
connections and synchronous connections.
The Flow_Control_Enable parameter shall only be changed if no connections
exist. See Bluetooth Spec v.5.0, Vol. 2, Part E, 7.3.38</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Flow_Control_Enable</p>
</td><td><p>1</p>
</td><td><p>Enable/Disable the Flow Control</p>
</td><td><li>0x00: Flow control off in direction from Controller to Host. Default.</li><li>0x01: Flow control on for HCI ACL Data Packets and off for HCI synchronous.Data Packets in direction from Controller to Host.</li><li>0x02: Flow control off for HCI ACL Data Packets and on for HCI synchronous.Data Packets in direction from Controller to Host.</li><li>0x03: Flow control on both for HCI ACL Data Packets and HCI synchronous.Data Packets in direction from Controller to Host.</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><h2><a name="HCI_HOST_BUFFER_SIZE_anchor">HCI_HOST_BUFFER_SIZE</a></h2><h3>Description</h3><p>The Host_Buffer_Size command is used by the Host to notify the Controller
about the maximum size of the data portion of HCI ACL and synchronous Data
Packets sent from the Controller to the Host. The Controller shall segment the
data to be transmitted from the Controller to the Host according to these sizes,
so that the HCI Data Packets will contain data with up to these sizes. The
Host_Buffer_Size command also notifies the Controller about the total number
of HCI ACL and synchronous Data Packets that can be stored in the data
buffers of the Host. If flow control from the Controller to the Host is turned off,
and the Host_Buffer_Size command has not been issued by the Host, this
means that the Controller will send HCI Data Packets to the Host with any
lengths the Controller wants to use, and it is assumed that the data buffer sizes
of the Host are unlimited. If flow control from the Controller to the Host is turned
on, the Host_Buffer_Size command shall after a power-on or a reset always be
sent by the Host before the first Host_Number_Of_Completed_Packets
command is sent.
The Set Controller To Host Flow Control Command is used to turn flow control
on or off. The Host_ACL_Data_Packet_Length command parameter will be
used to determine the size of the L2CAP segments contained in ACL Data
Packets, which are transferred from the Controller to the Host. The
Host_Synchronous_Data_Packet_Length command parameter is used to
determine the maximum size of HCI synchronous Data Packets. Both the Host
and the Controller shall support command and event packets, where the data
portion (excluding header) contained in the packets is 255 octets in size.
The Host_Total_Num_ACL_Data_Packets command parameter contains the
total number of HCI ACL Data Packets that can be stored in the data buffers of
the Host. The Controller will determine how the buffers are to be divided
between different Connection_Handles. The Host_Total_Num_Synchronous_
Data_Packets command parameter gives the same information for HCI
synchronous Data Packets.
Note: The Host_ACL_Data_Packet_Length and Host_Synchronous_Data_
Packet_Length command parameters do not include the length of the HCI Data
Packet header. See Bluetooth Spec v.5.0, Vol. 2, Part E, 7.3.39</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Host_ACL_Data_Packet_Length</p>
</td><td><p>2</p>
</td><td><p>Maximum length (in octets) of the data portion of each HCI ACL Data Packet that the Host is able to accept. Must be greater or equal to 251 bytes</p>
</td><td></tr>
<tr><td><p>Host_Synchronous_Data_Packet_Length</p>
</td><td><p>1</p>
</td><td><p>Maximum length (in octets) of the data portion of each HCI synchronous Data Packet that the Host is able to accept.</p>
</td><td></tr>
<tr><td><p>Host_Total_Num_ACL_Data_Packets</p>
</td><td><p>2</p>
</td><td><p>Total number of HCI ACL Data Packets that can be stored in the data buffers of the Host.</p>
</td><td></tr>
<tr><td><p>Host_Total_Num_Synchronous_Data_Packets</p>
</td><td><p>2</p>
</td><td><p>Total number of HCI synchronous Data Packets that can be stored in the data buffers of the Host.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><h2><a name="HCI_HOST_NUMBER_OF_COMPLETED_PACKETS_anchor">HCI_HOST_NUMBER_OF_COMPLETED_PACKETS</a></h2><h3>Description</h3><p>The Host_Number_Of_Completed_Packets command is used by the Host to
indicate to the Controller the number of HCI Data Packets that have been
completed for each Connection_Handle since the previous Host_Number_Of_
Completed_Packets command was sent to the Controller. This means that the
corresponding buffer space has been freed in the Host. Based on this
information, and the Host_Total_Num_ACL_Data_Packets and
Host_Total_Num_Synchronous_Data_Packets command parameters of the
Host_Buffer_Size command, the Controller can determine for which
Connection_Handles the following HCI Data Packets should be sent to the
Host. The command should only be issued by the Host if flow control in the
direction from the Controller to the Host is on and there is at least one
connection, or if the Controller is in local loopback mode. Otherwise, the
command will be ignored by the Controller. When the Host has completed one
or more HCI Data Packet(s) it shall send a
Host_Number_Of_Completed_Packets command to the Controller, until it
finally reports that all pending HCI Data Packets have been completed. The
frequency at which this command is sent is manufacturer specific.
The Set Controller To Host Flow Control Command is used to turn flow control on
or off. If flow control from the Controller to the Host is turned on, the
Host_Buffer_Size command shall always be sent by the Host after a power-on or
a reset before the first Host_Number_Of_Completed_Packets command is sent.
Note: The Host_Number_Of_Completed_Packets command is a special
command in the sense that no event is normally generated after the command
has completed. The command may be sent at any time by the Host when there
is at least one connection, or if the Controller is in local loopback mode
independent of other commands. The normal flow control for commands is not
used for the Host_Number_Of_Completed_Packets command. See Bluetooth Spec v.5.0, Vol. 2, Part E, 7.3.40</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Number_Of_Handles</p>
</td><td><p>1</p>
</td><td><p>The number of Connection_Handles and Host_Num_Of_Completed_Packets        parameters pairs contained in this command.</p>
</td><td><p>0-255</p>
</td></tr>
<tr><td><p>Connection_Handle[i]</p>
</td><td><p>Number_Of_Handles * 2</p>
</td><td><p>Connection_Handle</p>
</td><td><p>0x0000-0x0EFF</p>
</td></tr>
<tr><td><p>Host_Num_Of_Completed_Packets[i]</p>
</td><td><p>Number_Of_Handles * 2</p>
</td><td><p>The number of HCI Data Packets         that have been completed for the associated Connection_Handle since the previous time the event was returned.</p>
</td><td><p>0x0000-0xFFFF</p>
</td></tr>
</table><h3>Output parameters</h3><p>None</p><p> </p><p>Event(s) generated (unless masked away):                        Normally, no event is generated after the Host_Number_Of_Completed_Packets command has completed.                        However, if the Host_Number_Of_Completed_Packets command contains one or more invalid parameters, the                        Controller shall return a Command Complete event with a failure status                        indicating the Invalid HCI Command Parameters error code. The Host may                        send the Host_Number_Of_Completed_Packets command at any time when                        there is at least one connection, or if the Controller is in local loopback mode.                        The normal flow control for commands is not used for this command.</p><h2><a name="HCI_READ_LOCAL_VERSION_INFORMATION_anchor">HCI_READ_LOCAL_VERSION_INFORMATION</a></h2><h3>Description</h3><p>This command reads the values for the version information for the local Controller.
The HCI Version information defines the version information of the HCI layer.
The LMP/PAL Version information defines the version of the LMP or PAL. The
Manufacturer_Name information indicates the manufacturer of the local device.
The HCI Revision and LMP/PAL Subversion are implementation dependent.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.4.1)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>HCI_Version</p>
</td><td><p>1</p>
</td><td><p>See Bluetooth Assigned Numbers (<a class="reference external" href="https://www.bluetooth.org/en-us/specification/assigned-numbers">https://www.bluetooth.org/en-us/specification/assigned-numbers</a>)</p>
</td><td></tr>
<tr><td><p>HCI_Revision</p>
</td><td><p>2</p>
</td><td><p>Revision of the Current HCI in the BR/EDR Controller.</p>
</td><td></tr>
<tr><td><p>LMP_PAL_Version</p>
</td><td><p>1</p>
</td><td><p>Version of the Current LMP or PAL in the Controller.
See Bluetooth Assigned Numbers (<a class="reference external" href="https://www.bluetooth.org/en-us/specification/assigned-numbers">https://www.bluetooth.org/en-us/specification/assigned-numbers</a>)</p>
</td><td></tr>
<tr><td><p>Manufacturer_Name</p>
</td><td><p>2</p>
</td><td><p>Manufacturer Name of the BR/EDR Controller.
See Bluetooth Assigned Numbers (<a class="reference external" href="https://www.bluetooth.org/en-us/specification/assigned-numbers">https://www.bluetooth.org/en-us/specification/assigned-numbers</a>)</p>
</td><td></tr>
<tr><td><p>LMP_PAL_Subversion</p>
</td><td><p>2</p>
</td><td><p>Subversion of the Current LMP or PAL in the Controller. This value is
implementation dependent.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_READ_LOCAL_SUPPORTED_COMMANDS_anchor">HCI_READ_LOCAL_SUPPORTED_COMMANDS</a></h2><h3>Description</h3><p>This command reads the list of HCI commands supported for the local Controller.
This command shall return the Supported_Commands configuration parameter.
It is implied that if a command is listed as supported, the feature underlying
that command is also supported.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.4.2)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Supported_Commands</p>
</td><td><p>64</p>
</td><td><p>Bit mask for each HCI Command. If a bit is 1, the Controller supports the
corresponding command and the features required for the command.
Unsupported or undefined commands shall be set to 0.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_READ_LOCAL_SUPPORTED_FEATURES_anchor">HCI_READ_LOCAL_SUPPORTED_FEATURES</a></h2><h3>Description</h3><p>This command requests a list of the supported features for the local 
Controller. This command will return a list of the LMP features. For details see
Part C, Link Manager Protocol Specification on page 227.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.4.3)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>LMP_Features</p>
</td><td><p>8</p>
</td><td><p>Bit Mask List of LMP features.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_READ_BD_ADDR_anchor">HCI_READ_BD_ADDR</a></h2><h3>Description</h3><p>On an LE Controller, this command shall read the Public Device Address as
defined in [Vol 6] Part B, Section 1.3, Device Address. If this Controller does
not have a Public Device Address, the value 0x000000000000 shall be
returned.
On an LE Controller, the public address shall be the same as the
BD_ADDR.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.4.6)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>BD_ADDR</p>
</td><td><p>6</p>
</td><td><p>BD_ADDR ( Bluetooth Device Address) of the Device.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_READ_RSSI_anchor">HCI_READ_RSSI</a></h2><h3>Description</h3><p>This command reads the Received Signal Strength Indication (RSSI) value from
a Controller.
For an LE transport, a Connection_Handle is used as the Handle command
parameter and return parameter. The meaning of the RSSI metric is an absolute
receiver signal strength value in dBm to +/- 6 dB accuracy. If the RSSI cannot
be read, the RSSI metric shall be set to 127.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.5.4)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>RSSI</p>
</td><td><p>1</p>
</td><td><p>N Size: 1 Octet (signed integer)
Units: dBm</p>
</td><td><li>127: RSSI not available</li><li>-127 ... 20</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_EVENT_MASK_anchor">HCI_LE_SET_EVENT_MASK</a></h2><h3>Description</h3><p>The LE_Set_Event_Mask command is used to control which LE events are
generated by the HCI for the Host. If the bit in the LE_Event_Mask is set to a
one, then the event associated with that bit will be enabled. The Host has to
deal with each event that is generated by an LE Controller. The event mask
allows the Host to control which events will interrupt it.
For LE events to be generated, the LE Meta-Event bit in the Event_Mask shall
also be set. If that bit is not set, then LE events shall not be generated, regardless
of how the LE_Event_Mask is set.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.1)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Event_Mask</p>
</td><td><p>8</p>
</td><td><p>LE event mask. Default: 0x00000000000FFFFF.</p>
</td><td><p>Bitmask of:</p><br><li>0x0000000000000000: No LE events specified</li><li>0x0000000000000001: LE Connection Complete Event</li><li>0x0000000000000002: LE Advertising Report Event</li><li>0x0000000000000004: LE Connection Update Complete Event</li><li>0x0000000000000008: LE Read Remote Used Features Complete Event</li><li>0x0000000000000010: LE Long Term Key Request Event</li><li>0x0000000000000020: LE Remote Connection Parameter Request Event</li><li>0x0000000000000040: LE Data Length Change Event</li><li>0x0000000000000080: LE Read Local P-256 Public Key Complete Event</li><li>0x0000000000000100: LE Generate DHKey Complete Event</li><li>0x0000000000000200: LE Enhanced Connection Complete Event</li><li>0x0000000000000400: LE Direct Advertising Report Event</li><li>0x0000000000000800: LE PHY Update Complete Event</li><li>0x0000000000001000: LE Extended Advertising Report Event</li><li>0x0000000000002000: LE Periodic Advertising Sync Established Event</li><li>0x0000000000004000: LE Periodic Advertising Report Event</li><li>0x0000000000008000: LE Periodic Advertising Sync Lost Event</li><li>0x0000000000010000: LE Extended Scan Timeouout Event</li><li>0x0000000000020000: LE Extended Advertising Set Terminated Event</li><li>0x0000000000040000: LE Scan Request Received Event</li><li>0x0000000000080000: LE Channel Selection Algorithm Event</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_BUFFER_SIZE_anchor">HCI_LE_READ_BUFFER_SIZE</a></h2><h3>Description</h3><p>The LE_Read_Buffer_Size command is used to read the maximum size of the
data portion of HCI LE ACL Data Packets sent from the Host to the Controller.
The Host will segment the data transmitted to the Controller according to these
values, so that the HCI Data Packets will contain data with up to this size. The
LE_Read_Buffer_Size command also returns the total number of HCI LE ACL
Data Packets that can be stored in the data buffers of the Controller. The
LE_Read_Buffer_Size command must be issued by the Host before it sends
any data to an LE Controller (see Section 4.1.1).
If the Controller returns a length value of zero, the Host shall use the
Read_Buffer_Size command to determine the size of the data buffers
Note: Both the Read_Buffer_Size and LE_Read_Buffer_Size commands may
return buffer length and number of packets parameter values that are nonzero.
The HC_LE_ACL_Data_Packet_Length return parameter shall be used to
determine the size of the L2CAP PDU segments contained in ACL Data
Packets, which are transferred from the Host to the Controller to be broken up
into packets by the Link Layer. Both the Host and the Controller shall support
command and event packets, where the data portion (excluding header)
contained in the packets is 255 octets in size. The
HC_Total_Num_LE_ACL_Data_Packets return parameter contains the total
number of HCI ACL Data Packets that can be stored in the data buffers of the
Controller. The Host determines how the buffers are to be divided between
different Connection Handles.
Note: The HC_LE_ACL_Data_Packet_Length return parameter does not
include the length of the HCI Data Packet header.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.2)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>HC_LE_ACL_Data_Packet_Length</p>
</td><td><p>2</p>
</td><td><p>0x0000 No dedicated LE Buffer - use Read_Buffer_Size command.
0x0001 - 0xFFFF Maximum length (in octets) of the data portion of each HCI ACL Data
Packet that the Controller is able to accept.</p>
</td><td></tr>
<tr><td><p>HC_Total_Num_LE_ACL_Data_Packets</p>
</td><td><p>1</p>
</td><td><p>0x00 No dedicated LE Buffer - use Read_Buffer_Size command.
0x01 - 0xFF Total number of HCI ACL Data Packets that can be stored in the data
buffers of the Controller.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_LOCAL_SUPPORTED_FEATURES_anchor">HCI_LE_READ_LOCAL_SUPPORTED_FEATURES</a></h2><h3>Description</h3><p>This command requests the list of the supported LE features for the Controller.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.3)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>LE_Features</p>
</td><td><p>8</p>
</td><td><p>Bit Mask List of LE features. See Core v5.0, Vol. 6, Part B, Section 4.6.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_RANDOM_ADDRESS_anchor">HCI_LE_SET_RANDOM_ADDRESS</a></h2><h3>Description</h3><p>The LE_Set_Random_Address command is used by the Host to set the LE
Random Device Address in the Controller (see [Vol 6] Part B, Section 1.3).
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.4)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Random_Address</p>
</td><td><p>6</p>
</td><td><p>Random Device Address.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_ADVERTISING_PARAMETERS_anchor">HCI_LE_SET_ADVERTISING_PARAMETERS</a></h2><h3>Description</h3><p>The LE_Set_Advertising_Parameters command is used by the Host to set the
advertising parameters.
The Advertising_Interval_Min shall be less than or equal to the Advertising_Interval_Max.
The Advertising_Interval_Min and Advertising_Interval_Max
should not be the same value to enable the Controller to determine the best
advertising interval given other activities.
For high duty cycle directed advertising, i.e. when Advertising_Type is 0x01
(ADV_DIRECT_IND, high duty cycle), the Advertising_Interval_Min and Advertising_Interval_Max
parameters are not used and shall be ignored.
The Advertising_Type is used to determine the packet type that is used for
advertising when advertising is enabled.
The Advertising_Interval_Min and Advertising_Interval_Max shall not be set to
less than 0x00A0 (100 ms) if the Advertising_Type is set to 0x02 (ADV_SCAN_IND)
or 0x03 (ADV_NONCONN_IND). The Own_Address_Type determines
if the advertising packets are identified with the Public Device Address of
the device, or a Random Device Address as written by the LE_Set_Random_Address
command.
If directed advertising is performed, i.e. when Advertising_Type is set to 0x01
(ADV_DIRECT_IND, high duty cycle) or 0x04 (ADV_DIRECT_IND, low duty
cycle mode), then the Direct_Address_Type and Direct_Address shall be valid,
otherwise they shall be ignored by the Controller and not used.
The Advertising_Channel_Map is a bit field that indicates the advertising channels
that shall be used when transmitting advertising packets. At least one
channel bit shall be set in the Advertising_Channel_Map parameter.
The Advertising_Filter_Policy parameter shall be ignored when directed advertising
is enabled.
The Host shall not issue this command when advertising is enabled in the Controller;
if it is the Command Disallowed error code shall be used.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.5)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum advertising interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Advertising_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum advertising interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Advertising_Type</p>
</td><td><p>1</p>
</td><td><p>Advertising type.</p>
</td><td><li>0x00: ADV_IND (Connectable undirected advertising)</li><li>0x01: ADV_DIRECT_IND, high duty cycle (Connectable high duty cycle directed advertising)</li><li>0x02: ADV_SCAN_IND (Scannable undirected advertising)</li><li>0x03: ADV_NONCONN_IND (Non connectable undirected advertising)</li><li>0x04: ADV_DIRECT_IND, low duty cycle (Connectable low duty cycle directed advertising)</li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Own address type.</dt>
<dd><ul class="first last simple">
<li>0x00: Public Device Address</li>
<li>0x01 Random Device Address</li>
<li><dl class="first docutils">
<dt>0x02: Controller generates Resolvable Private Address based on the local</dt>
<dd>IRK from resolving list. If resolving list contains no matching entry,
use public address.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>0x03: Controller generates Resolvable Private Address based on the local</dt>
<dd>IRK from resolving list. If resolving list contains no matching entry,
use random address from LE_Set_Random_Address.</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Resolvable Private Address or Public Address</li><li>0x03: Resolvable Private Address or Random Address</li></td></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>The address type of the peer device.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address, Random Device Address, Public Identity
Address or Random (static) Identity Address of the device to be connected.</p>
</td><td></tr>
<tr><td><p>Advertising_Channel_Map</p>
</td><td><p>1</p>
</td><td><p>Advertising channel map.
Default: 00000111b (all channels enabled).</p>
</td><td><p>Bitmask of:</p><br><li>0x01: ch 37</li><li>0x02: ch 38</li><li>0x04: ch 39</li></td></tr>
<tr><td><p>Advertising_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>Advertising filter policy.</p>
</td><td><li>0x00: Allow Scan Request from Any, Allow Connect Request from Any</li><li>0x01: Allow Scan Request from White List Only, Allow Connect Request from Any</li><li>0x02: Allow Scan Request from Any, Allow Connect Request from White List Only</li><li>0x03: Allow Scan Request from White List Only, Allow Connect Request from White List Only</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_ADVERTISING_CHANNEL_TX_POWER_anchor">HCI_LE_READ_ADVERTISING_CHANNEL_TX_POWER</a></h2><h3>Description</h3><p>The LE_Read_Advertising_Channel_Tx_Power command is used by the Host
to read the transmit power level used for LE advertising channel packets.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.6)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Transmit_Power_Level</p>
</td><td><p>1</p>
</td><td><p>Size: 1 Octet (signed integer)
Units: dBm
Accuracy: +/- 4 dBm</p>
</td><td><li>-20 ... 10</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_ADVERTISING_DATA_anchor">HCI_LE_SET_ADVERTISING_DATA</a></h2><h3>Description</h3><p>The LE_Set_Advertising_Data command is used to set the data used in advertising
packets that have a data field.
Only the significant part of the Advertising_Data is transmitted in the advertising
packets, as defined in [Vol 3] Part C, Section 11.,
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.7)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Data_Length</p>
</td><td><p>1</p>
</td><td><p>The number of significant octets in the following data field</p>
</td><td></tr>
<tr><td><p>Advertising_Data</p>
</td><td><p>31</p>
</td><td><p>31 octets of data formatted as defined in [Vol 3] Part C, Section 11.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_SCAN_RESPONSE_DATA_anchor">HCI_LE_SET_SCAN_RESPONSE_DATA</a></h2><h3>Description</h3><p>This command is used to provide data used in Scanning Packets that have a
data field.
Only the significant part of the Scan_Response_Data is transmitted in the
Scanning Packets, as defined in [Vol 3] Part C, Section 11.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.8)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Scan_Response_Data_Length</p>
</td><td><p>1</p>
</td><td><p>The number of significant octets in the following data field</p>
</td><td></tr>
<tr><td><p>Scan_Response_Data</p>
</td><td><p>31</p>
</td><td><p>31 octets of data formatted as defined in [Vol 3] Part C, Section 11.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_ADVERTISE_ENABLE_anchor">HCI_LE_SET_ADVERTISE_ENABLE</a></h2><h3>Description</h3><p>The LE_Set_Advertise_Enable command is used to request the Controller to
start or stop advertising. The Controller manages the timing of advertisements
as per the advertising parameters given in the LE_Set_Advertising_Parameters
command.
The Controller shall continue advertising until the Host issues an LE_Set_Advertise_Enable
command with Advertising_Enable set to 0x00 (Advertising is
disabled) or until a connection is created or until the Advertising is timed out
due to high duty cycle Directed Advertising. In these cases, advertising is then
disabled.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.9)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Enable</p>
</td><td><p>1</p>
</td><td><p>Enable/disable advertise. Default is 0 (disabled).</p>
</td><td><li>0x00: Advertising is disabled</li><li>0x01: Advertising is enabled</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_SCAN_PARAMETERS_anchor">HCI_LE_SET_SCAN_PARAMETERS</a></h2><h3>Description</h3><p>The LE_Set_Scan_Parameters command is used to set the scan parameters.
The LE_Scan_Type parameter controls the type of scan to perform.
The LE_Scan_Interval and LE_Scan_Window parameters are recommendations
from the Host on how long (LE_Scan_Window) and how frequently
(LE_Scan_Interval) the Controller should scan (See [Vol 6] Part B, Section
4.4.3). The LE_Scan_Window parameter shall always be set to a value smaller
or equal to the value set for the LE_Scan_Interval parameter. If they are set to
the same value scanning should be run continuously.
The Own_Address_Type parameter determines the address used (Public or
Random Device Address) when performing active scan.
The Host shall not issue this command when scanning is enabled in the Controller;
if it is the Command Disallowed error code shall be used.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.10)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Type</p>
</td><td><p>1</p>
</td><td><p>Passive or active scanning. With active scanning SCAN_REQ packets are sent.</p>
</td><td><li>0x00: Passive Scanning</li><li>0x01: Active scanning</li></td></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started
its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window
shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Own address type.</dt>
<dd><ul class="first last simple">
<li>0x00: Public Device Address</li>
<li>0x01 Random Device Address</li>
<li><dl class="first docutils">
<dt>0x02: Controller generates Resolvable Private Address based on the local</dt>
<dd>IRK from resolving list. If resolving list contains no matching entry,
use public address.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>0x03: Controller generates Resolvable Private Address based on the local</dt>
<dd>IRK from resolving list. If resolving list contains no matching entry,
use random address from LE_Set_Random_Address.</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Resolvable Private Address or Public Address</li><li>0x03: Resolvable Private Address or Random Address</li></td></tr>
<tr><td><p>Scanning_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>0x00 Accept all advertisement packets.
Directed advertising packets which are not addressed for this device
shall be ignored.
0x01 Ignore advertisement packets from devices not in the White List Only.
Directed advertising packets which are not addressed for this device
shall be ignored
0x02 Accept all undirected advertisement packets.
Directed advertisement packets where initiator address is a RPA and
Directed advertisement packets addressed to this device shall be accepted.
0x03 Accept all undirected advertisement packets from devices that are in
the White List.Directed advertisement packets where initiator address is RPA and Directed advertisement packets addressed to this device shall be accepted.</p>
</td><td><li>0x00: Accept all</li><li>0x01: Ignore devices not in the White List</li><li>0x02: Accept all (use resolving list)</li><li>0x03: Ignore devices not in the White List (use resolving list)</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_SCAN_ENABLE_anchor">HCI_LE_SET_SCAN_ENABLE</a></h2><h3>Description</h3><p>The LE_Set_Scan_Enable command is used to start scanning. Scanning is
used to discover advertising devices nearby.
The Filter_Duplicates parameter controls whether the Link Layer shall filter
duplicate advertising reports to the Host, or if the Link Layer should generate
advertising reports for each packet received.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.11)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Enable</p>
</td><td><p>1</p>
</td><td><p>Enable/disable scan. Default is 0 (disabled).</p>
</td><td><li>0x00: Scanning disabled</li><li>0x01: Scanning enabled</li></td></tr>
<tr><td><p>Filter_Duplicates</p>
</td><td><p>1</p>
</td><td><p>Enable/disable duplicate filtering.</p>
</td><td><li>0x00: Duplicate filtering disabled</li><li>0x01: Duplicate filtering enabled</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a></li><h2><a name="HCI_LE_CREATE_CONNECTION_anchor">HCI_LE_CREATE_CONNECTION</a></h2><h3>Description</h3><p>The LE_Create_Connection command is used to create a Link Layer connection
to a connectable advertiser.
The LE_Scan_Interval and LE_Scan_Window parameters are recommendations
from the Host on how long (LE_Scan_Window) and how frequently
(LE_Scan_Interval) the Controller should scan. The LE_Scan_Window parameter
shall be set to a value smaller or equal to the value set for the LE_Scan_Interval
parameter. If both are set to the same value, scanning should run
continuously.
The Initiator_Filter_Policy is used to determine whether the White List is used.
If the White List is not used, the Peer_Address_Type and the Peer_Address
parameters specify the address type and address of the advertising device to
connect to.
The Link Layer shall set the address in the CONNECT_REQ packets to either
the Public Device Address or the Random Device Addressed based on the
Own_Address_Type parameter.
The Conn_Interval_Min and Conn_Interval_Max parameters define the minimum
and maximum allowed connection interval. The Conn_Interval_Min
parameter shall not be greater than the Conn_Interval_Max parameter.
The Conn_Latency parameter defines the maximum allowed connection
latency (see [Vol 6] Part B, Section 4.5.1).
The Supervision_Timeout parameter defines the link supervision timeout for
the connection. The Supervision_Timeout in milliseconds shall be larger than
(1 + Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is
given in milliseconds. (See [Vol 6] Part B, Section 4.5.2).
The Minimum_CE_Length and Maximum_CE_Length parameters are informative
parameters providing the Controller with the expected minimum and maximum
length of the connection events. The Minimum_CE_Length parameter
shall be less than or equal to the Maximum_CE_Length parameter.
The Host shall not issue this command when another LE_Create_Connection
is pending in the Controller; if this does occur the Controller shall return the
Command Disallowed error code shall be used.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.12)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started
its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window
shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Initiator_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>0x00 White list is not used to determine which advertiser to connect to.
Peer_Address_Type and Peer_Address shall be used.
0x01 White list is used to determine which advertiser to connect to.
Peer_Address_Type and Peer_Address shall be ignored.</p>
</td><td><li>0x00: White list not used</li><li>0x01: White list used</li></td></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>0x00 Public Device Address
0x01 Random Device Address
0x02 Public Identity Address (Corresponds to Resolved Private Address)
0x03 Random (Static) Identity Address (Corresponds to Resolved Private Address)</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Public Identity Address</li><li>0x03: Random (Static) Identity Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address of the device
to be connected.</p>
</td><td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Own address type.</dt>
<dd><ul class="first last simple">
<li>0x00: Public Device Address</li>
<li>0x01 Random Device Address</li>
<li><dl class="first docutils">
<dt>0x02: Controller generates Resolvable Private Address based on the local</dt>
<dd>IRK from resolving list. If resolving list contains no matching entry,
use public address.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>0x03: Controller generates Resolvable Private Address based on the local</dt>
<dd>IRK from resolving list. If resolving list contains no matching entry,
use random address from LE_Set_Random_Address.</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Resolvable Private Address or Public Address</li><li>0x03: Resolvable Private Address or Random Address</li></td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval. This shall be less
than or equal to Conn_Interval_Max.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval. This shall be
greater than or equal to Conn_Interval_Min.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Slave latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2.
Time = N * 10 msec.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
<tr><td><p>Minimum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the minimum length of connection
needed for this LE connection.
Time = N * 0.625 msec.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Maximum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the maximum length of connection needed
for this LE connection.
Time = N * 0.625 msec.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_CREATE_CONNECTION_CANCEL_anchor">HCI_LE_CREATE_CONNECTION_CANCEL</a></h2><h3>Description</h3><p>The LE_Create_Connection_Cancel command is used to cancel the LE_Create_Connection
command. This command shall only be issued after the
LE_Create_Connection command has been issued, a Command Status event
has been received for the LE Create Connection command and before the LE
Connection Complete event.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.13)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_WHITE_LIST_SIZE_anchor">HCI_LE_READ_WHITE_LIST_SIZE</a></h2><h3>Description</h3><p>The LE_Read_White_List_Size command is used to read the total number of
white list entries that can be stored in the Controller.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.14)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>White_List_Size</p>
</td><td><p>1</p>
</td><td><p>Total number of white list entries that can be stored in the Controller.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_CLEAR_WHITE_LIST_anchor">HCI_LE_CLEAR_WHITE_LIST</a></h2><h3>Description</h3><p>The LE_Clear_White_List command is used to clear the white list stored in the
Controller.
This command can be used at any time except when:
- the advertising filter policy uses the white list and advertising is enabled.
- the scanning filter policy uses the white list and scanning is enabled.
- the initiator filter policy uses the white list and an LE_Create_Connection
command is outstanding.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.15)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_ADD_DEVICE_TO_WHITE_LIST_anchor">HCI_LE_ADD_DEVICE_TO_WHITE_LIST</a></h2><h3>Description</h3><p>The LE_Add_Device_To_White_List command is used to add a single device
to the white list stored in the Controller.
This command can be used at any time except when:
- the advertising filter policy uses the white list and advertising is enabled.
- the scanning filter policy uses the white list and scanning is enabled.
- the initiator filter policy uses the white list and a create connection command
is outstanding.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.16)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Address_Type</p>
</td><td><p>1</p>
</td><td><p>Address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address of the device
to be added to the white list.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_REMOVE_DEVICE_FROM_WHITE_LIST_anchor">HCI_LE_REMOVE_DEVICE_FROM_WHITE_LIST</a></h2><h3>Description</h3><p>The LE_Remove_Device_From_White_List command is used to remove a single
device from the white list stored in the Controller.
This command can be used at any time except when:
- the advertising filter policy uses the white list and advertising is enabled.
- the scanning filter policy uses the white list and scanning is enabled.
- the initiator filter policy uses the white list and a create connection command
is outstanding.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.17)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Address_Type</p>
</td><td><p>1</p>
</td><td><p>Address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Address</p>
</td><td><p>6</p>
</td><td><dl class="docutils">
<dt>Public Device Address or Random Device Address of the device</dt>
<dd>to be removed from the white list.</dd>
</dl>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_CONNECTION_UPDATE_anchor">HCI_LE_CONNECTION_UPDATE</a></h2><h3>Description</h3><p>The LE_Connection_Update command is used to change the Link Layer connection
parameters of a connection. This command is supported only on master side.
The Conn_Interval_Min and Conn_Interval_Max parameters are used to define
the minimum and maximum allowed connection interval. The Conn_Interval_Min
parameter shall not be greater than the Conn_Interval_Max parameter.
The Conn_Latency parameter shall define the maximum allowed connection
latency.
The Supervision_Timeout parameter shall define the link supervision timeout
for the LE link. The Supervision_Timeout in milliseconds shall be larger than (1
+ Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is given
in milliseconds.
The Minimum_CE_Length and Maximum_CE_Length are information parameters
providing the Controller with a hint about the expected minimum and maximum
length of the connection events. The Minimum_CE_Length shall be less
than or equal to the Maximum_CE_Length.
The actual parameter values selected by the Link Layer may be different from
the parameter values provided by the Host through this command.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.18)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval. This shall be less
than or equal to Conn_Interval_Max.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval. This shall be
greater than or equal to Conn_Interval_Min.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Slave latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2.
Time = N * 10 msec.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
<tr><td><p>Minimum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the minimum length of connection
needed for this LE connection.
Time = N * 0.625 msec.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Maximum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the maximum length of connection needed
for this LE connection.
Time = N * 0.625 msec.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_HOST_CHANNEL_CLASSIFICATION_anchor">HCI_LE_SET_HOST_CHANNEL_CLASSIFICATION</a></h2><h3>Description</h3><p>The LE_Set_Host_Channel_Classification command allows the Host to specify
a channel classification for data channels based on its "local information". This
classification persists until overwritten with a subsequent LE_Set_Host_Channel_Classification
command or until the Controller is reset using the Reset
command (see [Vol 6] Part B, Section 4.5.8.1).
If this command is used, the Host should send it within 10 seconds of knowing
that the channel classification has changed. The interval between two successive
commands sent shall be at least one second.
This command shall only be used when the local device supports the Master
role.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.19)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Channel_Map</p>
</td><td><p>5</p>
</td><td><p>This parameter contains 37 1-bit fields.
The nth such field (in the range 0 to 36) contains the value for the
link layer channel index n.
Channel n is bad = 0.
Channel n is unknown = 1.
The most significant bits are reserved and shall be set to 0.
At least one channel shall be marked as unknown.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_CHANNEL_MAP_anchor">HCI_LE_READ_CHANNEL_MAP</a></h2><h3>Description</h3><p>The LE_Read_Channel_Map command returns the current Channel_Map for
the specified Connection_Handle. The returned value indicates the state of the
Channel_Map specified by the last transmitted or received Channel_Map (in a
CONNECT_REQ or LL_CHANNEL_MAP_REQ message) for the specified
Connection_Handle, regardless of whether the Master has received an
acknowledgement.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.20)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>LE_Channel_Map</p>
</td><td><p>5</p>
</td><td><p>This parameter contains 37 1-bit fields.
The nth such field (in the range 0 to 36) contains the value for the
link layer channel index n.
Channel n is unused = 0.
Channel n is used = 1.
The most significant bits are reserved and shall be set to 0.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_REMOTE_USED_FEATURES_anchor">HCI_LE_READ_REMOTE_USED_FEATURES</a></h2><h3>Description</h3><p>This command requests a list of the used LE features from the remote device.
This command shall return a list of the used LE features. For details see [Vol 6]
Part B, Section 4.6.
This command may be issued on both the master and slave.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.21)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_READ_REMOTE_USED_FEATURES_COMPLETE_EVENT_anchor">HCI_LE_READ_REMOTE_USED_FEATURES_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_ENCRYPT_anchor">HCI_LE_ENCRYPT</a></h2><h3>Description</h3><p>The LE_Encrypt command is used to request the Controller to encrypt the
Plaintext_Data in the command using the Key given in the command and
returns the Encrypted_Data to the Host. The AES-128 bit block cypher is
defined in NIST Publication FIPS-197 (http://csrc.nist.gov/publications/fips/
fips197/fips-197.pdf).
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.22)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Key</p>
</td><td><p>16</p>
</td><td><p>128 bit key for the encryption of the data given in the command.</p>
</td><td></tr>
<tr><td><p>Plaintext_Data</p>
</td><td><p>16</p>
</td><td><p>128 bit data block that is requested to be encrypted.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Encrypted_Data</p>
</td><td><p>16</p>
</td><td><p>128 bit encrypted data block.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_RAND_anchor">HCI_LE_RAND</a></h2><h3>Description</h3><p>The LE_Rand command is used to request the Controller to generate 8 octets
of random data to be sent to the Host. The Random_Number shall be generated
according to [Vol 2] Part H, Section 2 if the LE Feature (LL Encryption) is
supported.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.23)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Random_Number</p>
</td><td><p>8</p>
</td><td><p>Random Number</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_START_ENCRYPTION_anchor">HCI_LE_START_ENCRYPTION</a></h2><h3>Description</h3><p>The LE_Start_Encryption command is used to authenticate the given encryption
key associated with the remote device specified by the connection handle,
and once authenticated will encrypt the connection. The parameters are as
defined in [Vol 3] Part H, Section 2.4.4.
If the connection is already encrypted then the Controller shall pause connection
encryption before attempting to authenticate the given encryption key, and
then re-encrypt the connection. While encryption is paused no user data shall
be transmitted.
On an authentication failure, the connection shall be automatically disconnected
by the Link Layer. If this command succeeds, then the connection shall
be encrypted.
This command shall only be used when the local device's role is Master.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.24)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Random_Number</p>
</td><td><p>8</p>
</td><td><p>64 bit random number.</p>
</td><td></tr>
<tr><td><p>Encrypted_Diversifier</p>
</td><td><p>2</p>
</td><td><p>16 bit encrypted diversifier.</p>
</td><td></tr>
<tr><td><p>Long_Term_Key</p>
</td><td><p>16</p>
</td><td><p>128 bit long term key.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_ENCRYPTION_CHANGE_EVENT_anchor">HCI_ENCRYPTION_CHANGE_EVENT</a></li><li><a href="#HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT_anchor">HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_LONG_TERM_KEY_REQUEST_REPLY_anchor">HCI_LE_LONG_TERM_KEY_REQUEST_REPLY</a></h2><h3>Description</h3><p>The LE_Long_Term_Key_Request_Reply command is used to reply to an LE
Long Term Key Request event from the Controller, and specifies the
Long_Term_Key parameter that shall be used for this Connection_Handle. The
Long_Term_Key is used as defined in [Vol 6] Part B, Section 5.1.3.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.25)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Long_Term_Key</p>
</td><td><p>16</p>
</td><td><p>128 bit long term key.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_LONG_TERM_KEY_REQUESTED_NEGATIVE_REPLY_anchor">HCI_LE_LONG_TERM_KEY_REQUESTED_NEGATIVE_REPLY</a></h2><h3>Description</h3><p>The LE_Long_Term_Key_Request_Negative_Reply command is used to reply
to an LE Long Term Key Request event from the Controller if the Host cannot
provide a Long Term Key for this Connection_Handle.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.26)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_SUPPORTED_STATES_anchor">HCI_LE_READ_SUPPORTED_STATES</a></h2><h3>Description</h3><p>The LE_Read_Supported_States command reads the states and state combinations
that the link layer supports. See [Vol 6] Part B, Section 1.1.1.
LE_States is an 8-octet bit field. If a bit is set to 1 then this state or state combination
is supported by the Controller. Multiple bits in LE_States may be set to 1
to indicate support for multiple state and state combinations.
All the Advertising type with the Initiate State combinations shall be set only if
the corresponding Advertising types and Master Role combination are set.
All the Scanning types and the Initiate State combinations shall be set only if
the corresponding Scanning types and Master Role combination are set.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.27)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>LE_States</p>
</td><td><p>8</p>
</td><td><p>State or state combination is supported by the Controller.
See Core v5.0, Vol.2, part E, Ch. 7.8.27.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_DATA_LENGTH_anchor">HCI_LE_SET_DATA_LENGTH</a></h2><h3>Description</h3><p>The LE_Set_Data_Length command allows the Host to suggest maximum
transmission packet size and maximum packet transmission time
(connMaxTxOctets and connMaxTxTime - see Bluetooth Specification v5.0 [Vol 6] Part B, Section 4.5.10) to
be used for a given connection. The Controller may use smaller or larger
values based on local information. </p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>TxOctets</p>
</td><td><p>2</p>
</td><td><p>Preferred maximum number of payload octets that the local Controller
should include in a single Link Layer packet on this connection.</p>
</td><td><li>0x001B ... 0x00FB</li></td></tr>
<tr><td><p>TxTime</p>
</td><td><p>2</p>
</td><td><p>Preferred maximum number of microseconds that the local Controller
should use to transmit a single Link Layer packet on this connection.</p>
</td><td><li>0x0148 ... 0x4290</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH_anchor">HCI_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH</a></h2><h3>Description</h3><p>The LE_Read_Suggested_Default_Data_Length command allows the Host to
read the Host's suggested values (SuggestedMaxTxOctets and
SuggestedMaxTxTime) for the Controller's maximum transmitted number of
payload octets and maximum packet transmission time to be used for new
connections (see Bluetooth Specification v5.0 [Vol 6] Part B, Section 4.5.10). </p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>SuggestedMaxTxOctets</p>
</td><td><p>2</p>
</td><td><p>The Host's suggested value for the Controller's maximum transmitted
number of payload octets to be used for new connections.</p>
</td><td><li>0x001B ... 0x00FB</li></td></tr>
<tr><td><p>SuggestedMaxTxTime</p>
</td><td><p>2</p>
</td><td><p>The Host's suggested value for the Controller's maximum packet
transmission time to be used for new connections.</p>
</td><td><li>0x0148 ... 0x4290</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH_anchor">HCI_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH</a></h2><h3>Description</h3><p>The LE_Write_Suggested_Default_Data_Length command allows the Host to
specify its suggested values for the Controller's maximum transmission
number of payload octets and maximum packet transmission time to be used
for new connections. The Controller may use smaller or larger values for
connInitialMaxTxOctets and connInitialMaxTxTime based on local
information.(see Bluetooth Specification [Vol 6] Part B, Section 4.5.10). </p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>SuggestedMaxTxOctets</p>
</td><td><p>2</p>
</td><td><p>The Host's suggested value for the Controller's maximum transmitted
number of payload octets to be used for new connections.</p>
</td><td><li>0x001B ... 0x00FB</li></td></tr>
<tr><td><p>SuggestedMaxTxTime</p>
</td><td><p>2</p>
</td><td><p>The Host's suggested value for the Controller's maximum packet
transmission time to be used for new connections.</p>
</td><td><li>0x0148 ... 0x4290</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_anchor">HCI_LE_READ_LOCAL_P256_PUBLIC_KEY</a></h2><h3>Description</h3><p>The LE_Read_Local_P-256_Public_Key command is used to return the local
P-256 public key from the Controller. The Controller shall generate a new P-
256 public/private key pair upon receipt of this command.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.36)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT_anchor">HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_GENERATE_DHKEY_anchor">HCI_LE_GENERATE_DHKEY</a></h2><h3>Description</h3><p>The LE_Generate_DHKey command is used to initiate generation of a Diffie-
Hellman key in the Controller for use over the LE transport. This command
takes the remote P-256 public key as input. The Diffie-Hellman key generation
uses the private key generated by LE_Read_Local_P256_Public_Key command.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.37)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Remote_P256_Public_Key</p>
</td><td><p>64</p>
</td><td><p>The remote P-256 public key:
X, Y format
Octets 31-0: X co-ordinate
Octets 63-32: Y co-ordinate
Little Endian Format</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT_anchor">HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_ADD_DEVICE_TO_RESOLVING_LIST_anchor">HCI_LE_ADD_DEVICE_TO_RESOLVING_LIST</a></h2><h3>Description</h3><p>The LE_Add_Device_To_Resolving_List command is used to add one device
to the list of address translations used to resolve Resolvable Private Addresses
in the Controller.
This command cannot be used when address translation is enabled in the
Controller and:
- Advertising is enabled
- Scanning is enabled
- Create connection command is outstanding
This command can be used at any time when address translation is disabled in
the Controller.
When a Controller cannot add a device to the resolving list because the list is
full, it shall respond with error code 0x07 (Memory Capacity Exceeded).
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.38)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Peer_Identity_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type.</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Identity_Address</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) Identity address of the peer device</p>
</td><td></tr>
<tr><td><p>Peer_IRK</p>
</td><td><p>16</p>
</td><td><p>IRK of the peer device</p>
</td><td></tr>
<tr><td><p>Local_IRK</p>
</td><td><p>16</p>
</td><td><p>IRK of the local device</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST_anchor">HCI_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST</a></h2><h3>Description</h3><p>The LE_Remove_Device_From_Resolving_List command is used to remove
one device from the list of address translations used to resolve Resolvable
Private Addresses in the controller.
This command cannot be used when address translation is enabled in the
Controller and:
- Advertising is enabled
- Scanning is enabled
- Create connection command is outstanding
This command can be used at any time when address translation is disabled in
the Controller.
When a Controller cannot remove a device from the resolving list because it is
not found, it shall respond with error code 0x02 (Unknown Connection
Identifier).
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.39)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Peer_Identity_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type.</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Identity_Address</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) Identity address of the peer device</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_CLEAR_RESOLVING_LIST_anchor">HCI_LE_CLEAR_RESOLVING_LIST</a></h2><h3>Description</h3><p>The LE_Clear_Resolving_List command is used to remove all devices from the
list of address translations used to resolve Resolvable Private Addresses in the
Controller.
This command cannot be used when address translation is enabled in the
Controller and:
- Advertising is enabled
- Scanning is enabled
- Create connection command is outstanding
This command can be used at any time when address translation is disabled in
the Controller.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.40)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_RESOLVING_LIST_SIZE_anchor">HCI_LE_READ_RESOLVING_LIST_SIZE</a></h2><h3>Description</h3><p>The LE_Read_Resolving_List_Size command is used to read the total number
of address translation entries in the resolving list that can be stored in the
Controller.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.41)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Resolving_List_Size</p>
</td><td><p>1</p>
</td><td><p>Number of address translation entries in the resolving list</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_PEER_RESOLVABLE_ADDRESS_anchor">HCI_LE_READ_PEER_RESOLVABLE_ADDRESS</a></h2><h3>Description</h3><p>The LE_Read_Peer_Resolvable_Address command is used to get the current
peer Resolvable Private Address being used for the corresponding peer Public
and Random (static) Identity Address. The peer's resolvable address being
used may change after the command is called.
This command can be used at any time.
When a Controller cannot find a Resolvable Private Address associated with
the Peer Identity Address, it shall respond with error code 0x02 (Unknown
Connection Identifier).
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.42)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Peer_Identity_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type.</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Identity_Address</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) Identity address of the peer device</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Peer_Resolvable_Address</p>
</td><td><p>6</p>
</td><td><p>Resolvable Private Address being used by the peer device</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_LOCAL_RESOLVABLE_ADDRESS_anchor">HCI_LE_READ_LOCAL_RESOLVABLE_ADDRESS</a></h2><h3>Description</h3><p>The LE_Read_Local_Resolvable_Address command is used to get the current
local Resolvable Private Address being used for the corresponding peer
Identity Address. The local's resolvable address being used may change after
the command is called.
This command can be used at any time.
When a Controller cannot find a Resolvable Private Address associated with
the Peer Identity Address, it shall respond with error code 0x02 (Unknown
Connection Identifier).
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.43)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Peer_Identity_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type.</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Identity_Address</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) Identity address of the peer device</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Local_Resolvable_Address</p>
</td><td><p>6</p>
</td><td><p>Resolvable Private Address being used by the local device</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_ADDRESS_RESOLUTION_ENABLE_anchor">HCI_LE_SET_ADDRESS_RESOLUTION_ENABLE</a></h2><h3>Description</h3><p>The LE_Set_Address_Resolution_Enable command is used to enable
resolution of Resolvable Private Addresses in the Controller. This causes the
Controller to use the resolving list whenever the Controller receives a local or
peer Resolvable Private Address.
This command can be used at any time except when:
- Advertising is enabled
- Scanning is enabled
- Create connection command is outstanding
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.44)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Address_Resolution_Enable</p>
</td><td><p>1</p>
</td><td><p>Enable/disable address resolution in the controller.
0x00: Address Resolution in controller disabled (default),
0x01: Address Resolution in controller enabled</p>
</td><td><li>0x00: Address Resolution in controller disabled (default)</li><li>0x01: Address Resolution in controller enabled</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT_anchor">HCI_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT</a></h2><h3>Description</h3><p>The LE_Set_Resolvable_Private_Address_Timeout command set the length of
time the controller uses a Resolvable Private Address before a new resolvable
private address is generated and starts being used.
This timeout applies to all addresses generated by the controller.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.45)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>RPA_Timeout</p>
</td><td><p>2</p>
</td><td><p>RPA_Timeout measured in seconds.
Range for N: 0x0001 - 0xA1B8 (1 sec - approximately 11.5 hours)
Default: N= 0x0384 (900 secs or 15 minutes)</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_MAXIMUM_DATA_LENGTH_anchor">HCI_LE_READ_MAXIMUM_DATA_LENGTH</a></h2><h3>Description</h3><p>The LE_Read_Maximum_Data_Length command allows the Host to read the
Controllers maximum supported payload octets and packet duration times for
transmission and reception (supportedMaxTxOctets and
supportedMaxTxTime, supportedMaxRxOctets, and supportedMaxRxTime,
see Bluetooth Specification v5.0 [Vol 6] Part B, Section 4.5.10). </p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>supportedMaxTxOctets</p>
</td><td><p>2</p>
</td><td><p>Maximum number of payload octets that the local Controller supports
for transmission of a single Link Layer packet on a data connection.</p>
</td><td><li>0x001B ... 0x00FB</li></td></tr>
<tr><td><p>supportedMaxTxTime</p>
</td><td><p>2</p>
</td><td><p>Maximum time, in microseconds, that the local Controller supports for
transmission of a single Link Layer packet on a data connection.</p>
</td><td><li>0x0148 ... 0x4290</li></td></tr>
<tr><td><p>supportedMaxRxOctets</p>
</td><td><p>2</p>
</td><td><p>Maximum number of payload octets that the local Controller supports
for reception of a single Link Layer packet on a data connection.</p>
</td><td><li>0x001B ... 0x00FB</li></td></tr>
<tr><td><p>supportedMaxRxTime</p>
</td><td><p>2</p>
</td><td><p>Maximum time, in microseconds, that the local Controller supports for
reception of a single Link Layer packet on a data connection.</p>
</td><td><li>0x0148 ... 0x4290</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_READ_PHY_anchor">HCI_LE_READ_PHY</a></h2><h3>Description</h3><p>The LE_Read_PHY command is used to read the current transmitter PHY and
receiver PHY on the connection identified by the Connection_Handle. see Bluetooth Specification [vol2] part E Section 7.8.47</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>TX_PHY</p>
</td><td><p>1</p>
</td><td><p>Transmitter PHY in use</p>
</td><td><li>0x01: The transmitter PHY for the connection is LE 1M</li><li>0x02: The transmitter PHY for the connection is LE 2M</li><li>0x03: The transmitter PHY for the connection is LE Coded (Not Supported by STM32WB)</li></td></tr>
<tr><td><p>RX_PHY</p>
</td><td><p>1</p>
</td><td><p>Receiver PHY in use</p>
</td><td><li>0x01: The receiver PHY for the connection is LE 1M</li><li>0x02: The receiver PHY for the connection is LE 2M</li><li>0x03: The receiver PHY for the connection is LE Coded (Not Supported by STM32WB)</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_DEFAULT_PHY_anchor">HCI_LE_SET_DEFAULT_PHY</a></h2><h3>Description</h3><p>The LE_Set_Default_PHY command allows the Host to specify its preferred
values for the transmitter PHY and receiver PHY to be used for all subsequent
connections over the LE transport.
The ALL_PHYS parameter is a bit field that allows the Host to specify, for each
direction, whether it has no preference among the PHYs that the Controller
supports in a given direction or whether it has specified particular PHYs that it
prefers in the TX_PHYS or RX_PHYS parameter.
The TX_PHYS parameter is a bit field that indicates the transmitter PHYs that
the Host prefers the Controller to use. If the ALL_PHYS parameter specifies
that the Host has no preference, the TX_PHYS parameter is ignored;
otherwise at least one bit shall be set to 1.
The RX_PHYS parameter is a bit field that indicates the receiver PHYs that the
Host prefers the Controller to use. If the ALL_PHYS parameter specifies that
the Host has no preference, the RX_PHYS parameter is ignored; otherwise at
least one bit shall be set to 1. See Bluetooth Specification [Vol2] Part E Section 7.8.48</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>ALL_PHYS</p>
</td><td><p>1</p>
</td><td><p>Host preferences for TX PHY and RX PHY</p>
</td><td><li>0x00 ... 0x03</li></td></tr>
<tr><td><p>TX_PHYS</p>
</td><td><p>1</p>
</td><td><p>Host preferences for TX PHY (no LE coded support)</p>
</td><td><li>0x00 ... 0x03</li></td></tr>
<tr><td><p>RX_PHYS</p>
</td><td><p>1</p>
</td><td><p>Host preferences for RX PHY (no LE coded support)</p>
</td><td><li>0x00 ... 0x03</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_SET_PHY_anchor">HCI_LE_SET_PHY</a></h2><h3>Description</h3><p>The LE_Set_PHY command is used to set the PHY preferences for the
connection identified by the Connection_Handle. The Controller might not be
able to make the change (e.g. because the peer does not support the
requested PHY) or may decide that the current PHY is preferable.
The ALL_PHYS parameter is a bit field that allows the Host to specify, for each
direction, whether it has no preference among the PHYs that the Controller
supports in a given direction or whether it has specified particular PHYs that it
prefers in the TX_PHYS or RX_PHYS parameter.
The TX_PHYS parameter is a bit field that indicates the transmitter PHYs that
the Host prefers the Controller to use. If the ALL_PHYS parameter specifies
that the Host has no preference, the TX_PHYS parameter is ignored;
otherwise at least one bit shall be set to 1.
The RX_PHYS parameter is a bit field that indicates the receiver PHYs that the
Host prefers the Controller to use. If the ALL_PHYS parameter specifies that
the Host has no preference, the RX_PHYS parameter is ignored; otherwise at
least one bit shall be set to 1.
If, for at least one direction, the Host has specified a preference and the current
PHY is not one of those preferred, the Controller shall request a change.
Otherwise the Controller may, but need not, request a change.
The PHY preferences provided by the LE Set PHY command override those
provided via the LE Set Default PHY command (Section 7.8.48) or any
preferences previously set using the LE Set PHY command on the same
connection.
The PHY_options parameter is a bit field that allows the Host to specify options
for PHYs. The default value for a new connection shall be all zero bits. The
Controller may override any preferred coding for transmitting on the LE Coded
PHY.
The Host may specify a preferred coding even if it prefers not to use the LE
Coded transmitter PHY since the Controller may override the PHY preference.
see Bluetooth Specification v5.0 [Vol 6] Part B, Section 7.8.49 </p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>ALL_PHYS</p>
</td><td><p>1</p>
</td><td><p>Host preferences for TX PHY and RX PHY</p>
</td><td><li>0x00 ... 0x03</li></td></tr>
<tr><td><p>TX_PHYS</p>
</td><td><p>1</p>
</td><td><p>Host preferences for TX PHY (no LE coded support)</p>
</td><td><li>0x00 ... 0x03</li></td></tr>
<tr><td><p>RX_PHYS</p>
</td><td><p>1</p>
</td><td><p>Host preferences for RX PHY (no LE coded support)</p>
</td><td><li>0x00 ... 0x03</li></td></tr>
<tr><td><p>PHY_options</p>
</td><td><p>2</p>
</td><td><p>Not Supported by STM32WB</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_PHY_UPDATE_COMPLETE_EVENT_anchor">HCI_LE_PHY_UPDATE_COMPLETE_EVENT</a></li><h2><a name="HCI TESTING commands_anchor">HCI TESTING commands</a></h2><h3>HCI TESTING commands</h3><table width="800" border="1" class="reference">
<tr><th>Command</th><th>OpCode</th></tr>
<tr><td><a href="#HCI_LE_RECEIVER_TEST_anchor">HCI_LE_RECEIVER_TEST</a></td><td><p>0x201D</p>
</td></tr>
<tr><td><a href="#HCI_LE_TRANSMITTER_TEST_anchor">HCI_LE_TRANSMITTER_TEST</a></td><td><p>0x201E</p>
</td></tr>
<tr><td><a href="#HCI_LE_TEST_END_anchor">HCI_LE_TEST_END</a></td><td><p>0x201F</p>
</td></tr>
<tr><td><a href="#HCI_LE_ENHANCED_RECEIVER_TEST_anchor">HCI_LE_ENHANCED_RECEIVER_TEST</a></td><td><p>0x2033</p>
</td></tr>
<tr><td><a href="#HCI_LE_ENHANCED_TRANSMITTER_TEST_anchor">HCI_LE_ENHANCED_TRANSMITTER_TEST</a></td><td><p>0x2034</p>
</td></tr>
</table><h2><a name="HCI_LE_RECEIVER_TEST_anchor">HCI_LE_RECEIVER_TEST</a></h2><h3>Description</h3><p>This command is used to start a test where the DUT receives test reference
packets at a fixed interval. The tester generates the test reference packets.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.28)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>RX_Frequency</p>
</td><td><p>1</p>
</td><td><p>N = (F - 2402) / 2
Frequency Range : 2402 MHz to 2480 MHz</p>
</td><td><li>0x00 ... 0x27</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_TRANSMITTER_TEST_anchor">HCI_LE_TRANSMITTER_TEST</a></h2><h3>Description</h3><p>This command is used to start a test where the DUT generates test reference
packets at a fixed interval. The Controller shall transmit at maximum power.
An LE Controller supporting the LE_Transmitter_Test command shall support
Packet_Payload values 0x00, 0x01 and 0x02. An LE Controller may support
other values of Packet_Payload.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.29)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>TX_Frequency</p>
</td><td><p>1</p>
</td><td><p>N = (F - 2402) / 2
Frequency Range : 2402 MHz to 2480 MHz</p>
</td><td><li>0x00 ... 0x27</li></td></tr>
<tr><td><p>Length_Of_Test_Data</p>
</td><td><p>1</p>
</td><td><p>Length in bytes of payload data in each packet.</p>
</td><td><li>0x00 ... 0x25</li></td></tr>
<tr><td><p>Packet_Payload</p>
</td><td><p>1</p>
</td><td><p>Type of packet payload.</p>
</td><td><li>0x00: Pseudo-Random bit sequence 9</li><li>0x01: Pattern of alternating bits '11110000'</li><li>0x02: Pattern of alternating bits '10101010'</li><li>0x03: Pseudo-Random bit sequence 15</li><li>0x04: Pattern of All '1' bits</li><li>0x05: Pattern of All '0' bits</li><li>0x06: Pattern of alternating bits '00001111'</li><li>0x07: Pattern of alternating bits '0101'</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_TEST_END_anchor">HCI_LE_TEST_END</a></h2><h3>Description</h3><p>This command is used to stop any test which is in progress. The Number_Of_Packets
for a transmitter test shall be reported as 0x0000. The Number_Of_Packets
is an unsigned number and contains the number of received
packets.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.8.30)</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Number_Of_Packets</p>
</td><td><p>2</p>
</td><td><p>Number of packets received</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_ENHANCED_RECEIVER_TEST_anchor">HCI_LE_ENHANCED_RECEIVER_TEST</a></h2><h3>Description</h3><p>This command is used to start a test where the DUT receives test reference
packets at a fixed interval. The tester generates the test reference packets.
see Bluetooth Specification v5.0 [Vol 6] Part B, Section 7.8.50 </p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>RX_Frequency</p>
</td><td><p>1</p>
</td><td><p>N = (F - 2402) / 2
Frequency Range : 2402 MHz to 2480 MHz</p>
</td><td><li>0x00 ... 0x27</li></td></tr>
<tr><td><p>PHY</p>
</td><td><p>1</p>
</td><td><p>PHY to use for test packet</p>
</td><td><li>0x00: Reserved for future use</li><li>0x01: Transmitter set to use the LE 1M PHY</li><li>0x02: Transmitter set to use the LE 2M PHY</li><li>0x03: Transmitter set to use the LE Coded PHY with S=8 data coding</li><li>0x04: Transmitter set to use the LE Coded PHY with S=2 data coding</li></td></tr>
<tr><td><p>Modulation_Index</p>
</td><td><p>1</p>
</td><td><p>Modulation index capability of the transmitter</p>
</td><td><li>0x00: Assume transmitter will have a standard modulation index</li><li>0x01: Assume transmitter will have a stable modulation index</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="HCI_LE_ENHANCED_TRANSMITTER_TEST_anchor">HCI_LE_ENHANCED_TRANSMITTER_TEST</a></h2><h3>Description</h3><p>This command is used to start a test where the DUT generates test reference
packets at a fixed interval. The Controller shall transmit at maximum power.
An LE Controller supporting the LE_Enhanced Transmitter_Test command
shall support Packet_Payload values 0x00, 0x01 and 0x02. An LE Controller
supporting the LE Coded PHY shall also support Packet_Payload value 0x04 (not supported by STM32WB).
An LE Controller may support other values of Packet_Payload. see Bluetooth Specification v5.0 [Vol 6] Part B, Section 7.8.51</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>TX_Frequency</p>
</td><td><p>1</p>
</td><td><p>N = (F - 2402) / 2
Frequency Range : 2402 MHz to 2480 MHz</p>
</td><td><li>0x00 ... 0x27</li></td></tr>
<tr><td><p>Length_Of_Test_Data</p>
</td><td><p>1</p>
</td><td><p>Length in bytes of payload data in each packet.</p>
</td><td><li>0x00 ... 0x25</li></td></tr>
<tr><td><p>Packet_Payload</p>
</td><td><p>1</p>
</td><td><p>Type of packet payload.</p>
</td><td><li>0x00: Pseudo-Random bit sequence 9</li><li>0x01: Pattern of alternating bits '11110000'</li><li>0x02: Pattern of alternating bits '10101010'</li><li>0x03: Pseudo-Random bit sequence 15</li><li>0x04: Pattern of All '1' bits</li><li>0x05: Pattern of All '0' bits</li><li>0x06: Pattern of alternating bits '00001111'</li><li>0x07: Pattern of alternating bits '0101'</li></td></tr>
<tr><td><p>PHY</p>
</td><td><p>1</p>
</td><td><p>PHY to use for test packet</p>
</td><td><li>0x00: Reserved for future use</li><li>0x01: Transmitter set to use the LE 1M PHY</li><li>0x02: Transmitter set to use the LE 2M PHY</li><li>0x03: Transmitter set to use the LE Coded PHY with S=8 data coding</li><li>0x04: Transmitter set to use the LE Coded PHY with S=2 data coding</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI HAL commands_anchor">ACI HAL commands</a></h2><h3>ACI HAL commands</h3><table width="800" border="1" class="reference">
<tr><th>Command</th><th>OpCode</th></tr>
<tr><td><a href="#ACI_HAL_GET_FW_BUILD_NUMBER_anchor">ACI_HAL_GET_FW_BUILD_NUMBER</a></td><td><p>0xFC00</p>
</td></tr>
<tr><td><a href="#ACI_HAL_WRITE_CONFIG_DATA_anchor">ACI_HAL_WRITE_CONFIG_DATA</a></td><td><p>0xFC0C</p>
</td></tr>
<tr><td><a href="#ACI_HAL_READ_CONFIG_DATA_anchor">ACI_HAL_READ_CONFIG_DATA</a></td><td><p>0xFC0D</p>
</td></tr>
<tr><td><a href="#ACI_HAL_SET_TX_POWER_LEVEL_anchor">ACI_HAL_SET_TX_POWER_LEVEL</a></td><td><p>0xFC0F</p>
</td></tr>
<tr><td><a href="#ACI_HAL_LE_TX_TEST_PACKET_NUMBER_anchor">ACI_HAL_LE_TX_TEST_PACKET_NUMBER</a></td><td><p>0xFC14</p>
</td></tr>
<tr><td><a href="#ACI_HAL_TONE_START_anchor">ACI_HAL_TONE_START</a></td><td><p>0xFC15</p>
</td></tr>
<tr><td><a href="#ACI_HAL_TONE_STOP_anchor">ACI_HAL_TONE_STOP</a></td><td><p>0xFC16</p>
</td></tr>
<tr><td><a href="#ACI_HAL_GET_LINK_STATUS_anchor">ACI_HAL_GET_LINK_STATUS</a></td><td><p>0xFC17</p>
</td></tr>
<tr><td><a href="#ACI_HAL_SET_RADIO_ACTIVITY_MASK_anchor">ACI_HAL_SET_RADIO_ACTIVITY_MASK</a></td><td><p>0xFC18</p>
</td></tr>
<tr><td><a href="#ACI_HAL_GET_ANCHOR_PERIOD_anchor">ACI_HAL_GET_ANCHOR_PERIOD</a></td><td><p>0xFC19</p>
</td></tr>
<tr><td><a href="#ACI_HAL_SET_EVENT_MASK_anchor">ACI_HAL_SET_EVENT_MASK</a></td><td><p>0xFC1A</p>
</td></tr>
<tr><td><a href="#ACI_HAL_SET_SMP_ENG_CONFIG_anchor">ACI_HAL_SET_SMP_ENG_CONFIG</a></td><td><p>0xFC1B</p>
</td></tr>
<tr><td><a href="#ACI_HAL_GET_PM_DEBUG_INFO_anchor">ACI_HAL_GET_PM_DEBUG_INFO</a></td><td><p>0xFC1C</p>
</td></tr>
<tr><td><a href="#ACI_HAL_READ_RADIO_REG_anchor">ACI_HAL_READ_RADIO_REG</a></td><td><p>0xFC30</p>
</td></tr>
<tr><td><a href="#ACI_HAL_WRITE_RADIO_REG_anchor">ACI_HAL_WRITE_RADIO_REG</a></td><td><p>0xFC31</p>
</td></tr>
<tr><td><a href="#ACI_HAL_READ_RAW_RSSI_anchor">ACI_HAL_READ_RAW_RSSI</a></td><td><p>0xFC32</p>
</td></tr>
<tr><td><a href="#ACI_HAL_RX_START_anchor">ACI_HAL_RX_START</a></td><td><p>0xFC33</p>
</td></tr>
<tr><td><a href="#ACI_HAL_RX_STOP_anchor">ACI_HAL_RX_STOP</a></td><td><p>0xFC34</p>
</td></tr>
<tr><td><a href="#ACI_HAL_STACK_RESET_anchor">ACI_HAL_STACK_RESET</a></td><td><p>0xFC3B</p>
</td></tr>
</table><h2><a name="ACI_HAL_GET_FW_BUILD_NUMBER_anchor">ACI_HAL_GET_FW_BUILD_NUMBER</a></h2><h3>Description</h3><p>This command returns the build number associated with the firmware version currently running</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Build_Number</p>
</td><td><p>2</p>
</td><td><p>Build number of the firmware.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_WRITE_CONFIG_DATA_anchor">ACI_HAL_WRITE_CONFIG_DATA</a></h2><h3>Description</h3><p>This command writes a value to a low level configure data structure. It is useful to setup
directly some low level parameters for the system in the runtime.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Offset</p>
</td><td><p>1</p>
</td><td><p>Offset of the element in the configuration data structure
which has to be written. The valid offsets are:</p>
<ul class="simple">
<li>0x00: Bluetooth public address, Value length to be written: 6 bytes</li>
<li>0x06: DIV used to derive CSRK, Value length to be written: 2 bytes</li>
<li>0x08: Encryption root key used to derive LTK and CSRK, Value length to be written: 16 bytes</li>
<li>0x18: Identity root key used to derive LTK and CSRK, Value length to be written: 16 bytes</li>
<li>0x2C: Link layer without host (for certification purposes), Value length to be written: 1 byte</li>
<li>0x2E: Static Random Address: 6 bytes</li>
<li>0x2F: Disable watchdog (1=disable, 0=enable). Value length to be written: 1 byte</li>
</ul>
</td><td><li>0x00: CONFIG_DATA_PUBADDR_OFFSET</li><li>0x06: CONFIG_DATA_DIV_OFFSET</li><li>0x08: CONFIG_DATA_ER_OFFSET</li><li>0x18: CONFIG_DATA_IR_OFFSET</li><li>0x2C: LL_WITHOUT_HOST</li><li>0x2E: CONFIG_DATA_RANDOM_ADDRESS_WR</li><li>0x2F: CONFIG_DATA_WATCHDOG_DISABLE</li></td></tr>
<tr><td><p>Length</p>
</td><td><p>1</p>
</td><td><p>Length of data to be written</p>
</td><td></tr>
<tr><td><p>Value</p>
</td><td><p>Length</p>
</td><td><p>Data to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_READ_CONFIG_DATA_anchor">ACI_HAL_READ_CONFIG_DATA</a></h2><h3>Description</h3><p>This command requests the value in the low level configure data structure.
The number of read bytes changes for different Offset. </p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Offset</p>
</td><td><p>1</p>
</td><td><p>Offset of the element in the configuration data structure
which has to be read. The valid offsets are:</p>
<ul class="simple">
<li>0x00: Bluetooth public address, Value length returned: 6 bytes</li>
<li>0x06: DIV used to derive CSRK, Value length returned: 2 bytes</li>
<li>0x08: Encryption root key used to derive LTK and CSRK, Value length returned: 16 bytes</li>
<li>0x18: Identity root key used to derive LTK and CSRK, Value length returned: 16 bytes</li>
<li>0x2C: Link layer without host (for certification purposes), Value length returned: 1 byte</li>
<li>0x2F: Disable watchdog (1=disabled, 0=enable). Value length returned: 1 byte</li>
<li>0x80: Static random address. Value length returned: 6 bytes (read-only)</li>
</ul>
</td><td><li>0x00: CONFIG_DATA_PUBADDR_OFFSET</li><li>0x06: CONFIG_DATA_DIV_OFFSET</li><li>0x08: CONFIG_DATA_ER_OFFSET</li><li>0x18: CONFIG_DATA_IR_OFFSET</li><li>0x2C: LL_WITHOUT_HOST</li><li>0x2F: CONFIG_DATA_WATCHDOG_DISABLE</li><li>0x80: CONFIG_DATA_RANDOM_ADDRESS</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Data in octets</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Data_Length</p>
</td><td><p>Data field associated with Offset parameter</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_SET_TX_POWER_LEVEL_anchor">ACI_HAL_SET_TX_POWER_LEVEL</a></h2><h3>Description</h3><p>This command sets the TX power level of the device. By controlling the
PA_LEVEL, that determines the output power level (dBm) at the IC pin. 
When the system starts up or reboots, the default TX power level will be used, which is the
maximum value of 6 dBm. Once this command is given, the output power will be changed
instantly, regardless if there is Bluetooth communication going on or not. For example, for
debugging purpose, the device can be set to advertise all the time. And use this
command to observe the signal strength changing.
The system will keep the last received TX power level from the command, i.e. the 2nd
command overwrites the previous TX power level. The new TX power level remains until
another Set TX Power command, or the system reboots.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>En_High_Power</p>
</td><td><p>1</p>
</td><td><p>Enable High Power mode - Deprecated and ignored on STM32WB</p>
</td><td><li>0x00: Standard Power</li><li>0x01: High Power</li></td></tr>
<tr><td><p>PA_Level</p>
</td><td><p>1</p>
</td><td><p>Power amplifier output level. Output power is indicative and it depends on the PCB layout and associated
components.Here the values are given at the IC pin</p>
</td><td><li>0x00: -40 dBm</li><li>0x01: -20.85 dBm</li><li>0x02: -19.75 dBm</li><li>0x03: -18.85 dBm</li><li>0x04: -17.6 dBm</li><li>0x05: -16.5 dBm</li><li>0x06: -15.25 dBm</li><li>0x07: -14.1 dBm</li><li>0x08: -13.15 dBm</li><li>0x09: -12.05 dBm</li><li>0x0A: -10.9 dBm</li><li>0x0B: -9.9 dBm</li><li>0x0C: -8.85 dBm</li><li>0x0D: -7.8 dBm</li><li>0x0E: -6.9 dBm</li><li>0x0F: -5.9 dBm</li><li>0x10: -4.95 dBm</li><li>0x11: -4 dBm</li><li>0x12: -3.15 dBm</li><li>0x13: -2.45 dBm</li><li>0x14: -1.8 dBm</li><li>0x15: -1.3 dBm</li><li>0x16: -0.85 dBm</li><li>0x17: -0.5 dBm</li><li>0x18: -0.15 dBm</li><li>0x19: 0 dBm</li><li>0x1A: +1 dBm</li><li>0x1B: +2 dBm</li><li>0x1C: +3 dBm</li><li>0x1D: +4 dBm</li><li>0x1E: +5 dBm</li><li>0x1F: +6 dBm</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_LE_TX_TEST_PACKET_NUMBER_anchor">ACI_HAL_LE_TX_TEST_PACKET_NUMBER</a></h2><h3>Description</h3><p>This command returns the number of packets sent in Direct Test Mode.
When the Direct TX test is started, a 32-bit counter is used to count how many packets have been transmitted. 
This command can be used to check how many packets have been sent during the Direct TX test.
The counter starts from 0 and counts upwards. The counter can wrap and start from 0 again. 
The counter is not cleared until the next Direct TX test starts. </p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Number_Of_Packets</p>
</td><td><p>4</p>
</td><td><p>Number of packets sent during the last Direct TX test.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_TONE_START_anchor">ACI_HAL_TONE_START</a></h2><h3>Description</h3><p>This command starts a carrier frequency, i.e. a tone, on a specific channel. The frequency
sine wave at the specific channel may be used for debugging purpose only. The channel ID
is a parameter from 0x00 to 0x27 for the 40 BLE channels, e.g. 0x00 for 2.402 GHz, 0x01
for 2.404 GHz etc.
This command should not be used when normal Bluetooth activities are ongoing.
The tone should be stopped by <a href="#ACI_HAL_TONE_STOP_anchor">ACI_HAL_TONE_STOP</a> command.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>RF_Channel</p>
</td><td><p>1</p>
</td><td><p>BLE Channel ID, from 0x00 to 0x27 meaning (2.402 + 2*0xXX) GHz
Device will continuously emit 0s, that means that the tone
will be at the channel center frequency less the maximum
frequency deviation (250kHz).</p>
</td><td><li>0x00 ... 0x27</li></td></tr>
<tr><td><p>Freq_offset</p>
</td><td><p>1</p>
</td><td><p>Frequency Offset for tone channel</p>
</td><td><li>0x00 ... 0xFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_TONE_STOP_anchor">ACI_HAL_TONE_STOP</a></h2><h3>Description</h3><p>This command is used to stop the previously started <a href="#ACI_HAL_TONE_START_anchor">ACI_HAL_TONE_START</a> command.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_GET_LINK_STATUS_anchor">ACI_HAL_GET_LINK_STATUS</a></h2><h3>Description</h3><p>This command returns the status of the 8 Bluetooth low energy links managed by the device</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Link_Status</p>
</td><td><p>8</p>
</td><td><p>Array of link status (8 links). Each link status is 1 byte.</p>
</td><td></tr>
<tr><td><p>Link_Connection_Handle</p>
</td><td><p>16</p>
</td><td><p>Array of connection handles (2 bytes) for 8 links.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_SET_RADIO_ACTIVITY_MASK_anchor">ACI_HAL_SET_RADIO_ACTIVITY_MASK</a></h2><h3>Description</h3><p>This command set the bitmask associated to <a href="#ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT_anchor">ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT</a>. 
Only the radio activities enabled in the mask will be reported to application by <a href="#ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT_anchor">ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT</a></p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Radio_Activity_Mask</p>
</td><td><p>2</p>
</td><td><p>Bitmask of radio events</p>
</td><td><p>Bitmask of:</p><br><li>0x0001: Idle</li><li>0x0002: Advertising</li><li>0x0004: Connection event slave</li><li>0x0008: Scanning</li><li>0x0010: Connection request</li><li>0x0020: Connection event master</li><li>0x0040: TX test mode</li><li>0x0080: RX test mode</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT_anchor">ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT</a></li><h2><a name="ACI_HAL_GET_ANCHOR_PERIOD_anchor">ACI_HAL_GET_ANCHOR_PERIOD</a></h2><h3>Description</h3><p>This command returns information about the Anchor Period to help application in selecting 
                      slot timings when operating in multi-link scenarios.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Anchor_Period</p>
</td><td><p>4</p>
</td><td><p>Current anchor period.
T = N * 0.625 ms.</p>
</td><td></tr>
<tr><td><p>Max_Free_Slot</p>
</td><td><p>4</p>
</td><td><p>Maximum available time that can be allocated for a new slot.
T = N * 0.625 ms.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_SET_EVENT_MASK_anchor">ACI_HAL_SET_EVENT_MASK</a></h2><h3>Description</h3><p>This command is used to enable/disable the generation of HAL events </p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Event_Mask</p>
</td><td><p>4</p>
</td><td><p>Mask to enable/disable generation of HAL events</p>
</td><td><p>Bitmask of:</p><br><li>0x00000000: No events specified (Default)</li><li>0x00000001: ACI_HAL_SCAN_REQ_REPORT_EVENT</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_SET_SMP_ENG_CONFIG_anchor">ACI_HAL_SET_SMP_ENG_CONFIG</a></h2><h3>Description</h3><p>This command is used to provide a specific engineering setup to the Security Manager Protocol Layer. It may be used during development/debug only!</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>SMP_Config</p>
</td><td><p>4</p>
</td><td><p>Mask to configure SMP engineering knobs</p>
</td><td><p>Bitmask of:</p><br><li>0x00000000: Default config (all reset)</li><li>0x00000001: Cheat Level 1 ON</li><li>0x00000002: RFU</li><li>0x00000003: Cheat Level 3 ON</li><li>0x00000004: RFU</li><li>0x00000005: Cheat Level 5 ON</li><li>0x00000006: Cheat Level 6 ON</li><li>0x00000007: Cheat Level 7 ON</li><li>0x00000010: DBG messages ON</li><li>0x00000100: Debug Public Key ON</li><li>0x00000107: Debug KEY On + DBG msg Off + CL=7</li><li>0x00000117: Debug KEY On + DBG msg On + CL=7</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_GET_PM_DEBUG_INFO_anchor">ACI_HAL_GET_PM_DEBUG_INFO</a></h2><h3>Description</h3><p>This command is used to retrieve TX, RX and total buffer count allocated for ACL packets.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Allocated_For_TX</p>
</td><td><p>1</p>
</td><td><p>MBlocks allocated for TXing</p>
</td><td></tr>
<tr><td><p>Allocated_For_RX</p>
</td><td><p>1</p>
</td><td><p>MBlocks allocated for RXing</p>
</td><td></tr>
<tr><td><p>Allocated_MBlocks</p>
</td><td><p>1</p>
</td><td><p>Overall allocated MBlocks</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_READ_RADIO_REG_anchor">ACI_HAL_READ_RADIO_REG</a></h2><h3>Description</h3><p>This command Reads Register value from the RF module </p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Register_Address</p>
</td><td><p>1</p>
</td><td><p>Address of the register to be read</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>reg_val</p>
</td><td><p>1</p>
</td><td><p>Register value</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_WRITE_RADIO_REG_anchor">ACI_HAL_WRITE_RADIO_REG</a></h2><h3>Description</h3><p>This command writes Register value to the RF module </p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Register_Address</p>
</td><td><p>1</p>
</td><td><p>Address of the register to be written</p>
</td><td></tr>
<tr><td><p>Register_Value</p>
</td><td><p>1</p>
</td><td><p>Value to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_READ_RAW_RSSI_anchor">ACI_HAL_READ_RAW_RSSI</a></h2><h3>Description</h3><p>This command returns the raw value of the RSSI </p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Value</p>
</td><td><p>3</p>
</td><td><p>RAW RSSI value</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_RX_START_anchor">ACI_HAL_RX_START</a></h2><h3>Description</h3><p>This command does set up the RF to listen to a specific RF channel </p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>RF_Channel</p>
</td><td><p>1</p>
</td><td><p>BLE Channel ID, from 0x00 to 0x27 meaning (2.402 + 2*0xXX) GHz
Device will continuously emit 0s, that means that the tone
will be at the channel center frequency less the maximum
frequency deviation (250kHz).</p>
</td><td><li>0x00 ... 0x27</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_RX_STOP_anchor">ACI_HAL_RX_STOP</a></h2><h3>Description</h3><p>This command stop a previous ACI_HAL_RX_START command </p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_HAL_STACK_RESET_anchor">ACI_HAL_STACK_RESET</a></h2><h3>Description</h3><p>This command is equivalent to HCI_RESET but ensures the sleep mode is entered' immediately after its completion</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI GAP commands_anchor">ACI GAP commands</a></h2><h3>ACI GAP commands</h3><table width="800" border="1" class="reference">
<tr><th>Command</th><th>OpCode</th></tr>
<tr><td><a href="#ACI_GAP_SET_NON_DISCOVERABLE_anchor">ACI_GAP_SET_NON_DISCOVERABLE</a></td><td><p>0xFC81</p>
</td></tr>
<tr><td><a href="#ACI_GAP_SET_LIMITED_DISCOVERABLE_anchor">ACI_GAP_SET_LIMITED_DISCOVERABLE</a></td><td><p>0xFC82</p>
</td></tr>
<tr><td><a href="#ACI_GAP_SET_DISCOVERABLE_anchor">ACI_GAP_SET_DISCOVERABLE</a></td><td><p>0xFC83</p>
</td></tr>
<tr><td><a href="#ACI_GAP_SET_DIRECT_CONNECTABLE_anchor">ACI_GAP_SET_DIRECT_CONNECTABLE</a></td><td><p>0xFC84</p>
</td></tr>
<tr><td><a href="#ACI_GAP_SET_IO_CAPABILITY_anchor">ACI_GAP_SET_IO_CAPABILITY</a></td><td><p>0xFC85</p>
</td></tr>
<tr><td><a href="#ACI_GAP_SET_AUTHENTICATION_REQUIREMENT_anchor">ACI_GAP_SET_AUTHENTICATION_REQUIREMENT</a></td><td><p>0xFC86</p>
</td></tr>
<tr><td><a href="#ACI_GAP_SET_AUTHORIZATION_REQUIREMENT_anchor">ACI_GAP_SET_AUTHORIZATION_REQUIREMENT</a></td><td><p>0xFC87</p>
</td></tr>
<tr><td><a href="#ACI_GAP_PASS_KEY_RESP_anchor">ACI_GAP_PASS_KEY_RESP</a></td><td><p>0xFC88</p>
</td></tr>
<tr><td><a href="#ACI_GAP_AUTHORIZATION_RESP_anchor">ACI_GAP_AUTHORIZATION_RESP</a></td><td><p>0xFC89</p>
</td></tr>
<tr><td><a href="#ACI_GAP_INIT_anchor">ACI_GAP_INIT</a></td><td><p>0xFC8A</p>
</td></tr>
<tr><td><a href="#ACI_GAP_SET_NON_CONNECTABLE_anchor">ACI_GAP_SET_NON_CONNECTABLE</a></td><td><p>0xFC8B</p>
</td></tr>
<tr><td><a href="#ACI_GAP_SET_UNDIRECTED_CONNECTABLE_anchor">ACI_GAP_SET_UNDIRECTED_CONNECTABLE</a></td><td><p>0xFC8C</p>
</td></tr>
<tr><td><a href="#ACI_GAP_SLAVE_SECURITY_REQ_anchor">ACI_GAP_SLAVE_SECURITY_REQ</a></td><td><p>0xFC8D</p>
</td></tr>
<tr><td><a href="#ACI_GAP_UPDATE_ADV_DATA_anchor">ACI_GAP_UPDATE_ADV_DATA</a></td><td><p>0xFC8E</p>
</td></tr>
<tr><td><a href="#ACI_GAP_DELETE_AD_TYPE_anchor">ACI_GAP_DELETE_AD_TYPE</a></td><td><p>0xFC8F</p>
</td></tr>
<tr><td><a href="#ACI_GAP_GET_SECURITY_LEVEL_anchor">ACI_GAP_GET_SECURITY_LEVEL</a></td><td><p>0xFC90</p>
</td></tr>
<tr><td><a href="#ACI_GAP_SET_EVENT_MASK_anchor">ACI_GAP_SET_EVENT_MASK</a></td><td><p>0xFC91</p>
</td></tr>
<tr><td><a href="#ACI_GAP_CONFIGURE_WHITELIST_anchor">ACI_GAP_CONFIGURE_WHITELIST</a></td><td><p>0xFC92</p>
</td></tr>
<tr><td><a href="#ACI_GAP_TERMINATE_anchor">ACI_GAP_TERMINATE</a></td><td><p>0xFC93</p>
</td></tr>
<tr><td><a href="#ACI_GAP_CLEAR_SECURITY_DB_anchor">ACI_GAP_CLEAR_SECURITY_DB</a></td><td><p>0xFC94</p>
</td></tr>
<tr><td><a href="#ACI_GAP_ALLOW_REBOND_anchor">ACI_GAP_ALLOW_REBOND</a></td><td><p>0xFC95</p>
</td></tr>
<tr><td><a href="#ACI_GAP_START_LIMITED_DISCOVERY_PROC_anchor">ACI_GAP_START_LIMITED_DISCOVERY_PROC</a></td><td><p>0xFC96</p>
</td></tr>
<tr><td><a href="#ACI_GAP_START_GENERAL_DISCOVERY_PROC_anchor">ACI_GAP_START_GENERAL_DISCOVERY_PROC</a></td><td><p>0xFC97</p>
</td></tr>
<tr><td><a href="#ACI_GAP_START_NAME_DISCOVERY_PROC_anchor">ACI_GAP_START_NAME_DISCOVERY_PROC</a></td><td><p>0xFC98</p>
</td></tr>
<tr><td><a href="#ACI_GAP_START_AUTO_CONNECTION_ESTABLISH_PROC_anchor">ACI_GAP_START_AUTO_CONNECTION_ESTABLISH_PROC</a></td><td><p>0xFC99</p>
</td></tr>
<tr><td><a href="#ACI_GAP_START_GENERAL_CONNECTION_ESTABLISH_PROC_anchor">ACI_GAP_START_GENERAL_CONNECTION_ESTABLISH_PROC</a></td><td><p>0xFC9A</p>
</td></tr>
<tr><td><a href="#ACI_GAP_START_SELECTIVE_CONNECTION_ESTABLISH_PROC_anchor">ACI_GAP_START_SELECTIVE_CONNECTION_ESTABLISH_PROC</a></td><td><p>0xFC9B</p>
</td></tr>
<tr><td><a href="#ACI_GAP_CREATE_CONNECTION_anchor">ACI_GAP_CREATE_CONNECTION</a></td><td><p>0xFC9C</p>
</td></tr>
<tr><td><a href="#ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a></td><td><p>0xFC9D</p>
</td></tr>
<tr><td><a href="#ACI_GAP_START_CONNECTION_UPDATE_anchor">ACI_GAP_START_CONNECTION_UPDATE</a></td><td><p>0xFC9E</p>
</td></tr>
<tr><td><a href="#ACI_GAP_SEND_PAIRING_REQ_anchor">ACI_GAP_SEND_PAIRING_REQ</a></td><td><p>0xFC9F</p>
</td></tr>
<tr><td><a href="#ACI_GAP_RESOLVE_PRIVATE_ADDR_anchor">ACI_GAP_RESOLVE_PRIVATE_ADDR</a></td><td><p>0xFCA0</p>
</td></tr>
<tr><td><a href="#ACI_GAP_SET_BROADCAST_MODE_anchor">ACI_GAP_SET_BROADCAST_MODE</a></td><td><p>0xFCA1</p>
</td></tr>
<tr><td><a href="#ACI_GAP_START_OBSERVATION_PROC_anchor">ACI_GAP_START_OBSERVATION_PROC</a></td><td><p>0xFCA2</p>
</td></tr>
<tr><td><a href="#ACI_GAP_GET_BONDED_DEVICES_anchor">ACI_GAP_GET_BONDED_DEVICES</a></td><td><p>0xFCA3</p>
</td></tr>
<tr><td><a href="#ACI_GAP_IS_DEVICE_BONDED_anchor">ACI_GAP_IS_DEVICE_BONDED</a></td><td><p>0xFCA4</p>
</td></tr>
<tr><td><a href="#ACI_GAP_NUMERIC_COMPARISON_VALUE_CONFIRM_YESNO_anchor">ACI_GAP_NUMERIC_COMPARISON_VALUE_CONFIRM_YESNO</a></td><td><p>0xFCA5</p>
</td></tr>
<tr><td><a href="#ACI_GAP_PASSKEY_INPUT_anchor">ACI_GAP_PASSKEY_INPUT</a></td><td><p>0xFCA6</p>
</td></tr>
<tr><td><a href="#ACI_GAP_GET_OOB_DATA_anchor">ACI_GAP_GET_OOB_DATA</a></td><td><p>0xFCA7</p>
</td></tr>
<tr><td><a href="#ACI_GAP_SET_OOB_DATA_anchor">ACI_GAP_SET_OOB_DATA</a></td><td><p>0xFCA8</p>
</td></tr>
<tr><td><a href="#ACI_GAP_ADD_DEVICES_TO_RESOLVING_LIST_anchor">ACI_GAP_ADD_DEVICES_TO_RESOLVING_LIST</a></td><td><p>0xFCA9</p>
</td></tr>
<tr><td><a href="#ACI_GAP_REMOVE_BONDED_DEVICE_anchor">ACI_GAP_REMOVE_BONDED_DEVICE</a></td><td><p>0xFCAA</p>
</td></tr>
</table><h2><a name="ACI_GAP_SET_NON_DISCOVERABLE_anchor">ACI_GAP_SET_NON_DISCOVERABLE</a></h2><h3>Description</h3><p>Put the device in non-discoverable mode. This command disables the LL advertising.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_LIMITED_DISCOVERABLE_anchor">ACI_GAP_SET_LIMITED_DISCOVERABLE</a></h2><h3>Description</h3><p>Put the device in limited discoverable mode (as defined in Bluetooth Specification v.5.0,
Vol. 3, Part C, section 9.2.3). The device will be discoverable for maximum period of TGAP
(lim_adv_timeout) = 180 seconds (from errata). The advertising can be disabled at any time
by issuing <a href="#ACI_GAP_SET_NON_DISCOVERABLE_anchor">ACI_GAP_SET_NON_DISCOVERABLE</a> command.
The Adv_Interval_Min and Adv_Interval_Max parameters are optional. If both are set to 0,
the GAP will use default values for adv intervals for limited discoverable mode (250 ms
and 500 ms respectively).
To allow a fast connection, the host can set Local_Name, Service_Uuid_List,
Slave_Conn_Interval_Min and Slave_Conn_Interval_Max. If provided, these data will be 
inserted into the advertising packet payload as AD data. These parameters are optional
in this command. These values can be set in advertised data using GAP_Update_Adv_Data
command separately.
The total size of data in advertising packet cannot exceed 31 bytes.
With this command, the BLE Stack will also add automatically the following
standard AD types:
- AD Flags
- Power Level
When advertising timeout happens (i.e. limited discovery period has elapsed), controller generates
<a href="#ACI_GAP_LIMITED_DISCOVERABLE_EVENT_anchor">ACI_GAP_LIMITED_DISCOVERABLE_EVENT</a> event. </p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Type</p>
</td><td><p>1</p>
</td><td><p>Advertising type. Advertising_Type type cannot be any of GAP_ADV_HIGH_DC_DIRECT_IND or GAP_ADV_HIGH_DC_DIRECT_IND.</p>
</td><td><li>0x00: ADV_IND (Connectable undirected advertising)</li><li>0x01: ADV_DIRECT_IND (Connectable directed advertising)</li><li>0x02: ADV_SCAN_IND (Scannable undirected advertising)</li><li>0x03: ADV_NONCONN_IND (Non connectable undirected advertising)</li></td></tr>
<tr><td><p>Advertising_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum advertising interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Advertising_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum advertising interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Own address type:</dt>
<dd><ul class="first last simple">
<li>0x00: Public Device Address (it is allowed only if privacy is disabled)</li>
<li>0x01: Random Device Address (it is allowed only if privacy is disabled)</li>
<li>0x02: Resolvable Private Address (it is allowed only if privacy is enabled)</li>
<li>0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled)</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Public Device Address </li><li>0x01: Random Device Address </li><li>0x02: Resolvable Private Address</li><li>0x03: Non Resolvable Private Address</li></td></tr>
<tr><td><p>Advertising_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>Advertising filter policy: not applicable (the value of Advertising_Filter_Policy parameter is not used inside the Stack)</p>
</td><td></tr>
<tr><td><p>Local_Name_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the local_name field in octets.
If length is set to 0x00, Local_Name parameter is not used.</p>
</td><td></tr>
<tr><td><p>Local_Name</p>
</td><td><p>Local_Name_Length</p>
</td><td><p>Local name of the device. First byte must be 0x08 for Shortened Local Name
or 0x09 for Complete Local Name. No NULL character at the end.</p>
</td><td></tr>
<tr><td><p>Service_Uuid_length</p>
</td><td><p>1</p>
</td><td><p>Length of the Service Uuid List in octets.
If there is no service to be advertised, set this field to 0x00.</p>
</td><td></tr>
<tr><td><p>Service_Uuid_List</p>
</td><td><p>Service_Uuid_length</p>
</td><td><p>This is the list of the UUIDs as defined in Volume 3,
Section 11 of GAP Specification. First byte is the AD Type.
See also Supplement to the Bluetooth Core 5.0 specification.</p>
</td><td></tr>
<tr><td><p>Slave_Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Slave connection interval minimum value suggested by Peripheral.
If Slave_Conn_Interval_Min and Slave_Conn_Interval_Max are not 0x0000,
Slave Connection Interval Range AD structure will be added in advertising
data.
Connection interval is defined in the following manner:
connIntervalmin = Slave_Conn_Interval_Min x 1.25ms.</p>
</td><td><li>0x0000 (NaN) </li><li>0xFFFF (NaN) : No specific minimum</li><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Slave_Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Slave connection interval maximum value suggested by Peripheral.
If Slave_Conn_Interval_Min and Slave_Conn_Interval_Max are not 0x0000,
Slave Connection Interval Range AD structure will be added in advertising
data.
Connection interval is defined in the following manner:
connIntervalmax = Slave_Conn_Interval_Max x 1.25ms</p>
</td><td><li>0x0000 (NaN) </li><li>0xFFFF (NaN) : No specific maximum</li><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GAP_LIMITED_DISCOVERABLE_EVENT_anchor">ACI_GAP_LIMITED_DISCOVERABLE_EVENT</a></li><h2><a name="ACI_GAP_SET_DISCOVERABLE_anchor">ACI_GAP_SET_DISCOVERABLE</a></h2><h3>Description</h3><p>Put the device in general discoverable mode (as defined in Bluetooth Specification v.5.0,
Vol. 3, Part C, section 9.2.4). The device will be discoverable until the host issues 
the <a href="#ACI_GAP_SET_NON_DISCOVERABLE_anchor">ACI_GAP_SET_NON_DISCOVERABLE</a> command. The Adv_Interval_Min and Adv_Interval_Max
parameters are optional. If both are set to 0, the GAP uses the default values for adv
intervals for general discoverable mode.
When using connectable undirected advertising events:
- Adv_Interval_Min = 30 ms 
- Adv_Interval_Max = 60 ms
When using non-connectable advertising events or scannable undirected advertising events:
- Adv_Interval_Min = 100 ms 
- Adv_Interval_Max = 150 ms 
Host can set the Local Name, a Service UUID list and the Slave Connection Interval Range.
If provided, these data will be inserted into the advertising packet payload as AD data.
These parameters are optional in this command. These values can be also set using
aci_gap_update_adv_data() separately.
The total size of data in advertising packet cannot exceed 31 bytes.
With this command, the BLE Stack will also add automatically the following standard
AD types:
- AD Flags
- TX Power Level</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Type</p>
</td><td><p>1</p>
</td><td><p>Advertising type. Advertising_Type type cannot be any of GAP_ADV_HIGH_DC_DIRECT_IND or GAP_ADV_HIGH_DC_DIRECT_IND.</p>
</td><td><li>0x00: ADV_IND (Connectable undirected advertising)</li><li>0x01: ADV_DIRECT_IND (Connectable directed advertising)</li><li>0x02: ADV_SCAN_IND (Scannable undirected advertising)</li><li>0x03: ADV_NONCONN_IND (Non connectable undirected advertising)</li></td></tr>
<tr><td><p>Advertising_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum advertising interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Advertising_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum advertising interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Own address type:</dt>
<dd><ul class="first last simple">
<li>0x00: Public Device Address (it is allowed only if privacy is disabled)</li>
<li>0x01: Random Device Address (it is allowed only if privacy is disabled)</li>
<li>0x02: Resolvable Private Address (it is allowed only if privacy is enabled)</li>
<li>0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled)</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Public Device Address </li><li>0x01: Random Device Address </li><li>0x02: Resolvable Private Address</li><li>0x03: Non Resolvable Private Address</li></td></tr>
<tr><td><p>Advertising_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>Advertising filter policy: not applicable (the value of Advertising_Filter_Policy parameter is not used inside the Stack)</p>
</td><td></tr>
<tr><td><p>Local_Name_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the local_name field in octets.
If length is set to 0x00, Local_Name parameter is not used.</p>
</td><td></tr>
<tr><td><p>Local_Name</p>
</td><td><p>Local_Name_Length</p>
</td><td><p>Local name of the device. First byte must be 0x08 for Shortened Local Name
or 0x09 for Complete Local Name. No NULL character at the end.</p>
</td><td></tr>
<tr><td><p>Service_Uuid_length</p>
</td><td><p>1</p>
</td><td><p>Length of the Service Uuid List in octets.
If there is no service to be advertised, set this field to 0x00.</p>
</td><td></tr>
<tr><td><p>Service_Uuid_List</p>
</td><td><p>Service_Uuid_length</p>
</td><td><p>This is the list of the UUIDs as defined in Volume 3,
Section 11 of GAP Specification. First byte is the AD Type.
See also Supplement to the Bluetooth Core 5.0 specification.</p>
</td><td></tr>
<tr><td><p>Slave_Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Slave connection interval minimum value suggested by Peripheral.
If Slave_Conn_Interval_Min and Slave_Conn_Interval_Max are not 0x0000,
Slave Connection Interval Range AD structure will be added in advertising
data.
Connection interval is defined in the following manner:
connIntervalmin = Slave_Conn_Interval_Min x 1.25ms.</p>
</td><td><li>0x0000 (NaN) </li><li>0xFFFF (NaN) : No specific minimum</li><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Slave_Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Slave connection interval maximum value suggested by Peripheral.
If Slave_Conn_Interval_Min and Slave_Conn_Interval_Max are not 0x0000,
Slave Connection Interval Range AD structure will be added in advertising
data.
Connection interval is defined in the following manner:
connIntervalmax = Slave_Conn_Interval_Max x 1.25ms</p>
</td><td><li>0x0000 (NaN) </li><li>0xFFFF (NaN) : No specific maximum</li><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_DIRECT_CONNECTABLE_anchor">ACI_GAP_SET_DIRECT_CONNECTABLE</a></h2><h3>Description</h3><p>Set the device in direct connectable mode (as defined in Bluetooth Specification v.5.0,
Vol. 3, Part C, section 9.3.3). Device uses direct connectable mode to advertise using High Duty
cycle advertisement events or Low Duty cycle advertisement events and the address as
either what is specified in the Own Address Type parameter. The command specifies the type of the advertising used.
If the privacy is enabled, the Type parameter in reconnection address is used for advertising, otherwise the address
of the type specified in OwnAddrType is used.
The device will be in directed connectable mode only for 1.28 seconds. If no connection
is established within this duration, the device enters non discoverable mode and
advertising will have to be again enabled explicitly.
The controller generates a <a href="#HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a> event with the status set to
HCI_DIRECTED_ADV_TIMEOUT if the connection was not established and 0x00 if the
connection was successfully established.If Host privacy (i.e. privacy 1.1) is enabled this command returns BLE_STATUS_INVALID_PARAMS.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Own address type:</dt>
<dd><ul class="first last simple">
<li>0x00: Public Device Address (only if privacy is disabled)</li>
<li>0x01: Random Device Address (only if privacy is disabled)</li>
<li>0x02: Resolvable Private Address (only if privacy is enabled)</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Public Device Address </li><li>0x01: Random Device Address </li><li>0x02: Resolvable Private Address</li></td></tr>
<tr><td><p>Directed_Advertising_Type</p>
</td><td><p>1</p>
</td><td><p>Type of directed advertising.</p>
</td><td><li>0x01: High Duty Cycle Directed Advertising</li><li>0x04: Low Duty Cycle Directed Advertising</li></td></tr>
<tr><td><p>Direct_Address_Type</p>
</td><td><p>1</p>
</td><td><p>The address type of the peer device.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Direct_Address</p>
</td><td><p>6</p>
</td><td><p>Initiator Bluetooth address</p>
</td><td></tr>
<tr><td><p>Advertising_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum advertising interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Advertising_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum advertising interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_IO_CAPABILITY_anchor">ACI_GAP_SET_IO_CAPABILITY</a></h2><h3>Description</h3><p>Set the IO capabilities of the device. This command has to be given only when the device is
not in a connected state.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>IO_Capability</p>
</td><td><p>1</p>
</td><td><p>IO capability of the device.</p>
</td><td><li>0x00: IO_CAP_DISPLAY_ONLY</li><li>0x01: IO_CAP_DISPLAY_YES_NO</li><li>0x02: IO_CAP_KEYBOARD_ONLY</li><li>0x03: IO_CAP_NO_INPUT_NO_OUTPUT</li><li>0x04: IO_CAP_KEYBOARD_DISPLAY</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_AUTHENTICATION_REQUIREMENT_anchor">ACI_GAP_SET_AUTHENTICATION_REQUIREMENT</a></h2><h3>Description</h3><p>Set the authentication requirements for the device. If the OOB_Enable is set to 0, the
following 16 octets of OOB_Data will be ignored on reception. This command has to be
given only when the device is not in a connected state.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Bonding_Mode</p>
</td><td><p>1</p>
</td><td><p>Bonding mode.
Only if bonding is enabled (0x01), the bonding
information is stored in flash</p>
</td><td><li>0x00: No-bonding mode</li><li>0x01: Bonding mode</li></td></tr>
<tr><td><p>MITM_Mode</p>
</td><td><p>1</p>
</td><td><p>MITM mode.</p>
</td><td><li>0x00: MITM protection not required</li><li>0x01: MITM protection required</li></td></tr>
<tr><td><p>SC_Support</p>
</td><td><p>1</p>
</td><td><p>LE Secure connections support</p>
</td><td><li>0x00: Secure Connections Pairing not supported</li><li>0x01: Secure Connections Pairing supported but optional</li><li>0x02: Secure Connections Pairing supported and mandatory (SC Only Mode)</li></td></tr>
<tr><td><p>KeyPress_Notification_Support</p>
</td><td><p>1</p>
</td><td><p>Keypress notification support</p>
</td><td><li>0x00: Keypress notification not supported</li><li>0x01: Keypress notification supported</li></td></tr>
<tr><td><p>Min_Encryption_Key_Size</p>
</td><td><p>1</p>
</td><td><p>Minimum encryption key size to be used during pairing</p>
</td><td></tr>
<tr><td><p>Max_Encryption_Key_Size</p>
</td><td><p>1</p>
</td><td><p>Maximum encryption key size to be used during pairing</p>
</td><td></tr>
<tr><td><p>Use_Fixed_Pin</p>
</td><td><p>1</p>
</td><td><p>Use or not fixed pin. If set to 0x00, then during the pairing process
the application will not be requested for a pin (Fixed_Pin will be used).
If set to 0x01, then during pairing process if a
passkey is required the application will be
notified</p>
</td><td><li>0x00: use a fixed pin</li><li>0x01: do not use a fixed pin</li></td></tr>
<tr><td><p>Fixed_Pin</p>
</td><td><p>4</p>
</td><td><p>Fixed pin to be used during pairing if MIMT protection is enabled.
Any random value between 0 to 999999</p>
</td><td><li>0 ... 999999</li></td></tr>
<tr><td><p>Identity_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type.</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_AUTHORIZATION_REQUIREMENT_anchor">ACI_GAP_SET_AUTHORIZATION_REQUIREMENT</a></h2><h3>Description</h3><p>Set the authorization requirements of the device. This command has to be given when connected
to a device if authorization is required to access services which require authorization.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Authorization_Enable</p>
</td><td><p>1</p>
</td><td><p>Enable the authorization in the device
and when a remote device tries to read/write a characteristic with authorization
requirements, the stack will send back an error response with
&quot;Insufficient authorization&quot; error code. After pairing is complete a
ACI_GAP_AUTHORIZATION_REQ_EVENT will be sent to the Host.</p>
</td><td><li>0x00: Authorization not required</li><li>0x01: Authorization required</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_PASS_KEY_RESP_anchor">ACI_GAP_PASS_KEY_RESP</a></h2><h3>Description</h3><p>This command should be send by the host in response to <a href="#ACI_GAP_PASS_KEY_REQ_EVENT_anchor">ACI_GAP_PASS_KEY_REQ_EVENT</a>
event. The command parameter contains the pass key which will be used during the pairing process.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Pass_Key</p>
</td><td><p>4</p>
</td><td><p>Pass key that will be used during the pairing process.
Must be a six-digit decimal number.</p>
</td><td><li>0 ... 999999</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#ACI_GAP_PAIRING_COMPLETE_EVENT_anchor">ACI_GAP_PAIRING_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_AUTHORIZATION_RESP_anchor">ACI_GAP_AUTHORIZATION_RESP</a></h2><h3>Description</h3><p>Authorize a device to access attributes. This command should be send by the host in
response to <a href="#ACI_GAP_AUTHORIZATION_REQ_EVENT_anchor">ACI_GAP_AUTHORIZATION_REQ_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Authorize</p>
</td><td><p>1</p>
</td><td><p>Authorization response.</p>
</td><td><li>0x01: Authorize</li><li>0x02: Reject</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_INIT_anchor">ACI_GAP_INIT</a></h2><h3>Description</h3><p>Initialize the GAP layer. Register the GAP service with the GATT.
All the standard GAP characteristics will also be added:
- Device Name
- Appearance
- Peripheral Preferred Connection Parameters (peripheral role only)</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Role</p>
</td><td><p>1</p>
</td><td><p>Bitmap of allowed roles.</p>
</td><td><p>Bitmask of:</p><br><li>0x01: Peripheral</li><li>0x02: Broadcaster</li><li>0x04: Central</li><li>0x08: Observer</li></td></tr>
<tr><td><p>privacy_enabled</p>
</td><td><p>1</p>
</td><td><p>Specify if privacy is enabled or not and which one .</p>
</td><td><li>0x00: Privacy disabled</li><li>0x01: Privacy host enabled</li><li>0x02: Privacy controller enabled</li></td></tr>
<tr><td><p>device_name_char_len</p>
</td><td><p>1</p>
</td><td><p>Length of the device name characteristic</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Service_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the GAP service</p>
</td><td></tr>
<tr><td><p>Dev_Name_Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Device Name Characteristic handle</p>
</td><td></tr>
<tr><td><p>Appearance_Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Appearance Characteristic handle</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_NON_CONNECTABLE_anchor">ACI_GAP_SET_NON_CONNECTABLE</a></h2><h3>Description</h3><p>Put the device into non connectable mode. This mode does not support connection. The
privacy setting done in the <a href="#ACI_GAP_INIT_anchor">ACI_GAP_INIT</a> command plays a role in deciding the valid 
parameters for this command.Advertiser filter policy is internally set to 0x00</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Event_Type</p>
</td><td><p>1</p>
</td><td><p>Advertising type.</p>
</td><td><li>0x02: ADV_SCAN_IND (Scannable undirected advertising)</li><li>0x03: ADV_NONCONN_IND (Non connectable undirected advertising)</li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Own address type:</dt>
<dd><ul class="first last simple">
<li>0x00: Public Device Address (it is allowed only if privacy is disabled)</li>
<li>0x01: Random Device Address (it is allowed only if privacy is disabled)</li>
<li>0x02: Resolvable Private Address (it is allowed only if privacy is enabled)</li>
<li>0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled)</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Public Device Address </li><li>0x01: Random Device Address </li><li>0x02: Resolvable Private Address</li><li>0x03: Non Resolvable Private Address</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_UNDIRECTED_CONNECTABLE_anchor">ACI_GAP_SET_UNDIRECTED_CONNECTABLE</a></h2><h3>Description</h3><p>Put the device into undirected connectable mode.
If privacy is enabled in the device, a resolvable private address is generated and used as the 
advertiser's address. If not, the address of the type specified in own_addr_type is used for
advertising.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum advertising interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Advertising_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum advertising interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Own address type:</dt>
<dd><ul class="first last simple">
<li>0x00: Public Device Address (it is allowed only if privacy is disabled)</li>
<li>0x01: Random Device Address (it is allowed only if privacy is disabled)</li>
<li>0x02: Resolvable Private Address (it is allowed only if controller privacy is enabled or if Host privacy (i.e. privacy 1.1) is enabled)</li>
<li>0x03: Non Resolvable Private Address (it is allowed only if Host privacy (i.e. privacy 1.1) is enabled)</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Public Device Address </li><li>0x01: Random Device Address </li><li>0x02: Resolvable Private Address</li><li>0x03: Non Resolvable Private Address</li></td></tr>
<tr><td><p>Adv_Filter_Policy</p>
</td><td><p>1</p>
</td><td><p>Advertising filter policy.</p>
</td><td><li>0x00: Allow Scan Request from Any, Allow Connect Request from Any</li><li>0x03: Allow Scan Request from White List Only, Allow Connect Request from White List Only</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SLAVE_SECURITY_REQ_anchor">ACI_GAP_SLAVE_SECURITY_REQ</a></h2><h3>Description</h3><p>Send a slave security request to the master.
This command has to be issued to notify the master of the security requirements of the slave.
The master may encrypt the link, initiate the pairing procedure, or reject the request.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT_anchor">ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT</a></li><h2><a name="ACI_GAP_UPDATE_ADV_DATA_anchor">ACI_GAP_UPDATE_ADV_DATA</a></h2><h3>Description</h3><p>This command can be used to update the advertising data for a particular AD type. If the AD
type specified does not exist, then it is added to the advertising data. If the overall
advertising data length is more than 31 octets after the update, then the command is
rejected and the old data is retained.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>AdvDataLen</p>
</td><td><p>1</p>
</td><td><p>Length of AdvData in octets</p>
</td><td></tr>
<tr><td><p>AdvData</p>
</td><td><p>AdvDataLen</p>
</td><td><p>Advertising data used by the device while advertising.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_DELETE_AD_TYPE_anchor">ACI_GAP_DELETE_AD_TYPE</a></h2><h3>Description</h3><p>This command can be used to delete the specified AD type from the advertisement data if
present.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>ADType</p>
</td><td><p>1</p>
</td><td><p>One of the AD types like in Bluetooth specification (see volume 3, Part C, 11.1)</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_GET_SECURITY_LEVEL_anchor">ACI_GAP_GET_SECURITY_LEVEL</a></h2><h3>Description</h3><p>This command can be used to get the current security settings of the device.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Security_Mode</p>
</td><td><p>1</p>
</td><td><p>Security mode.</p>
</td><td><li>0x01: Security Mode 1</li><li>0x02: Security Mode 2</li></td></tr>
<tr><td><p>Security_Level</p>
</td><td><p>1</p>
</td><td><p>Security Level.</p>
</td><td><li>0x01: Security Level 1</li><li>0x02: Security Level 2</li><li>0x03: Security Level 3</li><li>0x04: Security Level 4</li></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_EVENT_MASK_anchor">ACI_GAP_SET_EVENT_MASK</a></h2><h3>Description</h3><p>It allows masking events from the GAP. The default configuration is all the events masked.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>GAP_Evt_Mask</p>
</td><td><p>2</p>
</td><td><p>GAP event mask. Default: 0xFFFF.</p>
</td><td><p>Bitmask of:</p><br><li>0x0000: No events</li><li>0x0001: ACI_GAP_LIMITED_DISCOVERABLE_EVENT</li><li>0x0002: ACI_GAP_PAIRING_COMPLETE_EVENT</li><li>0x0004: ACI_GAP_PASS_KEY_REQ_EVENT</li><li>0x0008: ACI_GAP_AUTHORIZATION_REQ_EVENT</li><li>0x0010: ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT</li><li>0x0020: ACI_GAP_BOND_LOST_EVENT</li><li>0x0080: ACI_GAP_PROC_COMPLETE_EVENT</li><li>0x0100: ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT</li><li>0x0200: ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT</li><li>0x0400: ACI_L2CAP_PROC_TIMEOUT_EVENT</li><li>0x0800: ACI_GAP_ADDR_NOT_RESOLVED_EVENT</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_CONFIGURE_WHITELIST_anchor">ACI_GAP_CONFIGURE_WHITELIST</a></h2><h3>Description</h3><p>Add addresses of bonded devices into the controller's whitelist.
The command will return an error if there are no devices in the database or if it was  
unable to add the device into the whitelist.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_TERMINATE_anchor">ACI_GAP_TERMINATE</a></h2><h3>Description</h3><p>Command the controller to terminate the connection.
A <a href="#HCI_DISCONNECTION_COMPLETE_EVENT_anchor">HCI_DISCONNECTION_COMPLETE_EVENT</a> event will be generated when the link is disconnected. It is important to leave an 100 ms blank window
before sending any new command (including system hardware reset), since immediately after <a href="#HCI_DISCONNECTION_COMPLETE_EVENT_anchor">HCI_DISCONNECTION_COMPLETE_EVENT</a> event,
system could save important information in non volatile memory.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Reason</p>
</td><td><p>1</p>
</td><td><p>The reason for ending the connection.</p>
</td><td><li>0x05: Authentication Failure</li><li>0x13: Remote User Terminated Connection</li><li>0x14: Remote Device Terminated Connection due to Low Resources</li><li>0x15: Remote Device Terminated Connection due to Power Off</li><li>0x1A: Unsupported Remote Feature</li><li>0x3B: Unacceptable Connection Parameters</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_DISCONNECTION_COMPLETE_EVENT_anchor">HCI_DISCONNECTION_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_CLEAR_SECURITY_DB_anchor">ACI_GAP_CLEAR_SECURITY_DB</a></h2><h3>Description</h3><p>Clear the security database. All the devices in the security database will be removed.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_ALLOW_REBOND_anchor">ACI_GAP_ALLOW_REBOND</a></h2><h3>Description</h3><p>Allows the security manager to complete the pairing procedure and re-bond with the master.
This command should be given by the application when it receives the
ACI_GAP_BOND_LOST_EVENT if it wants the re-bonding to happen successfully. If this
command is not given on receiving the event, the bonding procedure will timeout.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_START_LIMITED_DISCOVERY_PROC_anchor">ACI_GAP_START_LIMITED_DISCOVERY_PROC</a></h2><h3>Description</h3><p>Start the limited discovery procedure. The controller is commanded to start active scanning.
When this procedure is started, only the devices in limited discoverable mode are returned
to the upper layers.
The procedure is terminated when either the upper layers issue a command to terminate 
the procedure by issuing the command <a href="#ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a> with the procedure 
code set to 0x01 or a timeout happens. When the procedure is terminated due to any of the 
above  reasons, <a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a> event is returned with the procedure code
set to 0x01.
The device found when the procedure is ongoing is returned to the upper layers through the
event <a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a>.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started
its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window
shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Own address type:</dt>
<dd><ul class="first last simple">
<li>0x00: Public Device Address (it is allowed only if privacy is disabled)</li>
<li>0x01: Random Device Address (it is allowed only if privacy is disabled)</li>
<li>0x02: Resolvable Private Address (it is allowed only if privacy is enabled)</li>
<li>0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled)</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Public Device Address </li><li>0x01: Random Device Address </li><li>0x02: Resolvable Private Address</li><li>0x03: Non Resolvable Private Address</li></td></tr>
<tr><td><p>Filter_Duplicates</p>
</td><td><p>1</p>
</td><td><p>Enable/disable duplicate filtering.</p>
</td><td><li>0x00: Duplicate filtering disabled</li><li>0x01: Duplicate filtering enabled</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a></li><li><a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_START_GENERAL_DISCOVERY_PROC_anchor">ACI_GAP_START_GENERAL_DISCOVERY_PROC</a></h2><h3>Description</h3><p>Start the general discovery procedure. The controller is commanded to start active
scanning. The procedure is terminated when  either the upper layers issue a command
to terminate the procedure by issuing the command <a href="#ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a>
with the procedure code set to 0x02 or a timeout happens. When the procedure is
terminated due to any of the above reasons, <a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a> event
is returned with the procedure code set to 0x02. The device found when the procedure
is ongoing is returned to <a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a>.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started
its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window
shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Own address type:</dt>
<dd><ul class="first last simple">
<li>0x00: Public Device Address (it is allowed only if privacy is disabled)</li>
<li>0x01: Random Device Address (it is allowed only if privacy is disabled)</li>
<li>0x02: Resolvable Private Address (it is allowed only if privacy is enabled)</li>
<li>0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled)</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Public Device Address </li><li>0x01: Random Device Address </li><li>0x02: Resolvable Private Address</li><li>0x03: Non Resolvable Private Address</li></td></tr>
<tr><td><p>Filter_Duplicates</p>
</td><td><p>1</p>
</td><td><p>Enable/disable duplicate filtering.</p>
</td><td><li>0x00: Duplicate filtering disabled</li><li>0x01: Duplicate filtering enabled</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a></li><li><a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_START_NAME_DISCOVERY_PROC_anchor">ACI_GAP_START_NAME_DISCOVERY_PROC</a></h2><h3>Description</h3><p>Start the name discovery procedure. A LE_Create_Connection call will be made to the
controller by GAP with the initiator filter policy set to "ignore whitelist and process
connectable advertising packets only for the specified device". Once a connection is
established, GATT procedure is started to read the device name characteristic. When the
read is completed (successfully or unsuccessfully), a <a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a>
event is given to the upper layer. The event also contains the name of the device if the
device name was read successfully.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started
its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window
shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address of the device
to be connected.</p>
</td><td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Own address type:</dt>
<dd><ul class="first last simple">
<li>0x00: Public Device Address (it is allowed only if privacy is disabled)</li>
<li>0x01: Random Device Address (it is allowed only if privacy is disabled)</li>
<li>0x02: Resolvable Private Address (it is allowed only if privacy is enabled)</li>
<li>0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled)</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Public Device Address </li><li>0x01: Random Device Address </li><li>0x02: Resolvable Private Address</li><li>0x03: Non Resolvable Private Address</li></td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval. This shall be less
than or equal to Conn_Interval_Max.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval. This shall be
greater than or equal to Conn_Interval_Min.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Slave latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2.
Time = N * 10 msec.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
<tr><td><p>Minimum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the minimum length of connection
needed for this LE connection.
Time = N * 0.625 msec.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Maximum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the maximum length of connection needed
for this LE connection.
Time = N * 0.625 msec.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_START_AUTO_CONNECTION_ESTABLISH_PROC_anchor">ACI_GAP_START_AUTO_CONNECTION_ESTABLISH_PROC</a></h2><h3>Description</h3><p>Start the auto connection establishment procedure. The devices specified are added to the
white list of the controller and a LE_Create_Connection call will be made to the controller by
GAP with the initiator filter policy set to "use whitelist to determine which advertiser to
connect to". When a command is issued to terminate the procedure by upper layer, a
LE_Create_Connection_Cancel call will be made to the controller by GAP.
The procedure is terminated when either a connection is successfully established with one of
the specified devices in the white list or the procedure is explicitly terminated by issuing
the command <a href="#ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a> with the procedure code set to 0x08. A
<a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a> event is returned with the procedure code set to 0x08.If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used;</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started
its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window
shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Own address type:</dt>
<dd><ul class="first last simple">
<li>0x00: Public Device Address (it is allowed only if privacy is disabled)</li>
<li>0x01: Random Device Address (it is allowed only if privacy is disabled)</li>
<li>0x02: Resolvable Private Address (it is allowed only if privacy is enabled)</li>
<li>0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled)</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Public Device Address </li><li>0x01: Random Device Address </li><li>0x02: Resolvable Private Address</li><li>0x03: Non Resolvable Private Address</li></td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval. This shall be less
than or equal to Conn_Interval_Max.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval. This shall be
greater than or equal to Conn_Interval_Min.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Slave latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2.
Time = N * 10 msec.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
<tr><td><p>Minimum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the minimum length of connection
needed for this LE connection.
Time = N * 0.625 msec.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Maximum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the maximum length of connection needed
for this LE connection.
Time = N * 0.625 msec.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Num_of_Whitelist_Entries</p>
</td><td><p>1</p>
</td><td><p>Number of devices that have to be added to the whitelist.</p>
</td><td></tr>
<tr><td><p>Peer_Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Peer_Address[i]</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address of the device
to be added to the white list.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_START_GENERAL_CONNECTION_ESTABLISH_PROC_anchor">ACI_GAP_START_GENERAL_CONNECTION_ESTABLISH_PROC</a></h2><h3>Description</h3><p>Start a general connection establishment procedure. The host enables scanning in the
controller with the scanner filter policy set to "accept all advertising packets" and from the
scanning results, all the devices are sent to the upper layer using the event
LE_Advertising_Report. The upper layer then has to select one of the devices to which it
wants to connect by issuing the command <a href="#ACI_GAP_CREATE_CONNECTION_anchor">ACI_GAP_CREATE_CONNECTION</a>. If privacy is
enabled, then either a private resolvable address or a non resolvable address, based on the
address type specified in the command is set as the scanner address but the gap create
connection always uses a private resolvable address if the general connection
establishment procedure is active.
The procedure is terminated when a connection is established or the upper layer terminates
the procedure by issuing the command <a href="#ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a> with the procedure
code set to 0x10. On completion of the procedure a <a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a> event
is generated with the procedure code set to 0x10. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used;</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Type</p>
</td><td><p>1</p>
</td><td><p>Passive or active scanning. With active scanning SCAN_REQ packets are sent.</p>
</td><td><li>0x00: Passive Scanning</li><li>0x01: Active scanning</li></td></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started
its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window
shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Own address type:</dt>
<dd><ul class="first last simple">
<li>0x00: Public Device Address (it is allowed only if privacy is disabled)</li>
<li>0x01: Random Device Address (it is allowed only if privacy is disabled)</li>
<li>0x02: Resolvable Private Address (it is allowed only if privacy is enabled)</li>
<li>0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled)</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Public Device Address </li><li>0x01: Random Device Address </li><li>0x02: Resolvable Private Address</li><li>0x03: Non Resolvable Private Address</li></td></tr>
<tr><td><p>Scanning_Filter_Policy</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Scanning filter policy:</dt>
<dd><ul class="first last simple">
<li>0x00 Accept all advertisement packets.Directed advertising packets which are not addressed for this device shall be ignored.</li>
<li>0x01 Ignore advertisement packets from devices not in the White List Only.Directed advertising packets which are not addressed for this device shall be ignored.</li>
<li>0x02 Accept all undirected advertisement packets (it is allowed only if controller privacy or host privacy is enabled).Directed advertisement packets where initiator address is a RPA and Directed advertisement packets addressed to this device shall be accepted.</li>
<li>0x03 Accept all undirected advertisement packets from devices that are in the White List.Directed advertisement packets where initiator address is RPA and Directed advertisement packets addressed to this device shall be accepted.</li>
<li>NOTE: if controller privacy is enabled Scanning_Filter_Policy can only assume values 0x00 or 0x02; if Host privacy is enabled Scanning_Filter_Policy can only assume value 0x00.</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Accept all</li><li>0x01: Ignore devices not in the White List</li><li>0x02: Accept all (use resolving list)</li><li>0x03: Ignore devices not in the White List (use resolving list)</li></td></tr>
<tr><td><p>Filter_Duplicates</p>
</td><td><p>1</p>
</td><td><p>Enable/disable duplicate filtering.</p>
</td><td><li>0x00: Duplicate filtering disabled</li><li>0x01: Duplicate filtering enabled</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_START_SELECTIVE_CONNECTION_ESTABLISH_PROC_anchor">ACI_GAP_START_SELECTIVE_CONNECTION_ESTABLISH_PROC</a></h2><h3>Description</h3><p>Start a selective connection establishment procedure. The GAP adds the specified device
addresses into white list and enables scanning in the controller with the scanner filter policy
set to "accept packets only from devices in whitelist". All the devices found are sent to the
upper layer by the event <a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a>. The upper layer then has to select one of
the devices to which it wants to connect by issuing the command <a href="#ACI_GAP_CREATE_CONNECTION_anchor">ACI_GAP_CREATE_CONNECTION</a>.
On completion of the procedure a <a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a> event is generated with
the procedure code set to 0x20. The procedure is terminated when a connection is established
or the upper layer terminates the procedure by issuing the command
<a href="#ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a> with the procedure code set to 0x20.If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used;</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Type</p>
</td><td><p>1</p>
</td><td><p>Passive or active scanning. With active scanning SCAN_REQ packets are sent.</p>
</td><td><li>0x00: Passive Scanning</li><li>0x01: Active scanning</li></td></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started
its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window
shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Own address type:</dt>
<dd><ul class="first last simple">
<li>0x00: Public Device Address (it is allowed only if privacy is disabled)</li>
<li>0x01: Random Device Address (it is allowed only if privacy is disabled)</li>
<li>0x02: Resolvable Private Address (it is allowed only if privacy is enabled)</li>
<li>0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled)</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Public Device Address </li><li>0x01: Random Device Address </li><li>0x02: Resolvable Private Address</li><li>0x03: Non Resolvable Private Address</li></td></tr>
<tr><td><p>Scanning_Filter_Policy</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Scanning filter policy:</dt>
<dd><ul class="first last simple">
<li>0x00 Accept all advertisement packets.Directed advertising packets which are not addressed for this device shall be ignored.</li>
<li>0x01 Ignore advertisement packets from devices not in the White List Only.Directed advertising packets which are not addressed for this device shall be ignored.</li>
<li>0x02 Accept all undirected advertisement packets (it is allowed only if controller privacy or host privacy is enabled).Directed advertisement packets where initiator address is a RPA and Directed advertisement packets addressed to this device shall be accepted.</li>
<li>0x03 Accept all undirected advertisement packets from devices that are in the White List.Directed advertisement packets where initiator address is RPA and Directed advertisement packets addressed to this device shall be accepted.</li>
<li>NOTE: if controller privacy is enabled Scanning_Filter_Policy can only assume values 0x01 or 0x03; if Host privacy is enabled Scanning_Filter_Policy can only assume value 0x01.</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Accept all</li><li>0x01: Ignore devices not in the White List</li><li>0x02: Accept all (use resolving list)</li><li>0x03: Ignore devices not in the White List (use resolving list)</li></td></tr>
<tr><td><p>Filter_Duplicates</p>
</td><td><p>1</p>
</td><td><p>Enable/disable duplicate filtering.</p>
</td><td><li>0x00: Duplicate filtering disabled</li><li>0x01: Duplicate filtering enabled</li></td></tr>
<tr><td><p>Num_of_Whitelist_Entries</p>
</td><td><p>1</p>
</td><td><p>Number of devices that have to be added to the whitelist.</p>
</td><td></tr>
<tr><td><p>Peer_Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Peer_Address[i]</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address of the device
to be added to the white list.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_CREATE_CONNECTION_anchor">ACI_GAP_CREATE_CONNECTION</a></h2><h3>Description</h3><p>Start the direct connection establishment procedure. A LE_Create_Connection call will be
made to the controller by GAP with the initiator filter policy set to "ignore whitelist and
process connectable advertising packets only for the specified device". The procedure can
be terminated explicitly by the upper layer by issuing the command
<a href="#ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a>. When a command is issued to terminate the
procedure by upper layer, a <a href="#HCI_LE_CREATE_CONNECTION_CANCEL_anchor">HCI_LE_CREATE_CONNECTION_CANCEL</a> call will be made to the
controller by GAP.
On termination of the procedure, a <a href="#HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a> event is returned. The  
procedure can be explicitly terminated by the upper layer by issuing the command
<a href="#ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a> with the procedure_code set to 0x40.If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used;</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started
its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window
shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>The address type of the peer device.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address of the device
to be connected.</p>
</td><td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Own address type:</dt>
<dd><ul class="first last simple">
<li>0x00: Public Device Address (it is allowed only if privacy is disabled)</li>
<li>0x01: Random Device Address (it is allowed only if privacy is disabled)</li>
<li>0x02: Resolvable Private Address (it is allowed only if privacy is enabled)</li>
<li>0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled)</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Public Device Address </li><li>0x01: Random Device Address </li><li>0x02: Resolvable Private Address</li><li>0x03: Non Resolvable Private Address</li></td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval. This shall be less
than or equal to Conn_Interval_Max.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval. This shall be
greater than or equal to Conn_Interval_Min.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Slave latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2.
Time = N * 10 msec.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
<tr><td><p>Minimum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the minimum length of connection
needed for this LE connection.
Time = N * 0.625 msec.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Maximum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the maximum length of connection needed
for this LE connection.
Time = N * 0.625 msec.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_TERMINATE_GAP_PROC_anchor">ACI_GAP_TERMINATE_GAP_PROC</a></h2><h3>Description</h3><p>Terminate the specified GATT procedure. An <a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a> event is
returned with the procedure code set to the corresponding procedure.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Procedure_Code</p>
</td><td><p>1</p>
</td><td><p>GAP procedure bitmap.</p>
</td><td><li>0x00: No events</li><li>0x01: GAP_LIMITED_DISCOVERY_PROC</li><li>0x02: GAP_GENERAL_DISCOVERY_PROC</li><li>0x04: GAP_NAME_DISCOVERY_PROC</li><li>0x08: GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC</li><li>0x10: GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC</li><li>0x20: GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC</li><li>0x40: GAP_DIRECT_CONNECTION_ESTABLISHMENT_PROC</li><li>0x80: GAP_OBSERVATION_PROC</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><li><a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_START_CONNECTION_UPDATE_anchor">ACI_GAP_START_CONNECTION_UPDATE</a></h2><h3>Description</h3><p>Start the connection update procedure (only when role is Master). A <a href="#HCI_LE_CONNECTION_UPDATE_anchor">HCI_LE_CONNECTION_UPDATE</a> is called.
On completion of the procedure, an <a href="#HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT</a> event is returned to
the upper layer.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval. This shall be less
than or equal to Conn_Interval_Max.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval. This shall be
greater than or equal to Conn_Interval_Min.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Slave latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2.
Time = N * 10 msec.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
<tr><td><p>Minimum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the minimum length of connection
needed for this LE connection.
Time = N * 0.625 msec.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Maximum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the maximum length of connection needed
for this LE connection.
Time = N * 0.625 msec.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SEND_PAIRING_REQ_anchor">ACI_GAP_SEND_PAIRING_REQ</a></h2><h3>Description</h3><p>Send the SM pairing request to start a pairing process. The authentication requirements and
IO capabilities should be set before issuing this command using the
<a href="#ACI_GAP_SET_IO_CAPABILITY_anchor">ACI_GAP_SET_IO_CAPABILITY</a> and <a href="#ACI_GAP_SET_AUTHENTICATION_REQUIREMENT_anchor">ACI_GAP_SET_AUTHENTICATION_REQUIREMENT</a> commands.
A <a href="#ACI_GAP_PAIRING_COMPLETE_EVENT_anchor">ACI_GAP_PAIRING_COMPLETE_EVENT</a> event is returned after the pairing process is completed.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Force_Rebond</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>If 1, Pairing request will be sent even if the device was previously bonded,</dt>
<dd>otherwise pairing request is not sent.</dd>
</dl>
</td><td><li>0x00: NO</li><li>0x01: YES</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GAP_PAIRING_COMPLETE_EVENT_anchor">ACI_GAP_PAIRING_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_RESOLVE_PRIVATE_ADDR_anchor">ACI_GAP_RESOLVE_PRIVATE_ADDR</a></h2><h3>Description</h3><p>This command tries to resolve the address provided with the IRKs present in its database. If
the address is resolved successfully with any one of the IRKs present in the database, it
returns success and also the corresponding public/static random address stored with the
IRK in the database.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Address</p>
</td><td><p>6</p>
</td><td><p>Address to be resolved</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Actual_Address</p>
</td><td><p>6</p>
</td><td><p>The public or static random address of the peer device, distributed during pairing phase.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_BROADCAST_MODE_anchor">ACI_GAP_SET_BROADCAST_MODE</a></h2><h3>Description</h3><p>This command puts the device into broadcast mode. A privacy enabled device uses either a
resolvable private address or a non-resolvable private address as specified in the
Own_Addr_Type parameter of the command.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Advertising_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum advertising interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Advertising_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum advertising interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0020 (20.000 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>Advertising_Type</p>
</td><td><p>1</p>
</td><td><p>Non connectable advertising type</p>
</td><td><li>0x02: ADV_SCAN_IND (Scannable undirected advertising)</li><li>0x03: ADV_NONCONN_IND (Non connectable undirected advertising)</li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><p>If Privacy is disabled, then the address can be public or static random.
If Privacy is enabled, then the address can be a resolvable private address or a non-resolvable private address.</p>
</td><td><li>0x00: Public address</li><li>0x01: Static random address</li><li>0x02: Resolvable private address</li><li>0x03: Non-resolvable private address</li></td></tr>
<tr><td><p>Adv_Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the advertising data in the advertising packet.</p>
</td><td></tr>
<tr><td><p>Adv_Data</p>
</td><td><p>Adv_Data_Length</p>
</td><td><p>Advertising data used by the device while advertising.</p>
</td><td></tr>
<tr><td><p>Num_of_Whitelist_Entries</p>
</td><td><p>1</p>
</td><td><p>Number of devices that have to be added to the whitelist.</p>
</td><td></tr>
<tr><td><p>Peer_Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Peer_Address[i]</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address of the device
to be added to the white list.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_START_OBSERVATION_PROC_anchor">ACI_GAP_START_OBSERVATION_PROC</a></h2><h3>Description</h3><p>Starts an Observation procedure, when the device is in Observer Role. The host enables
scanning in the controller. The advertising reports are sent to the upper layer using standard
LE Advertising Report Event. (See Bluetooth Core v5.0, Vol. 2, part E, Ch. 7.7.65.2, LE
Advertising Report Event). If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used;</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>LE_Scan_Interval</p>
</td><td><p>2</p>
</td><td><p>This is defined as the time interval from when the Controller started
its last LE scan until it begins the subsequent LE scan.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>LE_Scan_Window</p>
</td><td><p>2</p>
</td><td><p>Amount of time for the duration of the LE scan. LE_Scan_Window
shall be less than or equal to LE_Scan_Interval.
Time = N * 0.625 msec.</p>
</td><td><li>0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms) </li></td></tr>
<tr><td><p>LE_Scan_Type</p>
</td><td><p>1</p>
</td><td><p>Passive or active scanning. With active scanning SCAN_REQ packets are sent.</p>
</td><td><li>0x00: Passive Scanning</li><li>0x01: Active scanning</li></td></tr>
<tr><td><p>Own_Address_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Own address type:</dt>
<dd><ul class="first last simple">
<li>0x00: Public Device Address (it is allowed only if privacy is disabled)</li>
<li>0x01: Random Device Address (it is allowed only if privacy is disabled)</li>
<li>0x02: Resolvable Private Address (it is allowed only if privacy is enabled)</li>
<li>0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled)</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Public Device Address </li><li>0x01: Random Device Address </li><li>0x02: Resolvable Private Address</li><li>0x03: Non Resolvable Private Address</li></td></tr>
<tr><td><p>Filter_Duplicates</p>
</td><td><p>1</p>
</td><td><p>Enable/disable duplicate filtering.</p>
</td><td><li>0x00: Duplicate filtering disabled</li><li>0x01: Duplicate filtering enabled</li></td></tr>
<tr><td><p>Scanning_Filter_Policy</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Scanning filter policy:</dt>
<dd><ul class="first last simple">
<li>0x00 Accept all advertisement packets (it is allowed only if controller privacy is enabled).Directed advertising packets which are not addressed for this device shall be ignored.</li>
<li>0x01 Ignore advertisement packets from devices not in the White List Only.Directed advertising packets which are not addressed for this device shall be ignored.</li>
<li>0x02 Accept all undirected advertisement packets (it is allowed only if controller privacy or host privacy is enabled).Directed advertisement packets where initiator address is a RPA and Directed advertisement packets addressed to this device shall be accepted.</li>
<li>0x03 Accept all undirected advertisement packets from devices that are in the White List.Directed advertisement packets where initiator address is RPA and Directed advertisement packets addressed to this device shall be accepted.</li>
<li>NOTE: If Host privacy is enabled Scanning_Filter_Policy can only take values 0x00 or 0x01;</li>
</ul>
</dd>
</dl>
</td><td><li>0x00: Accept all</li><li>0x01: Ignore devices not in the White List</li><li>0x02: Accept all (use resolving list)</li><li>0x03: Ignore devices not in the White List (use resolving list)</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a></li><h2><a name="ACI_GAP_GET_BONDED_DEVICES_anchor">ACI_GAP_GET_BONDED_DEVICES</a></h2><h3>Description</h3><p>This command gets the list of the devices which are bonded. It returns the
number of addresses and the corresponding address types and values.</p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Num_of_Addresses</p>
</td><td><p>1</p>
</td><td><p>The number of bonded devices</p>
</td><td></tr>
<tr><td><p>Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Address[i]</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address of the device
to be added to the white list.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_IS_DEVICE_BONDED_anchor">ACI_GAP_IS_DEVICE_BONDED</a></h2><h3>Description</h3><p>The command finds whether the device, whose address is specified in the command, is
bonded. If the device is using a resolvable private address and it has been bonded, then the
command will return BLE_STATUS_SUCCESS.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Address type.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Address used by the peer device while advertising</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_NUMERIC_COMPARISON_VALUE_CONFIRM_YESNO_anchor">ACI_GAP_NUMERIC_COMPARISON_VALUE_CONFIRM_YESNO</a></h2><h3>Description</h3><p>This command allows the User to validate/confirm or not the Numeric Comparison value showed through the ACI_GAP_Numeric_Comparison_Value_Event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Confirm_Yes_No</p>
</td><td><p>1</p>
</td><td><p>0 : The Numeric Values showed on both local and peer device are different!
1 : The Numeric Values showed on both local and peer device are equal!</p>
</td><td><li>0x00: No</li><li>0x01: YES</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_PASSKEY_INPUT_anchor">ACI_GAP_PASSKEY_INPUT</a></h2><h3>Description</h3><p>This command permits to signal to the Stack the input type detected during Passkey input.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Input_Type</p>
</td><td><p>1</p>
</td><td><p>Passkey input type detected</p>
</td><td><li>0x00: Passkey entry started</li><li>0x01: Passkey digit entered</li><li>0x02: Passkey digit erased</li><li>0x03: Passkey cleared</li><li>0x04: Passkey entry completed</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_GET_OOB_DATA_anchor">ACI_GAP_GET_OOB_DATA</a></h2><h3>Description</h3><p>This command is sent by the User to get (i.e. to extract from the Stack) the OOB data generated by the Stack itself.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>OOB_Data_Type</p>
</td><td><p>1</p>
</td><td><p>OOB Data type</p>
</td><td><li>0x00: TK (LP v.4.1)</li><li>0x01: Random (SC v.4.2)</li><li>0x02: Confirm (SC v.4.2)</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type.</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Address</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) address of this  device</p>
</td><td></tr>
<tr><td><p>OOB_Data_Type</p>
</td><td><p>1</p>
</td><td><p>OOB Data type</p>
</td><td><li>0x00: TK (LP v.4.1)</li><li>0x01: Random (SC v.4.2)</li><li>0x02: Confirm (SC v.4.2)</li></td></tr>
<tr><td><p>OOB_Data_Len</p>
</td><td><p>1</p>
</td><td><p>Length of OOB Data</p>
</td><td></tr>
<tr><td><p>OOB_Data</p>
</td><td><p>16</p>
</td><td><p>Local Pairing Data intended to the remote device to be sent via OOB.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_SET_OOB_DATA_anchor">ACI_GAP_SET_OOB_DATA</a></h2><h3>Description</h3><p>This command is sent (by the User) to input the OOB data arrived via OOB communication.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Device_Type</p>
</td><td><p>1</p>
</td><td><p>OOB Device type</p>
</td><td><li>0x00: Local device</li><li>0x01: Remote device</li></td></tr>
<tr><td><p>Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type.</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Address</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) address of the peer device</p>
</td><td></tr>
<tr><td><p>OOB_Data_Type</p>
</td><td><p>1</p>
</td><td><p>OOB Data type</p>
</td><td><li>0x00: TK (LP v.4.1)</li><li>0x01: Random (SC v.4.2)</li><li>0x02: Confirm (SC v.4.2)</li></td></tr>
<tr><td><p>OOB_Data_Len</p>
</td><td><p>1</p>
</td><td><p>Length of OOB Data</p>
</td><td></tr>
<tr><td><p>OOB_Data</p>
</td><td><p>16</p>
</td><td><p>Pairing Data received through OOB from remote device</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_ADD_DEVICES_TO_RESOLVING_LIST_anchor">ACI_GAP_ADD_DEVICES_TO_RESOLVING_LIST</a></h2><h3>Description</h3><p>This  command is used to add one device to the list of address translations used to resolve Resolvable Private Addresses in the Controller.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Num_of_Resolving_list_Entries</p>
</td><td><p>1</p>
</td><td><p>Number of devices that have to be added to the resolving list.</p>
</td><td></tr>
<tr><td><p>Peer_Identity_Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Identity address type.</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Identity_Address[i]</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) Identity address of the peer device</p>
</td><td></tr>
<tr><td><p>Clear_Resolving_List</p>
</td><td><p>1</p>
</td><td><p>Clear the resolving list</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GAP_REMOVE_BONDED_DEVICE_anchor">ACI_GAP_REMOVE_BONDED_DEVICE</a></h2><h3>Description</h3><p>This command is used to remove a specified device from bonding table</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Peer_Identity_Address_Type</p>
</td><td><p>1</p>
</td><td><p>Identity address type.</p>
</td><td><li>0x00: Public Identity Address</li><li>0x01: Random (static) Identity Address</li></td></tr>
<tr><td><p>Peer_Identity_Address</p>
</td><td><p>6</p>
</td><td><p>Public or Random (static) Identity address of the peer device</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI GATT/ATT commands_anchor">ACI GATT/ATT commands</a></h2><h3>ACI GATT/ATT commands</h3><table width="800" border="1" class="reference">
<tr><th>Command</th><th>OpCode</th></tr>
<tr><td><a href="#ACI_GATT_INIT_anchor">ACI_GATT_INIT</a></td><td><p>0xFD01</p>
</td></tr>
<tr><td><a href="#ACI_GATT_ADD_SERVICE_anchor">ACI_GATT_ADD_SERVICE</a></td><td><p>0xFD02</p>
</td></tr>
<tr><td><a href="#ACI_GATT_INCLUDE_SERVICE_anchor">ACI_GATT_INCLUDE_SERVICE</a></td><td><p>0xFD03</p>
</td></tr>
<tr><td><a href="#ACI_GATT_ADD_CHAR_anchor">ACI_GATT_ADD_CHAR</a></td><td><p>0xFD04</p>
</td></tr>
<tr><td><a href="#ACI_GATT_ADD_CHAR_DESC_anchor">ACI_GATT_ADD_CHAR_DESC</a></td><td><p>0xFD05</p>
</td></tr>
<tr><td><a href="#ACI_GATT_UPDATE_CHAR_VALUE_anchor">ACI_GATT_UPDATE_CHAR_VALUE</a></td><td><p>0xFD06</p>
</td></tr>
<tr><td><a href="#ACI_GATT_DEL_CHAR_anchor">ACI_GATT_DEL_CHAR</a></td><td><p>0xFD07</p>
</td></tr>
<tr><td><a href="#ACI_GATT_DEL_SERVICE_anchor">ACI_GATT_DEL_SERVICE</a></td><td><p>0xFD08</p>
</td></tr>
<tr><td><a href="#ACI_GATT_DEL_INCLUDE_SERVICE_anchor">ACI_GATT_DEL_INCLUDE_SERVICE</a></td><td><p>0xFD09</p>
</td></tr>
<tr><td><a href="#ACI_GATT_SET_EVENT_MASK_anchor">ACI_GATT_SET_EVENT_MASK</a></td><td><p>0xFD0A</p>
</td></tr>
<tr><td><a href="#ACI_GATT_EXCHANGE_CONFIG_anchor">ACI_GATT_EXCHANGE_CONFIG</a></td><td><p>0xFD0B</p>
</td></tr>
<tr><td><a href="#ACI_ATT_FIND_INFO_REQ_anchor">ACI_ATT_FIND_INFO_REQ</a></td><td><p>0xFD0C</p>
</td></tr>
<tr><td><a href="#ACI_ATT_FIND_BY_TYPE_VALUE_REQ_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_REQ</a></td><td><p>0xFD0D</p>
</td></tr>
<tr><td><a href="#ACI_ATT_READ_BY_TYPE_REQ_anchor">ACI_ATT_READ_BY_TYPE_REQ</a></td><td><p>0xFD0E</p>
</td></tr>
<tr><td><a href="#ACI_ATT_READ_BY_GROUP_TYPE_REQ_anchor">ACI_ATT_READ_BY_GROUP_TYPE_REQ</a></td><td><p>0xFD0F</p>
</td></tr>
<tr><td><a href="#ACI_ATT_PREPARE_WRITE_REQ_anchor">ACI_ATT_PREPARE_WRITE_REQ</a></td><td><p>0xFD10</p>
</td></tr>
<tr><td><a href="#ACI_ATT_EXECUTE_WRITE_REQ_anchor">ACI_ATT_EXECUTE_WRITE_REQ</a></td><td><p>0xFD11</p>
</td></tr>
<tr><td><a href="#ACI_GATT_DISC_ALL_PRIMARY_SERVICES_anchor">ACI_GATT_DISC_ALL_PRIMARY_SERVICES</a></td><td><p>0xFD12</p>
</td></tr>
<tr><td><a href="#ACI_GATT_DISC_PRIMARY_SERVICE_BY_UUID_anchor">ACI_GATT_DISC_PRIMARY_SERVICE_BY_UUID</a></td><td><p>0xFD13</p>
</td></tr>
<tr><td><a href="#ACI_GATT_FIND_INCLUDED_SERVICES_anchor">ACI_GATT_FIND_INCLUDED_SERVICES</a></td><td><p>0xFD14</p>
</td></tr>
<tr><td><a href="#ACI_GATT_DISC_ALL_CHAR_OF_SERVICE_anchor">ACI_GATT_DISC_ALL_CHAR_OF_SERVICE</a></td><td><p>0xFD15</p>
</td></tr>
<tr><td><a href="#ACI_GATT_DISC_CHAR_BY_UUID_anchor">ACI_GATT_DISC_CHAR_BY_UUID</a></td><td><p>0xFD16</p>
</td></tr>
<tr><td><a href="#ACI_GATT_DISC_ALL_CHAR_DESC_anchor">ACI_GATT_DISC_ALL_CHAR_DESC</a></td><td><p>0xFD17</p>
</td></tr>
<tr><td><a href="#ACI_GATT_READ_CHAR_VALUE_anchor">ACI_GATT_READ_CHAR_VALUE</a></td><td><p>0xFD18</p>
</td></tr>
<tr><td><a href="#ACI_GATT_READ_USING_CHAR_UUID_anchor">ACI_GATT_READ_USING_CHAR_UUID</a></td><td><p>0xFD19</p>
</td></tr>
<tr><td><a href="#ACI_GATT_READ_LONG_CHAR_VALUE_anchor">ACI_GATT_READ_LONG_CHAR_VALUE</a></td><td><p>0xFD1A</p>
</td></tr>
<tr><td><a href="#ACI_GATT_READ_MULTIPLE_CHAR_VALUE_anchor">ACI_GATT_READ_MULTIPLE_CHAR_VALUE</a></td><td><p>0xFD1B</p>
</td></tr>
<tr><td><a href="#ACI_GATT_WRITE_CHAR_VALUE_anchor">ACI_GATT_WRITE_CHAR_VALUE</a></td><td><p>0xFD1C</p>
</td></tr>
<tr><td><a href="#ACI_GATT_WRITE_LONG_CHAR_VALUE_anchor">ACI_GATT_WRITE_LONG_CHAR_VALUE</a></td><td><p>0xFD1D</p>
</td></tr>
<tr><td><a href="#ACI_GATT_WRITE_CHAR_RELIABLE_anchor">ACI_GATT_WRITE_CHAR_RELIABLE</a></td><td><p>0xFD1E</p>
</td></tr>
<tr><td><a href="#ACI_GATT_WRITE_LONG_CHAR_DESC_anchor">ACI_GATT_WRITE_LONG_CHAR_DESC</a></td><td><p>0xFD1F</p>
</td></tr>
<tr><td><a href="#ACI_GATT_READ_LONG_CHAR_DESC_anchor">ACI_GATT_READ_LONG_CHAR_DESC</a></td><td><p>0xFD20</p>
</td></tr>
<tr><td><a href="#ACI_GATT_WRITE_CHAR_DESC_anchor">ACI_GATT_WRITE_CHAR_DESC</a></td><td><p>0xFD21</p>
</td></tr>
<tr><td><a href="#ACI_GATT_READ_CHAR_DESC_anchor">ACI_GATT_READ_CHAR_DESC</a></td><td><p>0xFD22</p>
</td></tr>
<tr><td><a href="#ACI_GATT_WRITE_WITHOUT_RESP_anchor">ACI_GATT_WRITE_WITHOUT_RESP</a></td><td><p>0xFD23</p>
</td></tr>
<tr><td><a href="#ACI_GATT_SIGNED_WRITE_WITHOUT_RESP_anchor">ACI_GATT_SIGNED_WRITE_WITHOUT_RESP</a></td><td><p>0xFD24</p>
</td></tr>
<tr><td><a href="#ACI_GATT_CONFIRM_INDICATION_anchor">ACI_GATT_CONFIRM_INDICATION</a></td><td><p>0xFD25</p>
</td></tr>
<tr><td><a href="#ACI_GATT_WRITE_RESP_anchor">ACI_GATT_WRITE_RESP</a></td><td><p>0xFD26</p>
</td></tr>
<tr><td><a href="#ACI_GATT_ALLOW_READ_anchor">ACI_GATT_ALLOW_READ</a></td><td><p>0xFD27</p>
</td></tr>
<tr><td><a href="#ACI_GATT_SET_SECURITY_PERMISSION_anchor">ACI_GATT_SET_SECURITY_PERMISSION</a></td><td><p>0xFD28</p>
</td></tr>
<tr><td><a href="#ACI_GATT_SET_DESC_VALUE_anchor">ACI_GATT_SET_DESC_VALUE</a></td><td><p>0xFD29</p>
</td></tr>
<tr><td><a href="#ACI_GATT_READ_HANDLE_VALUE_anchor">ACI_GATT_READ_HANDLE_VALUE</a></td><td><p>0xFD2A</p>
</td></tr>
<tr><td><a href="#ACI_GATT_UPDATE_CHAR_VALUE_EXT_anchor">ACI_GATT_UPDATE_CHAR_VALUE_EXT</a></td><td><p>0xFD2C</p>
</td></tr>
<tr><td><a href="#ACI_GATT_DENY_READ_anchor">ACI_GATT_DENY_READ</a></td><td><p>0xFD2D</p>
</td></tr>
<tr><td><a href="#ACI_GATT_SET_ACCESS_PERMISSION_anchor">ACI_GATT_SET_ACCESS_PERMISSION</a></td><td><p>0xFD2E</p>
</td></tr>
</table><h2><a name="ACI_GATT_INIT_anchor">ACI_GATT_INIT</a></h2><h3>Description</h3><p>Initialize the GATT layer for server and client roles. 
It adds also the GATT service with Service Changed Characteristic. 
Until this command is issued the GATT channel will not process any commands even if the 
connection is opened. This command has to be given before using any of the GAP features. </p><h3>Input parameters</h3><p>None</p><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_ADD_SERVICE_anchor">ACI_GATT_ADD_SERVICE</a></h2><h3>Description</h3><p>Add a service to GATT Server. When a service is created in the server, the host needs to
reserve the handle ranges for this service using Max_Attribute_Records parameter. This
parameter specifies the maximum number of attribute records that can be added to this
service (including the service attribute, include attribute, characteristic attribute,
characteristic value attribute and characteristic descriptor attribute). Handle of the created
service is returned in command complete event. Service declaration is taken from the service pool. 
The attributes for characteristics and descriptors are allocated from the attribute pool.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Service_UUID_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>Service_UUID</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
<tr><td><p>Service_Type</p>
</td><td><p>1</p>
</td><td><p>Service type.</p>
</td><td><li>0x01: Primary Service</li><li>0x02: Secondary Service</li></td></tr>
<tr><td><p>Max_Attribute_Records</p>
</td><td><p>1</p>
</td><td><p>Maximum number of attribute records that can be added to this service</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Service_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the Service.
When this service is added, a handle is allocated by the server for this service.
Server also allocates a range of handles for this service from serviceHandle to &lt;serviceHandle + max_attr_records - 1&gt;</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_INCLUDE_SERVICE_anchor">ACI_GATT_INCLUDE_SERVICE</a></h2><h3>Description</h3><p>Include a service given by Include_Start_Handle and Include_End_Handle to another 
service given by Service_Handle. Attribute server creates an INCLUDE definition 
attribute and return the handle of this attribute in Included_handle.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Service_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the Service to which another service has to be included.</p>
</td><td></tr>
<tr><td><p>Include_Start_Handle</p>
</td><td><p>2</p>
</td><td><p>Start Handle of the Service which has to be included in service</p>
</td><td></tr>
<tr><td><p>Include_End_Handle</p>
</td><td><p>2</p>
</td><td><p>End Handle of the Service which has to be included in service</p>
</td><td></tr>
<tr><td><p>Include_UUID_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>Include_UUID</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Include_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the include declaration</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_ADD_CHAR_anchor">ACI_GATT_ADD_CHAR</a></h2><h3>Description</h3><p>Add a characteristic to a service.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Service_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the Service to which the characteristic will be added</p>
</td><td></tr>
<tr><td><p>Char_UUID_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>Char_UUID</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
<tr><td><p>Char_Value_Length</p>
</td><td><p>2</p>
</td><td><p>Maximum length of the characteristic value.</p>
</td><td></tr>
<tr><td><p>Char_Properties</p>
</td><td><p>1</p>
</td><td><p>Characteristic Properties (Volume 3, Part G, section 3.3.1.1 of Bluetooth Specification 5.0)</p>
</td><td><p>Bitmask of:</p><br><li>0x00: CHAR_PROP_NONE</li><li>0x01: CHAR_PROP_BROADCAST (Broadcast)</li><li>0x02: CHAR_PROP_READ (Read)</li><li>0x04: CHAR_PROP_WRITE_WITHOUT_RESP (Write w/o resp)</li><li>0x08: CHAR_PROP_WRITE (Write)</li><li>0x10: CHAR_PROP_NOTIFY (Notify)</li><li>0x20: CHAR_PROP_INDICATE (Indicate)</li><li>0x40: CHAR_PROP_SIGNED_WRITE (Authenticated Signed Writes)</li><li>0x80: CHAR_PROP_EXT (Extended Properties)</li></td></tr>
<tr><td><p>Security_Permissions</p>
</td><td><p>1</p>
</td><td><p>Security permission flags.</p>
</td><td><p>Bitmask of:</p><br><li>0x00: None</li><li>0x01: AUTHEN_READ (Need authentication to read)</li><li>0x02: AUTHOR_READ (Need authorization to read)</li><li>0x04: ENCRY_READ (Need encryption to read)</li><li>0x08: AUTHEN_WRITE (need authentication to write)</li><li>0x10: AUTHOR_WRITE (need authorization to write)</li><li>0x20: ENCRY_WRITE (need encryption to write)</li></td></tr>
<tr><td><p>GATT_Evt_Mask</p>
</td><td><p>1</p>
</td><td><p>GATT event mask.</p>
</td><td><p>Bitmask of:</p><br><li>0x00: GATT_DONT_NOTIFY_EVENTS</li><li>0x01: GATT_NOTIFY_ATTRIBUTE_WRITE</li><li>0x02: GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP</li><li>0x04: GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP</li></td></tr>
<tr><td><p>Enc_Key_Size</p>
</td><td><p>1</p>
</td><td><p>Minimum encryption key size required to read the characteristic.</p>
</td><td><li>0x07 ... 0x10</li></td></tr>
<tr><td><p>Is_Variable</p>
</td><td><p>1</p>
</td><td><p>Specify if the characteristic value has a fixed length or
a variable length.</p>
</td><td><li>0x00: Fixed length</li><li>0x01: Variable length</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the Characteristic that has been added.
It is the handle of the characteristic declaration.
The attribute that holds the characteristic value is allocated at the next handle,
followed by the Client Characteristic Configuration descriptor if the characteristic
has CHAR_PROP_NOTIFY or CHAR_PROP_INDICATE properties.</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_ADD_CHAR_DESC_anchor">ACI_GATT_ADD_CHAR_DESC</a></h2><h3>Description</h3><p>Add a characteristic descriptor to a service.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Service_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of service to which the characteristic belongs</p>
</td><td></tr>
<tr><td><p>Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic to which description has to be added</p>
</td><td></tr>
<tr><td><p>Char_Desc_Uuid_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>Char_Desc_Uuid</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
<tr><td><p>Char_Desc_Value_Max_Len</p>
</td><td><p>1</p>
</td><td><p>The maximum length of the descriptor value</p>
</td><td></tr>
<tr><td><p>Char_Desc_Value_Length</p>
</td><td><p>1</p>
</td><td><p>Current Length of the characteristic descriptor value</p>
</td><td></tr>
<tr><td><p>Char_Desc_Value</p>
</td><td><p>Char_Desc_Value_Length</p>
</td><td><p>Value of the characteristic description</p>
</td><td></tr>
<tr><td><p>Security_Permissions</p>
</td><td><p>1</p>
</td><td><p>Security permission flags.</p>
</td><td><p>Bitmask of:</p><br><li>0x00: None</li><li>0x01: AUTHEN_READ (Need authentication to read)</li><li>0x02: AUTHOR_READ (Need authorization to read)</li><li>0x04: ENCRY_READ (Need encryption to read)</li><li>0x08: AUTHEN_WRITE (need authentication to write)</li><li>0x10: AUTHOR_WRITE (need authorization to write)</li><li>0x20: ENCRY_WRITE (need encryption to write)</li></td></tr>
<tr><td><p>Access_Permissions</p>
</td><td><p>1</p>
</td><td><p>Access permission</p>
</td><td><p>Bitmask of:</p><br><li>0x00: None</li><li>0x01: READ</li><li>0x02: WRITE</li><li>0x04: WRITE_WO_RESP</li><li>0x08: SIGNED_WRITE</li></td></tr>
<tr><td><p>GATT_Evt_Mask</p>
</td><td><p>1</p>
</td><td><p>GATT event mask.</p>
</td><td><p>Bitmask of:</p><br><li>0x00: GATT_DONT_NOTIFY_EVENTS</li><li>0x01: GATT_NOTIFY_ATTRIBUTE_WRITE</li><li>0x02: GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP</li><li>0x04: GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP</li></td></tr>
<tr><td><p>Enc_Key_Size</p>
</td><td><p>1</p>
</td><td><p>Minimum encryption key size required to read the characteristic.</p>
</td><td><li>0x07 ... 0x10</li></td></tr>
<tr><td><p>Is_Variable</p>
</td><td><p>1</p>
</td><td><p>Specify if the characteristic value has a fixed length or
a variable length.</p>
</td><td><li>0x00: Fixed length</li><li>0x01: Variable length</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Char_Desc_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic descriptor</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_UPDATE_CHAR_VALUE_anchor">ACI_GATT_UPDATE_CHAR_VALUE</a></h2><h3>Description</h3><p>Update a characteristic value in a service. 
If notifications (or indications) are enabled on that characteristic, 
a notification (or indication) will be sent to the client after sending 
this command to the STM32WB. The command is queued into the STM32WB command queue. 
If the buffer is full, because previous commands could not be still processed,
the function will return BLE_STATUS_INSUFFICIENT_RESOURCES. This will happen 
if notifications (or indications) are enabled and the application calls 
<a href="#ACI_GATT_UPDATE_CHAR_VALUE_anchor">ACI_GATT_UPDATE_CHAR_VALUE</a> at an higher rate than what is allowed by the link. 
Throughput on BLE link depends on connection interval and connection length 
parameters (decided by the master, see aci_l2cap_connection_parameter_update_request() 
for more info on how to suggest new connection parameters from a slave). If the 
application does not want to lose notifications because STM32WB buffer becomes full, 
it has to retry again till the function returns BLE_STATUS_SUCCESS or any other error code.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Service_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of service to which the characteristic belongs</p>
</td><td></tr>
<tr><td><p>Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic declaration</p>
</td><td></tr>
<tr><td><p>Val_Offset</p>
</td><td><p>1</p>
</td><td><p>The offset from which the attribute value has to be updated.
If this is set to 0 and the attribute value is of variable length, then the length of the attribute will be set to the Char_Value_Length.
If the Val_Offset is set to a value greater than 0, then the length of the attribute will be set to the maximum length as
specified for the attribute while adding the characteristic.</p>
</td><td></tr>
<tr><td><p>Char_Value_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the characteristic value in octets</p>
</td><td></tr>
<tr><td><p>Char_Value</p>
</td><td><p>Char_Value_Length</p>
</td><td><p>Characteristic value</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DEL_CHAR_anchor">ACI_GATT_DEL_CHAR</a></h2><h3>Description</h3><p>Delete the specified characteristic from the service.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Serv_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of service to which the characteristic belongs</p>
</td><td></tr>
<tr><td><p>Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic which has to be deleted</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DEL_SERVICE_anchor">ACI_GATT_DEL_SERVICE</a></h2><h3>Description</h3><p>Delete the specified service from the GATT server database.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Serv_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the service to be deleted</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DEL_INCLUDE_SERVICE_anchor">ACI_GATT_DEL_INCLUDE_SERVICE</a></h2><h3>Description</h3><p>Delete the Include definition from the service.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Serv_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the service to which the include service belongs</p>
</td><td></tr>
<tr><td><p>Include_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the included service which has to be deleted</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_SET_EVENT_MASK_anchor">ACI_GATT_SET_EVENT_MASK</a></h2><h3>Description</h3><p>Mask events from the GATT. The default configuration is all the events masked.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>GATT_Evt_Mask</p>
</td><td><p>4</p>
</td><td><p>GATT/ATT event mask.</p>
</td><td><li>0x00000001: ACI_GATT_ATTRIBUTE_MODIFIED_EVENT</li><li>0x00000002: ACI_GATT_PROC_TIMEOUT_EVENT</li><li>0x00000004: ACI_ATT_EXCHANGE_MTU_RESP_EVENT</li><li>0x00000008: ACI_ATT_FIND_INFO_RESP_EVENT</li><li>0x00000010: ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT</li><li>0x00000020: ACI_ATT_READ_BY_TYPE_RESP_EVENT</li><li>0x00000040: ACI_ATT_READ_RESP_EVENT</li><li>0x00000080: ACI_ATT_READ_BLOB_RESP_EVENT</li><li>0x00000100: ACI_ATT_READ_MULTIPLE_RESP_EVENT</li><li>0x00000200: ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT</li><li>0x00000800: ACI_ATT_PREPARE_WRITE_RESP_EVENT</li><li>0x00001000: ACI_ATT_EXEC_WRITE_RESP_EVENT</li><li>0x00002000: ACI_GATT_INDICATION_EVENT</li><li>0x00004000: ACI_GATT_NOTIFICATION_EVENT</li><li>0x00008000: ACI_GATT_ERROR_RESP_EVENT</li><li>0x00010000: ACI_GATT_PROC_COMPLETE_EVENT</li><li>0x00020000: ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</li><li>0x00040000: ACI_GATT_TX_POOL_AVAILABLE_EVENT</li><li>0x00200000: ACI_GATT_INDICATION_EXT_EVENT</li><li>0x00400000: ACI_GATT_NOTIFICATION_EXT_EVENT</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_EXCHANGE_CONFIG_anchor">ACI_GATT_EXCHANGE_CONFIG</a></h2><h3>Description</h3><p>Perform an ATT MTU exchange procedure.
When the ATT MTU exchange procedure is completed, a <a href="#ACI_ATT_EXCHANGE_MTU_RESP_EVENT_anchor">ACI_ATT_EXCHANGE_MTU_RESP_EVENT</a>
event is generated. A <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is also generated
to indicate the end of the procedure.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_EXCHANGE_MTU_RESP_EVENT_anchor">ACI_ATT_EXCHANGE_MTU_RESP_EVENT</a></li><h2><a name="ACI_ATT_FIND_INFO_REQ_anchor">ACI_ATT_FIND_INFO_REQ</a></h2><h3>Description</h3><p>Send a Find Information Request.
This command is used to obtain the mapping of attribute handles with their associated
types. The responses of the procedure are given through the 
<a href="#ACI_ATT_FIND_INFO_RESP_EVENT_anchor">ACI_ATT_FIND_INFO_RESP_EVENT</a> event. The end of the procedure is indicated by
a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Start_Handle</p>
</td><td><p>2</p>
</td><td><p>First requested handle number</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>Last requested handle number</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_FIND_INFO_RESP_EVENT_anchor">ACI_ATT_FIND_INFO_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_ATT_FIND_BY_TYPE_VALUE_REQ_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_REQ</a></h2><h3>Description</h3><p>Send a Find By Type Value Request
The Find By Type Value Request is used to obtain the handles of attributes that
have a given 16-bit UUID attribute type and a given attribute value.
The responses of the procedure are given through the <a href="#ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT</a> event.
The end of the procedure is indicated by a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Start_Handle</p>
</td><td><p>2</p>
</td><td><p>First requested handle number</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>Last requested handle number</p>
</td><td></tr>
<tr><td><p>UUID</p>
</td><td><p>2</p>
</td><td><p>2 octet UUID to find (little-endian)</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of attribute value (maximum value is ATT_MTU - 7).</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Attribute value to find</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_ATT_READ_BY_TYPE_REQ_anchor">ACI_ATT_READ_BY_TYPE_REQ</a></h2><h3>Description</h3><p>Send a Read By Type Request.
The Read By Type Request is used to obtain the values of attributes where the attribute
type is known but the handle is not known.
The responses are given through the <a href="#ACI_ATT_READ_BY_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_TYPE_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Start_Handle</p>
</td><td><p>2</p>
</td><td><p>First requested handle number</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>Last requested handle number</p>
</td><td></tr>
<tr><td><p>UUID_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>UUID</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_BY_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_TYPE_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_ATT_READ_BY_GROUP_TYPE_REQ_anchor">ACI_ATT_READ_BY_GROUP_TYPE_REQ</a></h2><h3>Description</h3><p>Send a Read By Group Type Request. 
The Read By Group Type Request is used to obtain the values of grouping attributes where
the attribute type is known but the handle is not known. Grouping attributes are defined 
at GATT layer. The grouping attribute types are: "Primary Service", "Secondary Service" 
and "Characteristic". 
The responses of the procedure are given through the <a href="#ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT</a> event. 
The end of the procedure is indicated by a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a>.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Start_Handle</p>
</td><td><p>2</p>
</td><td><p>First requested handle number</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>Last requested handle number</p>
</td><td></tr>
<tr><td><p>UUID_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>UUID</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_ATT_PREPARE_WRITE_REQ_anchor">ACI_ATT_PREPARE_WRITE_REQ</a></h2><h3>Description</h3><p>Send a Prepare Write Request.
The Prepare Write Request is used to request the server to prepare to write the value of an attribute. 
The responses of the procedure are given through the <a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a> event. 
The end of the procedure is indicated by a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a>. </p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute to be written</p>
</td><td></tr>
<tr><td><p>Val_Offset</p>
</td><td><p>2</p>
</td><td><p>The offset of the first octet to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of attribute value (maximum value is ATT_MTU - 5).</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>The value of the attribute to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_ATT_EXECUTE_WRITE_REQ_anchor">ACI_ATT_EXECUTE_WRITE_REQ</a></h2><h3>Description</h3><p>Send an Execute Write Request.
The Execute Write Request is used to request the server to write or cancel the write 
of all the prepared values currently held in the prepare queue from this client. 
The result of the procedure is given through the <a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a> event. 
The end of the procedure is indicated by a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event. </p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Execute</p>
</td><td><p>1</p>
</td><td><p>Execute or cancel writes.</p>
</td><td><li>0x00: Cancel all prepared writes</li><li>0x01: Immediately write all pending prepared values</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DISC_ALL_PRIMARY_SERVICES_anchor">ACI_GATT_DISC_ALL_PRIMARY_SERVICES</a></h2><h3>Description</h3><p>Start the GATT client procedure to discover all primary services on the server.
The responses of the procedure are given through the <a href="#ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DISC_PRIMARY_SERVICE_BY_UUID_anchor">ACI_GATT_DISC_PRIMARY_SERVICE_BY_UUID</a></h2><h3>Description</h3><p>Start the procedure to discover the primary services of the specified UUID on the server.
The responses of the procedure are given through the <a href="#ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT</a> event.
The end of the procedure is indicated by a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>UUID_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>UUID</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_FIND_INCLUDED_SERVICES_anchor">ACI_GATT_FIND_INCLUDED_SERVICES</a></h2><h3>Description</h3><p>Start the procedure to find all included services.
The responses of the procedure are given through the <a href="#ACI_ATT_READ_BY_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_TYPE_RESP_EVENT</a> event.
The end of the procedure is indicated by a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Start_Handle</p>
</td><td><p>2</p>
</td><td><p>Start attribute handle of the service</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>End attribute handle of the service</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_BY_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_TYPE_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DISC_ALL_CHAR_OF_SERVICE_anchor">ACI_GATT_DISC_ALL_CHAR_OF_SERVICE</a></h2><h3>Description</h3><p>Start the procedure to discover all the characteristics of a given service.
When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated.
Before procedure completion the response packets are given through
<a href="#ACI_ATT_READ_BY_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_TYPE_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Start_Handle</p>
</td><td><p>2</p>
</td><td><p>Start attribute handle of the service</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>End attribute handle of the service</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_BY_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_TYPE_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DISC_CHAR_BY_UUID_anchor">ACI_GATT_DISC_CHAR_BY_UUID</a></h2><h3>Description</h3><p>Start the procedure to discover all the characteristics specified by a UUID.
When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated.
Before procedure completion the response packets are given through
<a href="#ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT_anchor">ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Start_Handle</p>
</td><td><p>2</p>
</td><td><p>Start attribute handle of the service</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>End attribute handle of the service</p>
</td><td></tr>
<tr><td><p>UUID_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>UUID</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT_anchor">ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DISC_ALL_CHAR_DESC_anchor">ACI_GATT_DISC_ALL_CHAR_DESC</a></h2><h3>Description</h3><p>Start the procedure to discover all characteristic descriptors on the server.
When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated.
Before procedure completion the response packets are given through
<a href="#ACI_ATT_FIND_INFO_RESP_EVENT_anchor">ACI_ATT_FIND_INFO_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic value</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>End handle of the characteristic</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_FIND_INFO_RESP_EVENT_anchor">ACI_ATT_FIND_INFO_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_READ_CHAR_VALUE_anchor">ACI_GATT_READ_CHAR_VALUE</a></h2><h3>Description</h3><p>Start the procedure to read the attribute value.
When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated.
Before procedure completion the response packet is given through <a href="#ACI_ATT_READ_RESP_EVENT_anchor">ACI_ATT_READ_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic value to be read</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_RESP_EVENT_anchor">ACI_ATT_READ_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_READ_USING_CHAR_UUID_anchor">ACI_GATT_READ_USING_CHAR_UUID</a></h2><h3>Description</h3><p>This command sends a Read By Type Request packet to the server in order to read the value attribute of the characteristics specified by the UUID.
When the procedure is completed, an <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated.
Before procedure completion, the response packet is given through one <a href="#ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT_anchor">ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</a> event per reported attribute.
Note: the number of bytes of a value reported by <a href="#ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT_anchor">ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</a> event can not exceed BLE_EVT_MAX_PARAM_LEN - 7 i.e. 248 bytes for default value of BLE_EVT_MAX_PARAM_LEN.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Start_Handle</p>
</td><td><p>2</p>
</td><td><p>Starting handle of the range to be searched</p>
</td><td></tr>
<tr><td><p>End_Handle</p>
</td><td><p>2</p>
</td><td><p>End handle of the range to be searched</p>
</td><td></tr>
<tr><td><p>UUID_Type</p>
</td><td><p>1</p>
</td><td><p>UUID type: 0x01 = 16 bits UUID while 0x02 = 128 bits UUID</p>
</td><td></tr>
<tr><td><p>UUID</p>
</td><td><p>2 or 16</p>
</td><td><p>16-bit UUID or 128-bit UUID</p>
</td><td></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT_anchor">ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_READ_LONG_CHAR_VALUE_anchor">ACI_GATT_READ_LONG_CHAR_VALUE</a></h2><h3>Description</h3><p>Start the procedure to read a long characteristic value.
When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated.
Before procedure completion the response packets are given through <a href="#ACI_ATT_READ_BLOB_RESP_EVENT_anchor">ACI_ATT_READ_BLOB_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic value to be read</p>
</td><td></tr>
<tr><td><p>Val_Offset</p>
</td><td><p>2</p>
</td><td><p>Offset from which the value needs to be read</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_BLOB_RESP_EVENT_anchor">ACI_ATT_READ_BLOB_RESP_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_READ_MULTIPLE_CHAR_VALUE_anchor">ACI_GATT_READ_MULTIPLE_CHAR_VALUE</a></h2><h3>Description</h3><p>Start a procedure to read multiple characteristic values from a server.
This sub-procedure is used to read multiple Characteristic Values from a server when the
client knows the Characteristic Value Handles.
When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated.
Before procedure completion the response packets are given through
<a href="#ACI_ATT_READ_MULTIPLE_RESP_EVENT_anchor">ACI_ATT_READ_MULTIPLE_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Number_of_Handles</p>
</td><td><p>1</p>
</td><td><p>The number of handles for which the value has to be read</p>
</td><td></tr>
<tr><td><p>Handle[i]</p>
</td><td><p>2</p>
</td><td><p>The handles for which the attribute value has to be read</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_MULTIPLE_RESP_EVENT_anchor">ACI_ATT_READ_MULTIPLE_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_WRITE_CHAR_VALUE_anchor">ACI_GATT_WRITE_CHAR_VALUE</a></h2><h3>Description</h3><p>Start the procedure to write a characteristic value.
When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Value to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_WRITE_LONG_CHAR_VALUE_anchor">ACI_GATT_WRITE_LONG_CHAR_VALUE</a></h2><h3>Description</h3><p>Start the procedure to write a long characteristic value.
When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated.
During the procedure, <a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a> and <a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a>
events are raised.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic value to be written</p>
</td><td></tr>
<tr><td><p>Val_Offset</p>
</td><td><p>2</p>
</td><td><p>Offset at which the attribute has to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Value to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><li><a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a></li><li><a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a></li><h2><a name="ACI_GATT_WRITE_CHAR_RELIABLE_anchor">ACI_GATT_WRITE_CHAR_RELIABLE</a></h2><h3>Description</h3><p>Start the procedure to write a characteristic reliably.
When the procedure is completed, a  <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated.
During the procedure, <a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a> and <a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a>
events are raised.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute to be written</p>
</td><td></tr>
<tr><td><p>Val_Offset</p>
</td><td><p>2</p>
</td><td><p>Offset at which the attribute has to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Value to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><li><a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a></li><li><a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a></li><h2><a name="ACI_GATT_WRITE_LONG_CHAR_DESC_anchor">ACI_GATT_WRITE_LONG_CHAR_DESC</a></h2><h3>Description</h3><p>Start the procedure to write a long characteristic descriptor.
When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated.
During the procedure, <a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a> and <a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a>
events are raised.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute to be written</p>
</td><td></tr>
<tr><td><p>Val_Offset</p>
</td><td><p>2</p>
</td><td><p>Offset at which the attribute has to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Value to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><li><a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a></li><li><a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a></li><h2><a name="ACI_GATT_READ_LONG_CHAR_DESC_anchor">ACI_GATT_READ_LONG_CHAR_DESC</a></h2><h3>Description</h3><p>Start the procedure to read a long characteristic value.
When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is
generated. Before procedure completion the response packets are given through
<a href="#ACI_ATT_READ_BLOB_RESP_EVENT_anchor">ACI_ATT_READ_BLOB_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic descriptor</p>
</td><td></tr>
<tr><td><p>Val_Offset</p>
</td><td><p>2</p>
</td><td><p>Offset from which the value needs to be read</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_BLOB_RESP_EVENT_anchor">ACI_ATT_READ_BLOB_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_WRITE_CHAR_DESC_anchor">ACI_GATT_WRITE_CHAR_DESC</a></h2><h3>Description</h3><p>Start the procedure to write a characteristic descriptor.
When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Value to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_READ_CHAR_DESC_anchor">ACI_GATT_READ_CHAR_DESC</a></h2><h3>Description</h3><p>Start the procedure to read the descriptor specified.
When the procedure is completed, a <a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a> event is generated.
Before procedure completion the response packet is given through <a href="#ACI_ATT_READ_RESP_EVENT_anchor">ACI_ATT_READ_RESP_EVENT</a> event.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the descriptor to be read</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_ATT_READ_RESP_EVENT_anchor">ACI_ATT_READ_RESP_EVENT</a></li><li><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_WRITE_WITHOUT_RESP_anchor">ACI_GATT_WRITE_WITHOUT_RESP</a></h2><h3>Description</h3><p>Start the procedure to write a characteristic value without waiting for any response from the
server. No events are generated after this command is executed.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the value to be written (maximum value is ATT_MTU - 3)</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Value to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_SIGNED_WRITE_WITHOUT_RESP_anchor">ACI_GATT_SIGNED_WRITE_WITHOUT_RESP</a></h2><h3>Description</h3><p>Start a signed write without response from the server.
The procedure is used to write a characteristic value with an authentication signature without waiting
for any response from the server. It cannot be used when the link is encrypted.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic value to be written</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the value to be written (up to ATT_MTU - 13)</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Value to be written</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_CONFIRM_INDICATION_anchor">ACI_GATT_CONFIRM_INDICATION</a></h2><h3>Description</h3><p>Allow application to confirm indication. This command has to be sent when the application
receives the event <a href="#ACI_GATT_INDICATION_EVENT_anchor">ACI_GATT_INDICATION_EVENT</a>.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_WRITE_RESP_anchor">ACI_GATT_WRITE_RESP</a></h2><h3>Description</h3><p>Allow or reject a write request from a client.
This command has to be sent by the application when it receives the
<a href="#ACI_GATT_WRITE_PERMIT_REQ_EVENT_anchor">ACI_GATT_WRITE_PERMIT_REQ_EVENT</a>. If the write can be allowed, then the status and error
code has to be set to 0. If the write cannot be allowed, then the status has to be set to 1 and
the error code has to be set to the error code that has to be passed to the client.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute that was passed in the event EVT_BLUE_GATT_WRITE_PERMIT_REQ</p>
</td><td></tr>
<tr><td><p>Write_status</p>
</td><td><p>1</p>
</td><td><p>If the value can be written or not.</p>
</td><td><li>0x00: The value can be written to the attribute specified by attr_handle</li><li>0x01: The value cannot be written to the attribute specified by the attr_handle</li></td></tr>
<tr><td><p>Error_Code</p>
</td><td><p>1</p>
</td><td><p>The error code that has to be passed to the client in case the write has to be rejected</p>
</td><td></tr>
<tr><td><p>Attribute_Val_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the value to be written as passed in the event EVT_BLUE_GATT_WRITE_PERMIT_REQ</p>
</td><td></tr>
<tr><td><p>Attribute_Val</p>
</td><td><p>Attribute_Val_Length</p>
</td><td><p>Value as passed in the event EVT_BLUE_GATT_WRITE_PERMIT_REQ</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_ALLOW_READ_anchor">ACI_GATT_ALLOW_READ</a></h2><h3>Description</h3><p>Allow the GATT server to send a response to a read request from a client.
The application has to send this command when it receives the
<a href="#ACI_GATT_READ_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_PERMIT_REQ_EVENT</a> or <a href="#ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT</a>. This
command indicates to the stack that the response can be sent to the client. So if the
application wishes to update any of the attributes before they are read by the client, it has to
update the characteristic values using the <a href="#ACI_GATT_UPDATE_CHAR_VALUE_anchor">ACI_GATT_UPDATE_CHAR_VALUE</a> and then give
this command. The application should perform the required operations within 30 seconds.
Otherwise the GATT procedure will be timeout.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_SET_SECURITY_PERMISSION_anchor">ACI_GATT_SET_SECURITY_PERMISSION</a></h2><h3>Description</h3><p>This command sets the security permission for the attribute handle specified. Currently the
setting of security permission is allowed only for client configuration descriptor.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Serv_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the service which contains the attribute whose security permission has to be modified</p>
</td><td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute whose security permission has to be modified</p>
</td><td></tr>
<tr><td><p>Security_Permissions</p>
</td><td><p>1</p>
</td><td><p>Security permission flags.</p>
</td><td><p>Bitmask of:</p><br><li>0x00: None</li><li>0x01: AUTHEN_READ (Need authentication to read)</li><li>0x02: AUTHOR_READ (Need authorization to read)</li><li>0x04: ENCRY_READ (Need encryption to read)</li><li>0x08: AUTHEN_WRITE (need authentication to write)</li><li>0x10: AUTHOR_WRITE (need authorization to write)</li><li>0x20: ENCRY_WRITE (need encryption to write)</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_SET_DESC_VALUE_anchor">ACI_GATT_SET_DESC_VALUE</a></h2><h3>Description</h3><p>This command sets the value of the descriptor specified by charDescHandle.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Serv_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the service which contains the characteristic descriptor</p>
</td><td></tr>
<tr><td><p>Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic which contains the descriptor</p>
</td><td></tr>
<tr><td><p>Char_Desc_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the descriptor whose value has to be set</p>
</td><td></tr>
<tr><td><p>Val_Offset</p>
</td><td><p>2</p>
</td><td><p>Offset from which the descriptor value has to be updated</p>
</td><td></tr>
<tr><td><p>Char_Desc_Value_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the descriptor value</p>
</td><td></tr>
<tr><td><p>Char_Desc_Value</p>
</td><td><p>Char_Desc_Value_Length</p>
</td><td><p>Descriptor value</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_READ_HANDLE_VALUE_anchor">ACI_GATT_READ_HANDLE_VALUE</a></h2><h3>Description</h3><p>Reads the value of the attribute handle specified from the local GATT database.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute to read</p>
</td><td></tr>
<tr><td><p>Offset</p>
</td><td><p>2</p>
</td><td><p>Offset from which the value needs to be read</p>
</td><td></tr>
<tr><td><p>Value_Length_Requested</p>
</td><td><p>2</p>
</td><td><p>Maximum number of octets to be returned as attribute value</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Length</p>
</td><td><p>2</p>
</td><td><p>Length of the attribute value</p>
</td><td></tr>
<tr><td><p>Value_Length</p>
</td><td><p>2</p>
</td><td><p>Length in octets of the Value parameter</p>
</td><td></tr>
<tr><td><p>Value</p>
</td><td><p>Value_Length</p>
</td><td><p>Attribute value</p>
</td><td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_UPDATE_CHAR_VALUE_EXT_anchor">ACI_GATT_UPDATE_CHAR_VALUE_EXT</a></h2><h3>Description</h3><p>This command is a more flexible version of <a href="#ACI_GATT_UPDATE_CHAR_VALUE_anchor">ACI_GATT_UPDATE_CHAR_VALUE</a>
                      to support update of long attribute up to 512 bytes and indicate selectively the generation of Indication/Notification.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Conn_Handle_To_Notify</p>
</td><td><p>2</p>
</td><td><p>Connection handle to notify. Notify all subscribed clients if equal to 0x0000</p>
</td><td></tr>
<tr><td><p>Service_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of service to which the characteristic belongs</p>
</td><td></tr>
<tr><td><p>Char_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the characteristic declaration</p>
</td><td></tr>
<tr><td><p>Update_Type</p>
</td><td><p>1</p>
</td><td><dl class="docutils">
<dt>Allow Notification or Indication generation,</dt>
<dd>if enabled in the client characteristic configuration descriptor</dd>
</dl>
</td><td><p>Bitmask of:</p><br><li>0x00: Do not notify</li><li>0x01: Notification</li><li>0x02: Indication</li></td></tr>
<tr><td><p>Char_Length</p>
</td><td><p>2</p>
</td><td><dl class="docutils">
<dt>Total length of the characteristic value.</dt>
<dd>In case of a variable size characteristic, this field specifies the new length of the characteristic value after the update; in case of fixed length characteristic this field is ignored.</dd>
</dl>
</td><td></tr>
<tr><td><p>Value_Offset</p>
</td><td><p>2</p>
</td><td><p>The offset from which the attribute value has to be updated.</p>
</td><td></tr>
<tr><td><p>Value_Length</p>
</td><td><p>1</p>
</td><td><p>Length of the Value parameter in octets</p>
</td><td></tr>
<tr><td><p>Value</p>
</td><td><p>Value_Length</p>
</td><td><p>Updated characteristic value</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_DENY_READ_anchor">ACI_GATT_DENY_READ</a></h2><h3>Description</h3><p>Deny the GATT server to send a response to a read request from a client.
The application may send this command when it receives the <a href="#ACI_GATT_READ_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_PERMIT_REQ_EVENT</a> or  <a href="#ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT</a>.
This command indicates to the stack that the client is not allowed to read the requested characteristic due to e.g. application restrictions.
The Error code shall be either 0x08 (Insufficient Authorization) or a value in the range 0x80-0x9F (Application Error).
The application should issue the <a href="#ACI_GATT_DENY_READ_anchor">ACI_GATT_DENY_READ</a>  or <a href="#ACI_GATT_ALLOW_READ_anchor">ACI_GATT_ALLOW_READ</a> command within 30 seconds from the reception of
the <a href="#ACI_GATT_READ_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_PERMIT_REQ_EVENT</a> or  <a href="#ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT</a> events otherwise the GATT procedure will issue a timeout.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Error_Code</p>
</td><td><p>1</p>
</td><td><p>Error code for the command</p>
</td><td><li>0x08: Insufficient Authorization</li><li>0x80 ... 0x9F: Application Error</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI_GATT_SET_ACCESS_PERMISSION_anchor">ACI_GATT_SET_ACCESS_PERMISSION</a></h2><h3>Description</h3><p>This command sets the access permission for the attribute handle specified.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Serv_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the service which contains the attribute whose access permission has to be modified</p>
</td><td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute whose security permission has to be modified</p>
</td><td></tr>
<tr><td><p>Access_Permissions</p>
</td><td><p>1</p>
</td><td><p>Access permission</p>
</td><td><p>Bitmask of:</p><br><li>0x00: None</li><li>0x01: READ</li><li>0x02: WRITE</li><li>0x04: WRITE_WO_RESP</li><li>0x08: SIGNED_WRITE</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h2><a name="ACI L2CAP commands_anchor">ACI L2CAP commands</a></h2><h3>ACI L2CAP commands</h3><table width="800" border="1" class="reference">
<tr><th>Command</th><th>OpCode</th></tr>
<tr><td><a href="#ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_REQ_anchor">ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_REQ</a></td><td><p>0xFD81</p>
</td></tr>
<tr><td><a href="#ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP_anchor">ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP</a></td><td><p>0xFD82</p>
</td></tr>
</table><h2><a name="ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_REQ_anchor">ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_REQ</a></h2><h3>Description</h3><p>Send an L2CAP connection parameter update request from the slave to the master.
An <a href="#ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT_anchor">ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT</a> event will be raised when the master will respond to the 
request (accepts or rejects).</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval. This shall be less
than or equal to Conn_Interval_Max.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval. This shall be
greater than or equal to Conn_Interval_Min.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Slave_latency</p>
</td><td><p>2</p>
</td><td><p>Slave latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Timeout_Multiplier</p>
</td><td><p>2</p>
</td><td><p>Defines connection timeout parameter in the following manner: Timeout Multiplier * 10ms.</p>
</td><td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></li><li><a href="#ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT_anchor">ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT</a></li><h2><a name="ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP_anchor">ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP</a></h2><h3>Description</h3><p>Accept or reject a connection update. This command should be sent in response
to a <a href="#ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT_anchor">ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT</a> event from the controller. The accept parameter has to be
set if the connection parameters given in the event are acceptable.</p><h3>Input parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Conn_Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval. This shall be less
than or equal to Conn_Interval_Max.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval. This shall be
greater than or equal to Conn_Interval_Min.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Slave_latency</p>
</td><td><p>2</p>
</td><td><p>Slave latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Timeout_Multiplier</p>
</td><td><p>2</p>
</td><td><p>Defines connection timeout parameter in the following manner: Timeout Multiplier * 10ms.</p>
</td><td></tr>
<tr><td><p>Minimum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the minimum length of connection
needed for this LE connection.
Time = N * 0.625 msec.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Maximum_CE_Length</p>
</td><td><p>2</p>
</td><td><p>Information parameter about the maximum length of connection needed
for this LE connection.
Time = N * 0.625 msec.</p>
</td><td><li>0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) </li></td></tr>
<tr><td><p>Identifier</p>
</td><td><p>1</p>
</td><td><p>Identifier received in ACI_L2CAP_Connection_Update_Req event.</p>
</td><td></tr>
<tr><td><p>Accept</p>
</td><td><p>1</p>
</td><td><p>Specify if connection update parameters are acceptable or not.</p>
</td><td><li>0x00: Reject</li><li>0x01: Accept</li></td></tr>
</table><h3>Output parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
</table><h3>Events generated</h3><li><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></li><h1><a name="HCI/ACI events_anchor">HCI/ACI events</a></h1><p><a href="#HCI events_anchor">HCI events</a></p><p><a href="#HCI LE meta events_anchor">HCI LE meta events</a></p><p><a href="#ACI GAP events_anchor">ACI GAP events</a></p><p><a href="#ACI GATT/ATT events_anchor">ACI GATT/ATT events</a></p><p><a href="#ACI L2CAP events_anchor">ACI L2CAP events</a></p><p><a href="#ACI HAL events_anchor">ACI HAL events</a></p><h2><a name="HCI events_anchor">HCI events</a></h2><h3>HCI events</h3><table width="800" border="1" class="reference">
<tr><th>Event name</th><th>Event Code</th></tr>
<tr><td><a href="#HCI_DISCONNECTION_COMPLETE_EVENT_anchor">HCI_DISCONNECTION_COMPLETE_EVENT</a></td><td><p>0x05</p>
</td></tr>
<tr><td><a href="#HCI_ENCRYPTION_CHANGE_EVENT_anchor">HCI_ENCRYPTION_CHANGE_EVENT</a></td><td><p>0x08</p>
</td></tr>
<tr><td><a href="#HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT_anchor">HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT</a></td><td><p>0x0C</p>
</td></tr>
<tr><td><a href="#HCI_HARDWARE_ERROR_EVENT_anchor">HCI_HARDWARE_ERROR_EVENT</a></td><td><p>0x10</p>
</td></tr>
<tr><td><a href="#HCI_NUMBER_OF_COMPLETED_PACKETS_EVENT_anchor">HCI_NUMBER_OF_COMPLETED_PACKETS_EVENT</a></td><td><p>0x13</p>
</td></tr>
<tr><td><a href="#HCI_DATA_BUFFER_OVERFLOW_EVENT_anchor">HCI_DATA_BUFFER_OVERFLOW_EVENT</a></td><td><p>0x1A</p>
</td></tr>
<tr><td><a href="#HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT_anchor">HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT</a></td><td><p>0x30</p>
</td></tr>
<tr><td><a href="#HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></td><td><p>0x0E</p>
</td></tr>
<tr><td><a href="#HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></td><td><p>0x0F</p>
</td></tr>
</table><h2><a name="HCI_DISCONNECTION_COMPLETE_EVENT_anchor">HCI_DISCONNECTION_COMPLETE_EVENT</a></h2><h3>Description</h3><p>The Disconnection Complete event occurs when a connection is terminated.
The status parameter indicates if the disconnection was successful or not. The
reason parameter indicates the reason for the disconnection if the disconnection
was successful. If the disconnection was not successful, the value of the
reason parameter can be ignored by the Host. For example, this can be the
case if the Host has issued the Disconnect command and there was a parameter
error, or the command was not presently allowed, or a Connection_Handle
that didn't correspond to a connection was given.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection_Handle which was disconnected.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Reason</p>
</td><td><p>1</p>
</td><td><p>Reason for disconnection.</p>
</td><td><li>0x00: Success</li><li>0x01: Unknown HCI Command</li><li>0x02: Unknown Connection Identifier</li><li>0x03: Hardware Failure</li><li>0x05: Authentication Failure</li><li>0x06: PIN or Key Missing</li><li>0x07: Memory Capacity Exceeded</li><li>0x08: Connection Timeout</li><li>0x09: Connection Limit Exceeded</li><li>0x0B: ACL Connection Already Exists</li><li>0x0C: Command Disallowed</li><li>0x0D: Connection Rejected Due To Limited Resources</li><li>0x0E: Connection Rejected Due To Security Reasons</li><li>0x0F: Connection Rejected due to Unacceptable BD_ADDR</li><li>0x10: Connection Accept Timeout Exceeded</li><li>0x11: Unsupported Feature Or Parameter Value</li><li>0x12: Invalid HCI Command Parameters</li><li>0x13: Remote User Terminated Connection</li><li>0x14: Remote Device Terminated Connection due to Low Resources</li><li>0x15: Remote Device Terminated Connection due to Power Off</li><li>0x16: Connection Terminated By Local Host</li><li>0x17: Repeated Attempts</li><li>0x18: Pairing Not Allowed</li><li>0x19: Unknown LMP PDU</li><li>0x1A: Unsupported Remote Feature / Unsupported LMP Feature</li><li>0x1E: Invalid LMP Parameters</li><li>0x1F: Unspecified Error</li><li>0x20: Unsupported LMP Parameter Value</li><li>0x21: Role Change Not Allowed</li><li>0x22: LMP Response Timeout / LL Response Timeout</li><li>0x23: LMP Error Transaction Collision</li><li>0x24: LMP PDU Not Allowed</li><li>0x25: Encryption Mode Not Acceptable</li><li>0x26: Link Key cannot be Changed</li><li>0x28: Instant Passed</li><li>0x29: Pairing With Unit Key Not Supported</li><li>0x2A: Different Transaction Collision</li><li>0x2E: Channel Assessment Not Supported</li><li>0x2F: Insufficient Security</li><li>0x30: Parameter Out Of Mandatory Range</li><li>0x32: Role Switch Pending</li><li>0x34: Reserved Slot Violation</li><li>0x35: Role Switch Failed</li><li>0x37: Secure Simple Pairing Not Supported by Host</li><li>0x38: Host Busy - Pairing</li><li>0x39: Connection Rejected due to No Suitable Channel Found</li><li>0x3A: Controller Busy</li><li>0x3B: Unacceptable Connection Interval</li><li>0x3C: Directed Advertising Timeout</li><li>0x3D: Connection Terminated Due to MIC Failure</li><li>0x3E: Connection Failed to be Established</li><li>0x41: Failed</li><li>0x42: Invalid parameters</li><li>0x43: Busy</li><li>0x44: Invalid length</li><li>0x45: Pending</li><li>0x46: Not allowed</li><li>0x47: GATT error</li><li>0x48: Address not resolved</li><li>0x50: Invalid CID</li><li>0x5A: CSRK not found</li><li>0x5B: IRK not found</li><li>0x5C: Device not found in DB</li><li>0x5D: Security DB full</li><li>0x5E: Device not bonded</li><li>0x5F: Device in blacklist</li><li>0x60: Invalid handle</li><li>0x61: Invalid parameter</li><li>0x62: Out of handles</li><li>0x63: Invalid operation</li><li>0x64: Insufficient resources</li><li>0x65: Insufficient encryption key size</li><li>0x66: Characteristic already exist</li><li>0x82: No valid slot</li><li>0x83: Short window</li><li>0x84: New interval failed</li><li>0x85: Too large interval</li><li>0x86: Slot length failed</li></td></tr>
</table><h2><a name="HCI_ENCRYPTION_CHANGE_EVENT_anchor">HCI_ENCRYPTION_CHANGE_EVENT</a></h2><h3>Description</h3><p>The Encryption Change event is used to indicate that the change of the encryption
mode has been completed. The Connection_Handle will be a Connection_Handle
for an ACL connection. The Encryption_Enabled event parameter
specifies the new Encryption_Enabled parameter for the Connection_Handle
specified by the Connection_Handle event parameter. This event will occur on
both devices to notify the Hosts when Encryption has changed for the specified
Connection_Handle between two devices. Note: This event shall not be generated
if encryption is paused or resumed; during a role switch, for example.
The meaning of the Encryption_Enabled parameter depends on whether the
Host has indicated support for Secure Connections in the Secure_Connections_Host_Support
parameter. When Secure_Connections_Host_Support is
'disabled' or the Connection_Handle refers to an LE link, the Controller shall
only use Encryption_Enabled values 0x00 (OFF) and 0x01 (ON).
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.7.8)</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Encryption_Enabled</p>
</td><td><p>1</p>
</td><td><p>Link Level Encryption.</p>
</td><td><li>0x00: Link Level Encryption OFF</li><li>0x01: Link Level Encryption is ON with AES-CCM</li></td></tr>
</table><h2><a name="HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT_anchor">HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT</a></h2><h3>Description</h3><p>The Read Remote Version Information Complete event is used to indicate the
completion of the process obtaining the version information of the remote Controller
specified by the Connection_Handle event parameter. The Connection_Handle
shall be for an ACL connection.
The Version event parameter defines the specification version of the LE Controller.
The Manufacturer_Name event parameter indicates the manufacturer
of the remote Controller. The Subversion event parameter is controlled
by the manufacturer and is implementation dependent. The Subversion
event parameter defines the various revisions that each version of the Bluetooth
hardware will go through as design processes change and errors are
fixed. This allows the software to determine what Bluetooth hardware is being
used and, if necessary, to work around various bugs in the hardware.
When the Connection_Handle is associated with an LE-U logical link, the Version
event parameter shall be Link Layer VersNr parameter, the Manufacturer_Name
event parameter shall be the CompId parameter, and the Subversion
event parameter shall be the SubVersNr parameter.
(See Bluetooth Specification v.5.0, Vol. 2, Part E, 7.7.12)</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Version</p>
</td><td><p>1</p>
</td><td><p>Version of the Current LMP in the remote Controller</p>
</td><td></tr>
<tr><td><p>Manufacturer_Name</p>
</td><td><p>2</p>
</td><td><p>Manufacturer Name of the remote Controller</p>
</td><td></tr>
<tr><td><p>Subversion</p>
</td><td><p>2</p>
</td><td><p>Subversion of the LMP in the remote Controller</p>
</td><td></tr>
</table><h2><a name="HCI_HARDWARE_ERROR_EVENT_anchor">HCI_HARDWARE_ERROR_EVENT</a></h2><h3>Description</h3><p>The Hardware Error event is used to indicate some implementation specific type of hardware failure for the controller. This event is used to notify the Host that a hardware failure has occurred in the Controller.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Hardware_Code</p>
</td><td><p>1</p>
</td><td><p>Hardware Error Event code.
Error code 0 is not used.
Error code 1 is bluecore act2 error detected.
Error code 2 is bluecore time overrun error detected.
Error code 3 is internal FIFO full.</p>
</td><td><li>0x00: Not used</li><li>0x01: event_act2 error</li><li>0x02: event_time_overrun error</li><li>0x03: event_fifo_full error</li></td></tr>
</table><h2><a name="HCI_NUMBER_OF_COMPLETED_PACKETS_EVENT_anchor">HCI_NUMBER_OF_COMPLETED_PACKETS_EVENT</a></h2><h3>Description</h3><p>'The Number Of Completed Packets event is used by the Controller to indicate
to the Host how many HCI Data Packets have been completed (transmitted or
flushed) for each Connection_Handle since the previous Number Of Completed
Packets event was sent to the Host. This means that the corresponding
buffer space has been freed in the Controller. Based on this information, and
the HC_Total_Num_ACL_Data_Packets and HC_Total_Num_Synchronous_-
Data_Packets return parameter of the Read_Buffer_Size command, the Host
can determine for which Connection_Handles the following HCI Data Packets
should be sent to the Controller. The Number Of Completed Packets event
must not be sent before the corresponding Connection Complete event. While
the Controller has HCI data packets in its buffer, it must keep sending the Number
Of Completed Packets event to the Host at least periodically, until it finally
reports that all the pending ACL Data Packets have been transmitted or
flushed.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Number_of_Handles</p>
</td><td><p>1</p>
</td><td><p>The number of Connection_Handles and Num_HCI_Data_Packets parameters pairs contained in this event</p>
</td><td></tr>
<tr><td><p>Connection_Handle[i]</p>
</td><td><p>2</p>
</td><td><p>Connection handle</p>
</td><td></tr>
<tr><td><p>HC_Num_Of_Completed_Packets[i]</p>
</td><td><p>2</p>
</td><td><p>The number of HCI Data Packets that have been completed (transmitted
or flushed) for the associated Connection_Handle since the previous time
the event was returned.</p>
</td><td></tr>
</table><h2><a name="HCI_DATA_BUFFER_OVERFLOW_EVENT_anchor">HCI_DATA_BUFFER_OVERFLOW_EVENT</a></h2><h3>Description</h3><p>'This event is used to indicate that the Controller's data buffers have been overflowed.
This can occur if the Host has sent more packets than allowed. The
Link_Type parameter is used to indicate that the overflow was caused by ACL data.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Link_Type</p>
</td><td><p>1</p>
</td><td><p>On wich type of channel overflow has occurred.</p>
</td><td><li>0x01: ACL Buffer Overflow</li></td></tr>
</table><h2><a name="HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT_anchor">HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT</a></h2><h3>Description</h3><p>'The Encryption Key Refresh Complete event is used to indicate to the Host
that the encryption key was refreshed on the given Connection_Handle any
time encryption is paused and then resumed.
If the Encryption Key Refresh Complete event was generated due to an
encryption pause and resume operation embedded within a change connection
link key procedure, the Encryption Key Refresh Complete event shall be sent
prior to the Change Connection Link Key Complete event.
If the Encryption Key Refresh Complete event was generated due to an
encryption pause and resume operation embedded within a role switch procedure,
the Encryption Key Refresh Complete event shall be sent prior to the
Role Change event.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the command is given.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h2><a name="HCI_COMMAND_COMPLETE_EVENT_anchor">HCI_COMMAND_COMPLETE_EVENT</a></h2><h3>Description</h3><p>'The Command Complete event is used by the Controller for most commands
to transmit return status of a command and the other event parameters that are
specified for the issued HCI command.
The Num_HCI_Command_Packets event parameter allows the Controller to
indicate the number of HCI command packets the Host can send to the Controller.
If the Controller requires the Host to stop sending commands, the
Num_HCI_Command_Packets event parameter will be set to zero. To indicate
to the Host that the Controller is ready to receive HCI command packets, the
Controller generates a Command Complete event with the Command_Opcode
0x0000, and the Num_HCI_Command_Packets event parameter is set to 1 or
more. See each command for the parameters that are returned
by this event.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Num_HCI_Command_Packets</p>
</td><td><p>1</p>
</td><td><p>The Number of HCI command packets which are allowed to be sent to the
Controller from the Host.</p>
</td><td></tr>
<tr><td><p>Command_Opcode</p>
</td><td><p>2</p>
</td><td><p>Opcode of the command which caused this event.</p>
</td><td></tr>
<tr><td><p>Return_Parameters</p>
</td><td><p>variable</p>
</td><td><p>This is the return parameter(s) for the command specified in the
Command_Opcode event parameter. See each command's definition for
the list of return parameters associated with that command.</p>
</td><td></tr>
</table><h2><a name="HCI_COMMAND_STATUS_EVENT_anchor">HCI_COMMAND_STATUS_EVENT</a></h2><h3>Description</h3><p>'The Command Status event is used to indicate that the command described by
the Command_Opcode parameter has been received, and that the Controller
is currently performing the task for this command. This event is needed to provide
mechanisms for asynchronous operation, which makes it possible to prevent
the Host from waiting for a command to finish. If the command cannot
begin to execute (a parameter error may have occurred, or the command may
currently not be allowed), the Status event parameter will contain the corresponding
error code, and no complete event will follow since the command was
not started. The Num_HCI_Command_Packets event parameter allows the
Controller to indicate the number of HCI command packets the Host can send
to the Controller. If the Controller requires the Host to stop sending commands,
the Num_HCI_Command_Packets event parameter will be set to zero. To indicate
to the Host that the Controller is ready to receive HCI command packets,
the Controller generates a Command Status event with Status 0x00 and Command_Opcode
0x0000, and the Num_HCI_Command_Packets event parameter
is set to 1 or more.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Num_HCI_Command_Packets</p>
</td><td><p>1</p>
</td><td><p>The Number of HCI command packets which are allowed to be sent to the
Controller from the Host.</p>
</td><td></tr>
<tr><td><p>Command_Opcode</p>
</td><td><p>2</p>
</td><td><p>Opcode of the command which caused this event.</p>
</td><td></tr>
</table><h2><a name="HCI LE meta events_anchor">HCI LE meta events</a></h2><h3>HCI LE meta events</h3><table width="800" border="1" class="reference">
<tr><th>Subevent name</th><th>Subevent Code</th></tr>
<tr><td><a href="#HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a></td><td><p>0x01</p>
</td></tr>
<tr><td><a href="#HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a></td><td><p>0x02</p>
</td></tr>
<tr><td><a href="#HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT</a></td><td><p>0x03</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_REMOTE_USED_FEATURES_COMPLETE_EVENT_anchor">HCI_LE_READ_REMOTE_USED_FEATURES_COMPLETE_EVENT</a></td><td><p>0x04</p>
</td></tr>
<tr><td><a href="#HCI_LE_LONG_TERM_KEY_REQUEST_EVENT_anchor">HCI_LE_LONG_TERM_KEY_REQUEST_EVENT</a></td><td><p>0x05</p>
</td></tr>
<tr><td><a href="#HCI_LE_DATA_LENGTH_CHANGE_EVENT_anchor">HCI_LE_DATA_LENGTH_CHANGE_EVENT</a></td><td><p>0x07</p>
</td></tr>
<tr><td><a href="#HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT_anchor">HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT</a></td><td><p>0x08</p>
</td></tr>
<tr><td><a href="#HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT_anchor">HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT</a></td><td><p>0x09</p>
</td></tr>
<tr><td><a href="#HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT</a></td><td><p>0x0A</p>
</td></tr>
<tr><td><a href="#HCI_LE_DIRECT_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_DIRECT_ADVERTISING_REPORT_EVENT</a></td><td><p>0x0B</p>
</td></tr>
<tr><td><a href="#HCI_LE_PHY_UPDATE_COMPLETE_EVENT_anchor">HCI_LE_PHY_UPDATE_COMPLETE_EVENT</a></td><td><p>0x0C</p>
</td></tr>
</table><h2><a name="HCI_LE_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_COMPLETE_EVENT</a></h2><h3>Description</h3><p>The LE Connection Complete event indicates to both of the Hosts forming the
connection that a new connection has been created. Upon the creation of the
connection a Connection_Handle shall be assigned by the Controller, and
passed to the Host in this event. If the connection establishment fails this event
shall be provided to the Host that had issued the LE_Create_Connection command.
This event indicates to the Host which issued a LE_Create_Connection
command and received a Command Status event if the connection
establishment failed or was successful.
The Master_Clock_Accuracy parameter is only valid for a slave. On a master,
this parameter shall be set to 0x00. See Bluetooth spec 5.0 vol 2 [part E] 7.7.65.1</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle to be used to identify the connection with the peer device.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Role</p>
</td><td><p>1</p>
</td><td><p>Role of the local device in the connection.</p>
</td><td><li>0x00: Master</li><li>0x01: Slave</li></td></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>The address type of the peer device.</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address of the peer
device</p>
</td><td></tr>
<tr><td><p>Conn_Interval</p>
</td><td><p>2</p>
</td><td><p>Connection interval used on this connection.
Time = N * 1.25 msec</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Slave latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2.
Time = N * 10 msec.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
<tr><td><p>Master_Clock_Accuracy</p>
</td><td><p>1</p>
</td><td><p>Master clock accuracy. Only valid for a slave.</p>
</td><td><li>0x00: 500 ppm</li><li>0x01: 250 ppm</li><li>0x02: 150 ppm</li><li>0x03: 100 ppm</li><li>0x04: 75 ppm</li><li>0x05: 50 ppm</li><li>0x06: 30 ppm</li><li>0x07: 20 ppm</li></td></tr>
</table><h2><a name="HCI_LE_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_ADVERTISING_REPORT_EVENT</a></h2><h3>Description</h3><p>The LE Advertising Report event indicates that a Bluetooth device or multiple
Bluetooth devices have responded to an active scan or received some information
during a passive scan. The Controller may queue these advertising reports
and send information from multiple devices in one LE Advertising Report event. See Bluetooth spec 5.0 vol 2 [part E] 7.7.65.2</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Num_Reports</p>
</td><td><p>1</p>
</td><td><p>Number of responses in this event.</p>
</td><td><li>0x01</li></td></tr>
<tr><td><p>Event_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Type of advertising report event:
ADV_IND: Connectable undirected advertising',
ADV_DIRECT_IND: Connectable directed advertising,
ADV_SCAN_IND: Scannable undirected advertising,
ADV_NONCONN_IND: Non connectable undirected advertising,
SCAN_RSP: Scan response.</p>
</td><td><li>0x00: ADV_IND</li><li>0x01: ADV_DIRECT_IND</li><li>0x02: ADV_SCAN_IND</li><li>0x03: ADV_NONCONN_IND</li><li>0x04: SCAN_RSP</li></td></tr>
<tr><td><p>Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>0x00 Public Device Address
0x01 Random Device Address
0x02 Public Identity Address (Corresponds to Resolved Private Address)
0x03 Random (Static) Identity Address (Corresponds to Resolved Private Address)</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Public Identity Address</li><li>0x03: Random (Static) Identity Address</li></td></tr>
<tr><td><p>Address[i]</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address of the device
to be connected.</p>
</td><td></tr>
<tr><td><p>Length_Data[i]</p>
</td><td><p>1</p>
</td><td><p>Length of the Data[i] field for each device which responded.</p>
</td><td><li>0 ... 31</li></td></tr>
<tr><td><p>Data[i]</p>
</td><td><p>Length_Data[i]</p>
</td><td><p>Length_Data[i] octets of advertising or scan response data formatted
as defined in [Vol 3] Part C, Section 8.</p>
</td><td></tr>
<tr><td><p>RSSI[i]</p>
</td><td><p>1</p>
</td><td><p>N Size: 1 Octet (signed integer)
Units: dBm</p>
</td><td><li>127: RSSI not available</li><li>-127 ... 20</li></td></tr>
</table><h2><a name="HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT_anchor">HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT</a></h2><h3>Description</h3><p>The LE Connection Update Complete event is used to indicate that the Controller
process to update the connection has completed.
On a slave, if no connection parameters are updated, then this event shall not be issued.
On a master, this event shall be issued if the Connection_Update command was sent. See Bluetooth spec 5.0 vol 2 [part E] 7.7.65.3</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle to be used to identify the connection with the peer device.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Conn_Interval</p>
</td><td><p>2</p>
</td><td><p>Connection interval used on this connection.
Time = N * 1.25 msec</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Slave latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2.
Time = N * 10 msec.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
</table><h2><a name="HCI_LE_READ_REMOTE_USED_FEATURES_COMPLETE_EVENT_anchor">HCI_LE_READ_REMOTE_USED_FEATURES_COMPLETE_EVENT</a></h2><h3>Description</h3><p>The LE Read Remote Used Features Complete event is used to indicate the
completion of the process of the Controller obtaining the used features of the
remote Bluetooth device specified by the Connection_Handle event parameter.See Bluetooth spec 5.0 vol 2 [part E] 7.7.65.4</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle to be used to identify the connection with the peer device.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>LE_Features</p>
</td><td><p>8</p>
</td><td><p>Bit Mask List of used LE features. For details see LE Link Layer specification.</p>
</td><td></tr>
</table><h2><a name="HCI_LE_LONG_TERM_KEY_REQUEST_EVENT_anchor">HCI_LE_LONG_TERM_KEY_REQUEST_EVENT</a></h2><h3>Description</h3><p>The LE Long Term Key Request event indicates that the master device is
attempting to encrypt or re-encrypt the link and is requesting the Long Term
Key from the Host. (See [Vol 6] Part B, Section 5.1.3)and Bluetooth spec 5.0 vol 2 [part E] 7.7.65.5</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle to be used to identify the connection with the peer device.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Random_Number</p>
</td><td><p>8</p>
</td><td><p>64-bit random number</p>
</td><td></tr>
<tr><td><p>Encrypted_Diversifier</p>
</td><td><p>2</p>
</td><td><p>16-bit encrypted diversifier</p>
</td><td></tr>
</table><h2><a name="HCI_LE_DATA_LENGTH_CHANGE_EVENT_anchor">HCI_LE_DATA_LENGTH_CHANGE_EVENT</a></h2><h3>Description</h3><p>The LE Data Length Change event notifies the Host of a change to either the
maximum Payload length or the maximum transmission time of packets in
either direction. The values reported are the maximum that will actually be
used on the connection following the change, except that on the LE Coded
PHY a packet taking up to 2704 us to transmit may be sent even though the
corresponding parameter has a lower value.
 See Bluetooth spec 5.0 vol 2 [part E] 7.7.65.7</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle to be used to identify the connection with the peer device.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>MaxTxOctets</p>
</td><td><p>2</p>
</td><td><p>The maximum number of payload octets in a Link Layer packet that the
local Controller will send on this connection(connEffectiveMaxTxOctets defined in [Vol 6] Part B, Section 4.5.10).</p>
</td><td><li>0x001B ... 0x00FB</li></td></tr>
<tr><td><p>MaxTxTime</p>
</td><td><p>2</p>
</td><td><p>The maximum time that the local Controller will take to send a Link
Layer packet on this connection (connEffectiveMaxTxTime defined in[Vol 6] Part B, Section 4.5.10).</p>
</td><td><li>0x0148 ... 0x4290</li></td></tr>
<tr><td><p>MaxRxOctets</p>
</td><td><p>2</p>
</td><td><p>The maximum number of payload octets in a Link Layer packet that the
local Controller expects to receive on this connection(connEffectiveMaxRxOctets defined in [Vol 6] Part B, Section 4.5.10).</p>
</td><td><li>0x001B ... 0x00FB</li></td></tr>
<tr><td><p>MaxRxTime</p>
</td><td><p>2</p>
</td><td><p>The maximum time that the local Controller expects to take to receive a
Link Layer packet on this connection (connEffectiveMaxRxTime defined in [Vol 6] Part B, Section 4.5.10).</p>
</td><td><li>0x0148 ... 0x4290</li></td></tr>
</table><h2><a name="HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT_anchor">HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT</a></h2><h3>Description</h3><p>This event is generated when local P-256 key generation is complete. 
                                                                  See Bluetooth spec 5.0 vol 2 [part E] 7.7.65.8</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Local_P256_Public_Key</p>
</td><td><p>64</p>
</td><td><p>Local P-256 public key.</p>
</td><td></tr>
</table><h2><a name="HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT_anchor">HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT</a></h2><h3>Description</h3><p>This event indicates that LE Diffie Hellman key generation has been completed
by the Controller. See Bluetooth spec 5.0 vol 2 [part E] 7.7.65.9</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>DHKey</p>
</td><td><p>32</p>
</td><td><p>Diffie Hellman Key</p>
</td><td></tr>
</table><h2><a name="HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT_anchor">HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT</a></h2><h3>Description</h3><p>The LE Enhanced Connection Complete event indicates to both of the Hosts
forming the connection that a new connection has been created. Upon the
creation of the connection a Connection_Handle shall be assigned by the
Controller, and passed to the Host in this event. If the connection establishment
fails, this event shall be provided to the Host that had issued the
LE_Create_Connection command.
If this event is unmasked and LE Connection Complete event is unmasked,
only the LE Enhanced Connection Complete event is sent when a new
connection has been completed.
This event indicates to the Host that issued a LE_Create_Connection
command and received a Command Status event if the connection
establishment failed or was successful.
The Master_Clock_Accuracy parameter is only valid for a slave. On a master,
this parameter shall be set to 0x00. See Bluetooth spec 5.0 vol 2 [part E] 7.7.65.10</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle to be used to identify the connection with the peer device.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Role</p>
</td><td><p>1</p>
</td><td><p>Role of the local device in the connection.</p>
</td><td><li>0x00: Master</li><li>0x01: Slave</li></td></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>0x00 Public Device Address
0x01 Random Device Address
0x02 Public Identity Address (Corresponds to Resolved Private Address)
0x03 Random (Static) Identity Address (Corresponds to Resolved Private Address)</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Public Identity Address</li><li>0x03: Random (Static) Identity Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address, Random Device Address, Public Identity
Address or Random (static) Identity Address of the device to be connected.</p>
</td><td></tr>
<tr><td><p>Local_Resolvable_Private_Address</p>
</td><td><p>6</p>
</td><td><p>Resolvable Private Address being used by the local device for this connection.
This is only valid when the Own_Address_Type is set to 0x02 or 0x03. For other Own_Address_Type values,
the Controller shall return all zeros.</p>
</td><td></tr>
<tr><td><p>Peer_Resolvable_Private_Address</p>
</td><td><p>6</p>
</td><td><p>Resolvable Private Address being used by the peer device for this connection.
This is only valid for Peer_Address_Type 0x02 and 0x03. For
other Peer_Address_Type values, the Controller shall return all zeros.</p>
</td><td></tr>
<tr><td><p>Conn_Interval</p>
</td><td><p>2</p>
</td><td><p>Connection interval used on this connection.
Time = N * 1.25 msec</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Conn_Latency</p>
</td><td><p>2</p>
</td><td><p>Slave latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Supervision_Timeout</p>
</td><td><p>2</p>
</td><td><p>Supervision timeout for the LE Link.
It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2.
Time = N * 10 msec.</p>
</td><td><li>0x000A (100 ms)  ... 0x0C80 (32000 ms) </li></td></tr>
<tr><td><p>Master_Clock_Accuracy</p>
</td><td><p>1</p>
</td><td><p>Master clock accuracy. Only valid for a slave.</p>
</td><td><li>0x00: 500 ppm</li><li>0x01: 250 ppm</li><li>0x02: 150 ppm</li><li>0x03: 100 ppm</li><li>0x04: 75 ppm</li><li>0x05: 50 ppm</li><li>0x06: 30 ppm</li><li>0x07: 20 ppm</li></td></tr>
</table><h2><a name="HCI_LE_DIRECT_ADVERTISING_REPORT_EVENT_anchor">HCI_LE_DIRECT_ADVERTISING_REPORT_EVENT</a></h2><h3>Description</h3><p>The LE Direct Advertising Report event indicates that directed advertisements
have been received where the advertiser is using a resolvable private address
for the InitA field in the ADV_DIRECT_IND PDU and the
Scanning_Filter_Policy is equal to 0x02 or 0x03, see HCI_LE_Set_Scan_Parameters.
Direct_Address_Type and Direct_Addres is the address the directed
advertisements are being directed to. Address_Type and Address is the
address of the advertiser sending the directed advertisements. See Bluetooth spec 5.0 vol 2 [part E] 7.7.65.11</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Num_Reports</p>
</td><td><p>1</p>
</td><td><p>Number of responses in this event.</p>
</td><td><li>0x01</li></td></tr>
<tr><td><p>Event_Type[i]</p>
</td><td><p>1</p>
</td><td><p>Advertising type</p>
</td><td><li>0x01: Connectable directed advertising (ADV_DIRECT_IND)</li></td></tr>
<tr><td><p>Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>0x00 Public Device Address
0x01 Random Device Address
0x02 Public Identity Address (Corresponds to Resolved Private Address)
0x03 Random (Static) Identity Address (Corresponds to Resolved Private Address)</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Public Identity Address</li><li>0x03: Random (Static) Identity Address</li></td></tr>
<tr><td><p>Address[i]</p>
</td><td><p>6</p>
</td><td><p>Public Device Address, Random Device Address, Public Identity
Address or Random (static) Identity Address of the advertising device.</p>
</td><td></tr>
<tr><td><p>Direct_Address_Type[i]</p>
</td><td><p>1</p>
</td><td><p>0x01 Random Device Address</p>
</td><td><li>0x01: Random Device Address</li></td></tr>
<tr><td><p>Direct_Address[i]</p>
</td><td><p>6</p>
</td><td><p>Random Device Address</p>
</td><td></tr>
<tr><td><p>RSSI[i]</p>
</td><td><p>1</p>
</td><td><p>N Size: 1 Octet (signed integer)
Units: dBm</p>
</td><td><li>127: RSSI not available</li><li>-127 ... 20</li></td></tr>
</table><h2><a name="HCI_LE_PHY_UPDATE_COMPLETE_EVENT_anchor">HCI_LE_PHY_UPDATE_COMPLETE_EVENT</a></h2><h3>Description</h3><p>The LE PHY Update Complete Event is used to indicate that the Controller has
changed the transmitter PHY or receiver PHY in use.
If the Controller changes the transmitter PHY, the receiver PHY, or both PHYs,
this event shall be issued.
If an LE_Set_PHY command was sent and the Controller determines that
neither PHY will change as a result, it issues this event immediately.
 See See Bluetooth spec 5.0 vol 2 [part E] 7.7.65.12</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle to be used to identify the connection with the peer device.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>TX_PHY</p>
</td><td><p>1</p>
</td><td><p>Transmitter PHY in use</p>
</td><td><li>0x01: The transmitter PHY for the connection is LE 1M</li><li>0x02: The transmitter PHY for the connection is LE 2M</li><li>0x03: The transmitter PHY for the connection is LE Coded (Not Supported by STM32WB)</li></td></tr>
<tr><td><p>RX_PHY</p>
</td><td><p>1</p>
</td><td><p>Receiver PHY in use</p>
</td><td><li>0x01: The receiver PHY for the connection is LE 1M</li><li>0x02: The receiver PHY for the connection is LE 2M</li><li>0x03: The receiver PHY for the connection is LE Coded (Not Supported by STM32WB)</li></td></tr>
</table><h2><a name="ACI GAP events_anchor">ACI GAP events</a></h2><h3>ACI GAP events</h3><table width="800" border="1" class="reference">
<tr><th>Vendor specific event name</th><th>Vendor specific event Code</th></tr>
<tr><td><a href="#ACI_GAP_LIMITED_DISCOVERABLE_EVENT_anchor">ACI_GAP_LIMITED_DISCOVERABLE_EVENT</a></td><td><p>0x0400</p>
</td></tr>
<tr><td><a href="#ACI_GAP_PAIRING_COMPLETE_EVENT_anchor">ACI_GAP_PAIRING_COMPLETE_EVENT</a></td><td><p>0x0401</p>
</td></tr>
<tr><td><a href="#ACI_GAP_PASS_KEY_REQ_EVENT_anchor">ACI_GAP_PASS_KEY_REQ_EVENT</a></td><td><p>0x0402</p>
</td></tr>
<tr><td><a href="#ACI_GAP_AUTHORIZATION_REQ_EVENT_anchor">ACI_GAP_AUTHORIZATION_REQ_EVENT</a></td><td><p>0x0403</p>
</td></tr>
<tr><td><a href="#ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT_anchor">ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT</a></td><td><p>0x0404</p>
</td></tr>
<tr><td><a href="#ACI_GAP_BOND_LOST_EVENT_anchor">ACI_GAP_BOND_LOST_EVENT</a></td><td><p>0x0405</p>
</td></tr>
<tr><td><a href="#ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></td><td><p>0x0407</p>
</td></tr>
<tr><td><a href="#ACI_GAP_ADDR_NOT_RESOLVED_EVENT_anchor">ACI_GAP_ADDR_NOT_RESOLVED_EVENT</a></td><td><p>0x0408</p>
</td></tr>
<tr><td><a href="#ACI_GAP_NUMERIC_COMPARISON_VALUE_EVENT_anchor">ACI_GAP_NUMERIC_COMPARISON_VALUE_EVENT</a></td><td><p>0x0409</p>
</td></tr>
<tr><td><a href="#ACI_GAP_KEYPRESS_NOTIFICATION_EVENT_anchor">ACI_GAP_KEYPRESS_NOTIFICATION_EVENT</a></td><td><p>0x040A</p>
</td></tr>
</table><h2><a name="ACI_GAP_LIMITED_DISCOVERABLE_EVENT_anchor">ACI_GAP_LIMITED_DISCOVERABLE_EVENT</a></h2><h3>Description</h3><p>This event is generated by the controller when the limited discoverable mode ends due to
timeout. The timeout is 180 seconds.</p><h3>Event parameters</h3><p>None</p><h2><a name="ACI_GAP_PAIRING_COMPLETE_EVENT_anchor">ACI_GAP_PAIRING_COMPLETE_EVENT</a></h2><h3>Description</h3><p>This event is generated when the pairing process has completed successfully or a pairing
procedure timeout has occurred or the pairing has failed. This is to notify the application that
we have paired with a remote device so that it can take further actions or to notify that a
timeout has occurred so that the upper layer can decide to disconnect the link.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle on which the pairing procedure completed</p>
</td><td></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Pairing status</p>
</td><td></td></tr>
<tr><td><p>Reason</p>
</td><td><p>1</p>
</td><td><p>Pairing reason error code</p>
</td><td><li>0x00</li><li>0x01: PASSKEY_ENTRY_FAILED</li><li>0x02: OOB_NOT_AVAILABLE</li><li>0x03: AUTH_REQ_CANNOT_BE_MET</li><li>0x04: CONFIRM_VALUE_FAILED</li><li>0x05: PAIRING_NOT_SUPPORTED</li><li>0x06: INSUFF_ENCRYPTION_KEY_SIZE</li><li>0x07: CMD_NOT_SUPPORTED</li><li>0x08: UNSPECIFIED_REASON</li><li>0x09: VERY_EARLY_NEXT_ATTEMPT</li><li>0x0A: SM_INVALID_PARAMS</li><li>0x0B: SMP_SC_DHKEY_CHECK_FAILED</li><li>0x0C: SMP_SC_NUMCOMPARISON_FAILED</li></td></tr>
</table><h2><a name="ACI_GAP_PASS_KEY_REQ_EVENT_anchor">ACI_GAP_PASS_KEY_REQ_EVENT</a></h2><h3>Description</h3><p>This event is generated by the Security manager to the application when a passkey is
required for pairing. When this event is received, the application has to respond with the
<a href="#ACI_GAP_PASS_KEY_RESP_anchor">ACI_GAP_PASS_KEY_RESP</a> command.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the passkey has been requested.</p>
</td><td></tr>
</table><h2><a name="ACI_GAP_AUTHORIZATION_REQ_EVENT_anchor">ACI_GAP_AUTHORIZATION_REQ_EVENT</a></h2><h3>Description</h3><p>This event is generated by the Security manager to the application when the application has
set that authorization is required for reading/writing of attributes. This event will be
generated as soon as the pairing is complete. When this event is received,
<a href="#ACI_GAP_AUTHORIZATION_RESP_anchor">ACI_GAP_AUTHORIZATION_RESP</a> command should be used to respond by the application.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which authorization has been requested.</p>
</td><td></tr>
</table><h2><a name="ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT_anchor">ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT</a></h2><h3>Description</h3><p>This event is generated when the slave security request is successfully sent to the master.</p><h3>Event parameters</h3><p>None</p><h2><a name="ACI_GAP_BOND_LOST_EVENT_anchor">ACI_GAP_BOND_LOST_EVENT</a></h2><h3>Description</h3><p>This event is generated when a pairing request is issued in response to a slave security
request from a master which has previously bonded with the slave. When this event is
received, the upper layer has to issue the command <a href="#ACI_GAP_ALLOW_REBOND_anchor">ACI_GAP_ALLOW_REBOND</a> in order to
allow the slave to continue the pairing process with the master.</p><h3>Event parameters</h3><p>None</p><h2><a name="ACI_GAP_PROC_COMPLETE_EVENT_anchor">ACI_GAP_PROC_COMPLETE_EVENT</a></h2><h3>Description</h3><p>This event is sent by the GAP to the upper layers when a procedure previously started has
been terminated by the upper layer or has completed for any other reason</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Procedure_Code</p>
</td><td><p>1</p>
</td><td><p>Terminated procedure.</p>
</td><td><li>0x01: GAP_LIMITED_DISCOVERY_PROC</li><li>0x02: GAP_GENERAL_DISCOVERY_PROC</li><li>0x04: GAP_NAME_DISCOVERY_PROC</li><li>0x08: GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC</li><li>0x10: GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC</li><li>0x20: GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC</li><li>0x40: GAP_DIRECT_CONNECTION_ESTABLISHMENT_PROC</li><li>0x80: GAP_OBSERVATION_PROC</li></td></tr>
<tr><td><p>Status</p>
</td><td><p>1</p>
</td><td><p>Status error code.</p>
</td><td></td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Data in octets</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Data_Length</p>
</td><td><p>Procedure Specific Data:
- For Name Discovery Procedure: the name of the peer device if the procedure completed successfully.</p>
</td><td></tr>
</table><h2><a name="ACI_GAP_ADDR_NOT_RESOLVED_EVENT_anchor">ACI_GAP_ADDR_NOT_RESOLVED_EVENT</a></h2><h3>Description</h3><p>This event is sent only by a privacy enabled Peripheral. The event is sent to the
upper layers when the peripheral is unsuccessful in resolving the resolvable
address of the peer device after connecting to it.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle for which the private address could not be
resolved with any of the stored IRK's.</p>
</td><td></tr>
</table><h2><a name="ACI_GAP_NUMERIC_COMPARISON_VALUE_EVENT_anchor">ACI_GAP_NUMERIC_COMPARISON_VALUE_EVENT</a></h2><h3>Description</h3><p>This event is sent only during SC v.4.2 Pairing, when Numeric Comparison Association model is selected, in order to show the Numeric Value generated, and to ask for Confirmation to the User. When this event is received, the application has to respond with the
<a href="#ACI_GAP_NUMERIC_COMPARISON_RESP_anchor">ACI_GAP_NUMERIC_COMPARISON_RESP</a> command.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the underlying Pairing</p>
</td><td></tr>
<tr><td><p>Numeric_Value</p>
</td><td><p>4</p>
</td><td></td><td></tr>
</table><h2><a name="ACI_GAP_KEYPRESS_NOTIFICATION_EVENT_anchor">ACI_GAP_KEYPRESS_NOTIFICATION_EVENT</a></h2><h3>Description</h3><p>This event is sent only during SC v.4.2 Pairing, when Keypress Notifications are supported, in order to show the input type signalled by the peer device, having Keyboard only I/O capabilities. When this event is received, no action is required to the User.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the underlying Pairing</p>
</td><td></tr>
<tr><td><p>Notification_Type</p>
</td><td><p>1</p>
</td><td><p>Type of Keypress input notified/signaled by peer device (having Keyboard only I/O capabilities</p>
</td><td></tr>
</table><h2><a name="ACI GATT/ATT events_anchor">ACI GATT/ATT events</a></h2><h3>ACI GATT/ATT events</h3><table width="800" border="1" class="reference">
<tr><th>Vendor specific event name</th><th>Vendor specific event Code</th></tr>
<tr><td><a href="#ACI_GATT_ATTRIBUTE_MODIFIED_EVENT_anchor">ACI_GATT_ATTRIBUTE_MODIFIED_EVENT</a></td><td><p>0x0C01</p>
</td></tr>
<tr><td><a href="#ACI_GATT_PROC_TIMEOUT_EVENT_anchor">ACI_GATT_PROC_TIMEOUT_EVENT</a></td><td><p>0x0C02</p>
</td></tr>
<tr><td><a href="#ACI_ATT_EXCHANGE_MTU_RESP_EVENT_anchor">ACI_ATT_EXCHANGE_MTU_RESP_EVENT</a></td><td><p>0x0C03</p>
</td></tr>
<tr><td><a href="#ACI_ATT_FIND_INFO_RESP_EVENT_anchor">ACI_ATT_FIND_INFO_RESP_EVENT</a></td><td><p>0x0C04</p>
</td></tr>
<tr><td><a href="#ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT</a></td><td><p>0x0C05</p>
</td></tr>
<tr><td><a href="#ACI_ATT_READ_BY_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_TYPE_RESP_EVENT</a></td><td><p>0x0C06</p>
</td></tr>
<tr><td><a href="#ACI_ATT_READ_RESP_EVENT_anchor">ACI_ATT_READ_RESP_EVENT</a></td><td><p>0x0C07</p>
</td></tr>
<tr><td><a href="#ACI_ATT_READ_BLOB_RESP_EVENT_anchor">ACI_ATT_READ_BLOB_RESP_EVENT</a></td><td><p>0x0C08</p>
</td></tr>
<tr><td><a href="#ACI_ATT_READ_MULTIPLE_RESP_EVENT_anchor">ACI_ATT_READ_MULTIPLE_RESP_EVENT</a></td><td><p>0x0C09</p>
</td></tr>
<tr><td><a href="#ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT</a></td><td><p>0x0C0A</p>
</td></tr>
<tr><td><a href="#ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a></td><td><p>0x0C0C</p>
</td></tr>
<tr><td><a href="#ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a></td><td><p>0x0C0D</p>
</td></tr>
<tr><td><a href="#ACI_GATT_INDICATION_EVENT_anchor">ACI_GATT_INDICATION_EVENT</a></td><td><p>0x0C0E</p>
</td></tr>
<tr><td><a href="#ACI_GATT_NOTIFICATION_EVENT_anchor">ACI_GATT_NOTIFICATION_EVENT</a></td><td><p>0x0C0F</p>
</td></tr>
<tr><td><a href="#ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></td><td><p>0x0C10</p>
</td></tr>
<tr><td><a href="#ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></td><td><p>0x0C11</p>
</td></tr>
<tr><td><a href="#ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT_anchor">ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</a></td><td><p>0x0C12</p>
</td></tr>
<tr><td><a href="#ACI_GATT_WRITE_PERMIT_REQ_EVENT_anchor">ACI_GATT_WRITE_PERMIT_REQ_EVENT</a></td><td><p>0x0C13</p>
</td></tr>
<tr><td><a href="#ACI_GATT_READ_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_PERMIT_REQ_EVENT</a></td><td><p>0x0C14</p>
</td></tr>
<tr><td><a href="#ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT</a></td><td><p>0x0C15</p>
</td></tr>
<tr><td><a href="#ACI_GATT_TX_POOL_AVAILABLE_EVENT_anchor">ACI_GATT_TX_POOL_AVAILABLE_EVENT</a></td><td><p>0x0C16</p>
</td></tr>
<tr><td><a href="#ACI_GATT_SERVER_CONFIRMATION_EVENT_anchor">ACI_GATT_SERVER_CONFIRMATION_EVENT</a></td><td><p>0x0C17</p>
</td></tr>
<tr><td><a href="#ACI_GATT_PREPARE_WRITE_PERMIT_REQ_EVENT_anchor">ACI_GATT_PREPARE_WRITE_PERMIT_REQ_EVENT</a></td><td><p>0x0C18</p>
</td></tr>
<tr><td><a href="#ACI_GATT_INDICATION_EXT_EVENT_anchor">ACI_GATT_INDICATION_EXT_EVENT</a></td><td><p>0x0C1E</p>
</td></tr>
<tr><td><a href="#ACI_GATT_NOTIFICATION_EXT_EVENT_anchor">ACI_GATT_NOTIFICATION_EXT_EVENT</a></td><td><p>0x0C1F</p>
</td></tr>
</table><h2><a name="ACI_GATT_ATTRIBUTE_MODIFIED_EVENT_anchor">ACI_GATT_ATTRIBUTE_MODIFIED_EVENT</a></h2><h3>Description</h3><p>This event is generated to the application by the GATT server when a client modifies any
attribute on the server, as consequence of one of the following GATT procedures:
- write without response
- signed write without response
- write characteristic value
- write long characteristic value
- reliable write.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>The connection handle which modified the attribute.</p>
</td><td></tr>
<tr><td><p>Attr_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the attribute that was modified.</p>
</td><td></tr>
<tr><td><p>Offset</p>
</td><td><p>2</p>
</td><td><p>Bits 14-0: offset from which the write has been performed by the peer device. Bit 15 is used as flag: when set to 1 it indicates that more data are to come (fragmented event in case of long attribute data).</p>
</td><td></tr>
<tr><td><p>Attr_Data_Length</p>
</td><td><p>2</p>
</td><td><p>Length of Attr_Data in octets</p>
</td><td></tr>
<tr><td><p>Attr_Data</p>
</td><td><p>Attr_Data_Length</p>
</td><td><p>The modified value</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_PROC_TIMEOUT_EVENT_anchor">ACI_GATT_PROC_TIMEOUT_EVENT</a></h2><h3>Description</h3><p>This event is generated by the client/server to the application on a GATT timeout (30
seconds). This is a critical event that should not happen during normal operating conditions. It is an indication of either a major disruption in the communication link or a mistake in the application which does not provide a reply to GATT procedures. After this event, the GATT channel is closed and no more GATT communication can be performed. The applications is exptected to issue an <a href="#ACI_GAP_TERMINATE_anchor">ACI_GAP_TERMINATE</a> to disconnect from the peer device. It is important to leave an 100 ms blank window before sending the <a href="#ACI_GAP_TERMINATE_anchor">ACI_GAP_TERMINATE</a>, since immediately after this event, system could save important information in non volatile memory.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle on which the GATT procedure has timed out</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_EXCHANGE_MTU_RESP_EVENT_anchor">ACI_ATT_EXCHANGE_MTU_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to an Exchange MTU request. See
<a href="#ACI_GATT_EXCHANGE_CONFIG_anchor">ACI_GATT_EXCHANGE_CONFIG</a>.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Server_RX_MTU</p>
</td><td><p>2</p>
</td><td><p>Attribute server receive MTU size</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_FIND_INFO_RESP_EVENT_anchor">ACI_ATT_FIND_INFO_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to a Find Information Request. See
<a href="#ACI_ATT_FIND_INFO_REQ_anchor">ACI_ATT_FIND_INFO_REQ</a> and Find Information Response in Bluetooth Core v5.0
spec. This event is also generated in response to <a href="#ACI_GATT_DISC_ALL_CHAR_DESC_anchor">ACI_GATT_DISC_ALL_CHAR_DESC</a></p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Format</p>
</td><td><p>1</p>
</td><td><p>Format of the hanndle-uuid pairs</p>
</td><td></tr>
<tr><td><p>Event_Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Handle_UUID_Pair in octets</p>
</td><td></tr>
<tr><td><p>Handle_UUID_Pair</p>
</td><td><p>Event_Data_Length</p>
</td><td><p>A sequence of handle-uuid pairs. if format=1, each pair is:[2 octets for handle, 2 octets for UUIDs], if format=2, each pair is:[2 octets for handle, 16 octets for UUIDs]</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to a <a href="#ACI_ATT_FIND_BY_TYPE_VALUE_REQ_anchor">ACI_ATT_FIND_BY_TYPE_VALUE_REQ</a></p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Num_of_Handle_Pair</p>
</td><td><p>1</p>
</td><td><p>Number of attribute, group handle pairs</p>
</td><td></tr>
<tr><td><p>Found_Attribute_Handle[i]</p>
</td><td><p>2</p>
</td><td><p>Found Attribute handle</p>
</td><td></tr>
<tr><td><p>Group_End_Handle[i]</p>
</td><td><p>2</p>
</td><td><p>Group End handle</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_READ_BY_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_TYPE_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to a <a href="#ACI_ATT_READ_BY_TYPE_REQ_anchor">ACI_ATT_READ_BY_TYPE_REQ</a>. See
<a href="#ACI_GATT_FIND_INCLUDED_SERVICES_anchor">ACI_GATT_FIND_INCLUDED_SERVICES</a> and <a href="#ACI_GATT_DISC_ALL_CHAR_DESC_anchor">ACI_GATT_DISC_ALL_CHAR_DESC</a>.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Handle_Value_Pair_Length</p>
</td><td><p>1</p>
</td><td><p>The size of each attribute handle-value pair</p>
</td><td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Handle_Value_Pair_Data in octets</p>
</td><td></tr>
<tr><td><p>Handle_Value_Pair_Data</p>
</td><td><p>Data_Length</p>
</td><td><p>Attribute Data List as defined in Bluetooth Core v5.0 spec. A sequence of handle-value pairs: [2 octets for Attribute Handle, (Handle_Value_Pair_Length - 2 octets) for Attribute Value]</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_READ_RESP_EVENT_anchor">ACI_ATT_READ_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to a Read Request. See <a href="#ACI_GATT_READ_CHAR_VALUE_anchor">ACI_GATT_READ_CHAR_VALUE</a>.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Event_Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of following data</p>
</td><td></tr>
<tr><td><p>Attribute_Value</p>
</td><td><p>Event_Data_Length</p>
</td><td><p>The value of the attribute.</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_READ_BLOB_RESP_EVENT_anchor">ACI_ATT_READ_BLOB_RESP_EVENT</a></h2><h3>Description</h3><p>This event can be generated during a read long characteristic value procedure. See <a href="#ACI_GATT_READ_LONG_CHAR_VALUE_anchor">ACI_GATT_READ_LONG_CHAR_VALUE</a>.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Event_Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of following data</p>
</td><td></tr>
<tr><td><p>Attribute_Value</p>
</td><td><p>Event_Data_Length</p>
</td><td><p>Part of the attribute value.</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_READ_MULTIPLE_RESP_EVENT_anchor">ACI_ATT_READ_MULTIPLE_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to a Read Multiple Request.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Event_Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of following data</p>
</td><td></tr>
<tr><td><p>Set_Of_Values</p>
</td><td><p>Event_Data_Length</p>
</td><td><p>A set of two or more values.
A concatenation of attribute values for each of the attribute handles in the request in the order that they were requested.</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT_anchor">ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to a Read By Group Type Request. See
<a href="#ACI_GATT_DISC_ALL_PRIMARY_SERVICES_anchor">ACI_GATT_DISC_ALL_PRIMARY_SERVICES</a>.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attribute_Data_Length</p>
</td><td><p>1</p>
</td><td><p>The size of each attribute data</p>
</td><td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Attribute_Data_List in octets</p>
</td><td></tr>
<tr><td><p>Attribute_Data_List</p>
</td><td><p>Data_Length</p>
</td><td><p>Attribute Data List as defined in Bluetooth Core v5.0 spec. A sequence of attribute handle, end group handle, attribute value tuples: [2 octets for Attribute Handle, 2 octets End Group Handle, (Attribute_Data_Length - 4 octets) for Attribute Value]</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_PREPARE_WRITE_RESP_EVENT_anchor">ACI_ATT_PREPARE_WRITE_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to a <a href="#ACI_ATT_PREPARE_WRITE_REQ_anchor">ACI_ATT_PREPARE_WRITE_REQ</a>.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute to be written</p>
</td><td></tr>
<tr><td><p>Offset</p>
</td><td><p>2</p>
</td><td><p>The offset of the first octet to be written.</p>
</td><td></tr>
<tr><td><p>Part_Attribute_Value_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Part_Attribute_Value in octets</p>
</td><td></tr>
<tr><td><p>Part_Attribute_Value</p>
</td><td><p>Part_Attribute_Value_Length</p>
</td><td><p>The value of the attribute to be written</p>
</td><td></tr>
</table><h2><a name="ACI_ATT_EXEC_WRITE_RESP_EVENT_anchor">ACI_ATT_EXEC_WRITE_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated in response to an Execute Write Request.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
</table><h2><a name="ACI_GATT_INDICATION_EVENT_anchor">ACI_GATT_INDICATION_EVENT</a></h2><h3>Description</h3><p>This event is generated when an indication is received from the server.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute</p>
</td><td></tr>
<tr><td><p>Attribute_Value_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Attribute_Value in octets</p>
</td><td></tr>
<tr><td><p>Attribute_Value</p>
</td><td><p>Attribute_Value_Length</p>
</td><td><p>The current value of the attribute</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_NOTIFICATION_EVENT_anchor">ACI_GATT_NOTIFICATION_EVENT</a></h2><h3>Description</h3><p>This event is generated when a notification is received from the server.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute</p>
</td><td></tr>
<tr><td><p>Attribute_Value_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Attribute_Value in octets</p>
</td><td></tr>
<tr><td><p>Attribute_Value</p>
</td><td><p>Attribute_Value_Length</p>
</td><td><p>The current value of the attribute</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_PROC_COMPLETE_EVENT_anchor">ACI_GATT_PROC_COMPLETE_EVENT</a></h2><h3>Description</h3><p>This event is generated when a GATT client procedure completes either with error or
successfully.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Error_Code</p>
</td><td><p>1</p>
</td><td><p>Indicates whether the procedure completed with an error or was successful</p>
</td><td><li>0x00: Success</li><li>0x01: Unknown HCI Command</li><li>0x02: Unknown Connection Identifier</li><li>0x03: Hardware Failure</li><li>0x05: Authentication Failure</li><li>0x06: PIN or Key Missing</li><li>0x07: Memory Capacity Exceeded</li><li>0x08: Connection Timeout</li><li>0x09: Connection Limit Exceeded</li><li>0x0B: ACL Connection Already Exists</li><li>0x0C: Command Disallowed</li><li>0x0D: Connection Rejected Due To Limited Resources</li><li>0x0E: Connection Rejected Due To Security Reasons</li><li>0x0F: Connection Rejected due to Unacceptable BD_ADDR</li><li>0x10: Connection Accept Timeout Exceeded</li><li>0x11: Unsupported Feature Or Parameter Value</li><li>0x12: Invalid HCI Command Parameters</li><li>0x13: Remote User Terminated Connection</li><li>0x14: Remote Device Terminated Connection due to Low Resources</li><li>0x15: Remote Device Terminated Connection due to Power Off</li><li>0x16: Connection Terminated By Local Host</li><li>0x17: Repeated Attempts</li><li>0x18: Pairing Not Allowed</li><li>0x19: Unknown LMP PDU</li><li>0x1A: Unsupported Remote Feature / Unsupported LMP Feature</li><li>0x1E: Invalid LMP Parameters</li><li>0x1F: Unspecified Error</li><li>0x20: Unsupported LMP Parameter Value</li><li>0x21: Role Change Not Allowed</li><li>0x22: LMP Response Timeout / LL Response Timeout</li><li>0x23: LMP Error Transaction Collision</li><li>0x24: LMP PDU Not Allowed</li><li>0x25: Encryption Mode Not Acceptable</li><li>0x26: Link Key cannot be Changed</li><li>0x28: Instant Passed</li><li>0x29: Pairing With Unit Key Not Supported</li><li>0x2A: Different Transaction Collision</li><li>0x2E: Channel Assessment Not Supported</li><li>0x2F: Insufficient Security</li><li>0x30: Parameter Out Of Mandatory Range</li><li>0x32: Role Switch Pending</li><li>0x34: Reserved Slot Violation</li><li>0x35: Role Switch Failed</li><li>0x37: Secure Simple Pairing Not Supported by Host</li><li>0x38: Host Busy - Pairing</li><li>0x39: Connection Rejected due to No Suitable Channel Found</li><li>0x3A: Controller Busy</li><li>0x3B: Unacceptable Connection Interval</li><li>0x3C: Directed Advertising Timeout</li><li>0x3D: Connection Terminated Due to MIC Failure</li><li>0x3E: Connection Failed to be Established</li><li>0x41: Failed</li><li>0x42: Invalid parameters</li><li>0x43: Busy</li><li>0x44: Invalid length</li><li>0x45: Pending</li><li>0x46: Not allowed</li><li>0x47: GATT error</li><li>0x48: Address not resolved</li><li>0x50: Invalid CID</li><li>0x5A: CSRK not found</li><li>0x5B: IRK not found</li><li>0x5C: Device not found in DB</li><li>0x5D: Security DB full</li><li>0x5E: Device not bonded</li><li>0x5F: Device in blacklist</li><li>0x60: Invalid handle</li><li>0x61: Invalid parameter</li><li>0x62: Out of handles</li><li>0x63: Invalid operation</li><li>0x64: Insufficient resources</li><li>0x65: Insufficient encryption key size</li><li>0x66: Characteristic already exist</li><li>0x82: No valid slot</li><li>0x83: Short window</li><li>0x84: New interval failed</li><li>0x85: Too large interval</li><li>0x86: Slot length failed</li></td></tr>
</table><h2><a name="ACI_GATT_ERROR_RESP_EVENT_anchor">ACI_GATT_ERROR_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated when an Error Response is received from the server. The error
response can be given by the server at the end of one of the GATT discovery procedures.
This does not mean that the procedure ended with an error, but this error event is part of the
procedure itself.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Req_Opcode</p>
</td><td><p>1</p>
</td><td><p>The request that generated this error response</p>
</td><td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The attribute handle that generated this error response</p>
</td><td></tr>
<tr><td><p>Error_Code</p>
</td><td><p>1</p>
</td><td><p>The reason why the request has generated an error response (ATT error codes)</p>
</td><td><li>0x01: Invalid handle</li><li>0x02: Read not permitted</li><li>0x03: Write not permitted</li><li>0x04: Invalid PDU</li><li>0x05: Insufficient authentication</li><li>0x06: Request not supported</li><li>0x07: Invalid offset</li><li>0x08: Insufficient authorization</li><li>0x09: Prepare queue full</li><li>0x0A: Attribute not found</li><li>0x0B: Attribute not long</li><li>0x0C: Insufficient encryption key size</li><li>0x0D: Invalid attribute value length</li><li>0x0E: Unlikely error</li><li>0x0F: Insufficient encryption</li><li>0x10: Unsupported group type</li><li>0x11: Insufficient resources</li></td></tr>
</table><h2><a name="ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT_anchor">ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT</a></h2><h3>Description</h3><p>This event can be generated during a "Discover Characteristics By UUID" procedure or a
"Read using Characteristic UUID" procedure.
The attribute value will be a service declaration as defined in Bluetooth Core v5.0.spec
(vol.3, Part G, ch. 3.3.1), when a "Discover Characteristics By UUID" has been started. It will
be the value of the Characteristic if a* "Read using Characteristic UUID" has been
performed.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute</p>
</td><td></tr>
<tr><td><p>Attribute_Value_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Attribute_Value in octets</p>
</td><td></tr>
<tr><td><p>Attribute_Value</p>
</td><td><p>Attribute_Value_Length</p>
</td><td><dl class="docutils">
<dt>The attribute value will be a service declaration as defined in Bluetooth Core v5.0 spec</dt>
<dd>(vol.3, Part G, ch. 3.3.1), when a &quot;Discover Characteristics By UUID&quot; has been started.
It will be the value of the Characteristic if a &quot;Read using Characteristic UUID&quot; has been performed.</dd>
</dl>
</td><td></tr>
</table><h2><a name="ACI_GATT_WRITE_PERMIT_REQ_EVENT_anchor">ACI_GATT_WRITE_PERMIT_REQ_EVENT</a></h2><h3>Description</h3><p>This event is given to the application when a write request, write command or signed write
command is received by the server from the client. This event will be given to the application
only if the event bit for this event generation is set when the characteristic was added.
When this event is received, the application has to check whether the value being requested
for write can be allowed to be written and respond with the command <a href="#ACI_GATT_WRITE_RESP_anchor">ACI_GATT_WRITE_RESP</a>.
The details of the parameters of the command can be found. Based on the response from
the application, the attribute value will be modified by the stack. If the write is rejected by the
application, then the value of the attribute will not be modified. In case of a write REQ, an
error response will be sent to the client, with the error code as specified by the application.
In case of write/signed write commands, no response is sent to the client but the attribute is
not modified.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection on which there was the request to write the attribute</p>
</td><td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute</p>
</td><td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Data field</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Data_Length</p>
</td><td><p>The data that the client has requested to write</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_READ_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_PERMIT_REQ_EVENT</a></h2><h3>Description</h3><p>This event is given to the application when a read request or read blob request is received
by the server from the client. This event will be given to the application only if the event bit
for this event generation is set when the characteristic was added.
On receiving this event, the application can update the value of the handle if it desires and
when done, it has to send the <a href="#ACI_GATT_ALLOW_READ_anchor">ACI_GATT_ALLOW_READ</a> command to indicate to the stack that it
can send the response to the client.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute</p>
</td><td></tr>
<tr><td><p>Offset</p>
</td><td><p>2</p>
</td><td><p>Contains the offset from which the read has been requested</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT_anchor">ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT</a></h2><h3>Description</h3><p>This event is given to the application when a read multiple request or read by type request is
received by the server from the client. This event will be given to the application only if the
event bit for this event generation is set when the characteristic was added.
On receiving this event, the application can update the values of the handles if it desires and
when done, it has to send the <a href="#ACI_GATT_ALLOW_READ_anchor">ACI_GATT_ALLOW_READ</a> command to indicate to the stack that it
can send the response to the client.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection which requested to read the attribute</p>
</td><td></tr>
<tr><td><p>Number_of_Handles</p>
</td><td><p>1</p>
</td><td></td><td></tr>
<tr><td><p>Handle[i]</p>
</td><td><p>2</p>
</td><td></td><td></tr>
</table><h2><a name="ACI_GATT_TX_POOL_AVAILABLE_EVENT_anchor">ACI_GATT_TX_POOL_AVAILABLE_EVENT</a></h2><h3>Description</h3><p>Each time BLE FW stack raises the error code
BLE_STATUS_INSUFFICIENT_RESOURCES (0x64), the
<a href="#ACI_GATT_TX_POOL_AVAILABLE_EVENT_anchor">ACI_GATT_TX_POOL_AVAILABLE_EVENT</a> event is generated as soon as there are at least two
buffers available for notifications or write commands.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the request</p>
</td><td></tr>
<tr><td><p>Available_Buffers</p>
</td><td><p>2</p>
</td><td><p>Number of buffers available</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_SERVER_CONFIRMATION_EVENT_anchor">ACI_GATT_SERVER_CONFIRMATION_EVENT</a></h2><h3>Description</h3><p>This event is generated when the client has sent the confirmation to a previously sent indication</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the event</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_PREPARE_WRITE_PERMIT_REQ_EVENT_anchor">ACI_GATT_PREPARE_WRITE_PERMIT_REQ_EVENT</a></h2><h3>Description</h3><p>This event is given to the application when a prepare write request
is received by the server from the client. This event will be given to the application
only if the event bit for this event generation is set when the characteristic was added.
When this event is received, the application has to check whether the value being requested
for write can be allowed to be written and respond with the command <a href="#ACI_GATT_WRITE_RESP_anchor">ACI_GATT_WRITE_RESP</a>.
Based on the response from the application, the attribute value will be modified by the stack.
If the write is rejected by the application, then the value of the attribute will not be modified
and an error response will be sent to the client, with the error code as specified by the application.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection on which there was the request to write the attribute</p>
</td><td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute</p>
</td><td></tr>
<tr><td><p>Offset</p>
</td><td><p>2</p>
</td><td><p>The offset from which the prepare write has been requested</p>
</td><td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Data field</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Data_Length</p>
</td><td><p>The data that the client has requested to write</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_INDICATION_EXT_EVENT_anchor">ACI_GATT_INDICATION_EXT_EVENT</a></h2><h3>Description</h3><p>When it is enabled with ACI_GATT_SET_EVENT_MASK and when an indication is received from the server, this event is generated instead of ACI_GATT_INDICATION_EVENT.
This event should be used instead of ACI_GATT_INDICATION_EVENT when ATT_MTU &gt; (BLE_EVT_MAX_PARAM_LEN - 4)
i.e. ATT_MTU &gt; 251 for BLE_EVT_MAX_PARAM_LEN default value.
</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute</p>
</td><td></tr>
<tr><td><p>Offset</p>
</td><td><p>2</p>
</td><td><p>Bits 14-0: offset in octets from which Attribute_Value data starts. Bit 15 is used as flag: when set to 1 it indicates that more data are to come (fragmented event in case of long attribute data).</p>
</td><td></tr>
<tr><td><p>Attribute_Value_Length</p>
</td><td><p>2</p>
</td><td><p>Length of Attribute_Value in octets</p>
</td><td></tr>
<tr><td><p>Attribute_Value</p>
</td><td><p>Attribute_Value_Length</p>
</td><td><p>The current value of the attribute</p>
</td><td></tr>
</table><h2><a name="ACI_GATT_NOTIFICATION_EXT_EVENT_anchor">ACI_GATT_NOTIFICATION_EXT_EVENT</a></h2><h3>Description</h3><p>When it is enabled with ACI_GATT_SET_EVENT_MASK and when a notification is received from the server, this event is generated instead of ACI_GATT_NOTIFICATION_EVENT.
This event should be used instead of ACI_GATT_NOTIFICATION_EVENT when ATT_MTU &gt; (BLE_EVT_MAX_PARAM_LEN - 4)
i.e. ATT_MTU &gt; 251 for BLE_EVT_MAX_PARAM_LEN default value.
</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle related to the response.</p>
</td><td><li>0x0000 ... 0x0EFF</li></td></tr>
<tr><td><p>Attribute_Handle</p>
</td><td><p>2</p>
</td><td><p>The handle of the attribute</p>
</td><td></tr>
<tr><td><p>Offset</p>
</td><td><p>2</p>
</td><td><p>Bits 14-0: offset in octets from which Attribute_Value data starts. Bit 15 is used as flag: when set to 1 it indicates that more data are to come (fragmented event in case of long attribute data).</p>
</td><td></tr>
<tr><td><p>Attribute_Value_Length</p>
</td><td><p>2</p>
</td><td><p>Length of Attribute_Value in octets</p>
</td><td></tr>
<tr><td><p>Attribute_Value</p>
</td><td><p>Attribute_Value_Length</p>
</td><td><p>The current value of the attribute</p>
</td><td></tr>
</table><h2><a name="ACI L2CAP events_anchor">ACI L2CAP events</a></h2><h3>ACI L2CAP events</h3><table width="800" border="1" class="reference">
<tr><th>Vendor specific event name</th><th>Vendor specific event Code</th></tr>
<tr><td><a href="#ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT_anchor">ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT</a></td><td><p>0x0800</p>
</td></tr>
<tr><td><a href="#ACI_L2CAP_PROC_TIMEOUT_EVENT_anchor">ACI_L2CAP_PROC_TIMEOUT_EVENT</a></td><td><p>0x0801</p>
</td></tr>
<tr><td><a href="#ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT_anchor">ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT</a></td><td><p>0x0802</p>
</td></tr>
<tr><td><a href="#ACI_L2CAP_COMMAND_REJECT_EVENT_anchor">ACI_L2CAP_COMMAND_REJECT_EVENT</a></td><td><p>0x080A</p>
</td></tr>
</table><h2><a name="ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT_anchor">ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT</a></h2><h3>Description</h3><p>This event is generated when the master responds to the connection update request packet
with a connection update response packet.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle referring to the COS Channel where the Disconnection has been received.</p>
</td><td></tr>
<tr><td><p>Result</p>
</td><td><p>2</p>
</td><td></td><td></tr>
</table><h2><a name="ACI_L2CAP_PROC_TIMEOUT_EVENT_anchor">ACI_L2CAP_PROC_TIMEOUT_EVENT</a></h2><h3>Description</h3><p>This event is generated when the master does not respond to the connection update
request packet with a connection update response packet or a command reject packet
within 30 seconds.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection related to this L2CAP procedure.</p>
</td><td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of following data</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Data_Length</p>
</td><td></td><td></tr>
</table><h2><a name="ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT_anchor">ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT</a></h2><h3>Description</h3><p>The event is given by the L2CAP layer when a connection update request is received from
the slave. The upper layer which receives this event has to respond by sending a
<a href="#ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP_anchor">ACI_L2CAP_CONNECTION_PARAMETER_UPDATE_RESP</a> command.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Handle of the connection related to this L2CAP procedure.</p>
</td><td></tr>
<tr><td><p>Identifier</p>
</td><td><p>1</p>
</td><td><p>This is the identifier which associate the request to the response.</p>
</td><td></tr>
<tr><td><p>L2CAP_Length</p>
</td><td><p>2</p>
</td><td><p>Length of the L2CAP connection update request.</p>
</td><td></tr>
<tr><td><p>Interval_Min</p>
</td><td><p>2</p>
</td><td><p>Minimum value for the connection event interval. This shall be less
than or equal to Conn_Interval_Max.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Interval_Max</p>
</td><td><p>2</p>
</td><td><p>Maximum value for the connection event interval. This shall be
greater than or equal to Conn_Interval_Min.
Time = N * 1.25 msec.</p>
</td><td><li>0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) </li></td></tr>
<tr><td><p>Slave_Latency</p>
</td><td><p>2</p>
</td><td><p>Slave latency for the connection in number of connection events.</p>
</td><td><li>0x0000 ... 0x01F3</li></td></tr>
<tr><td><p>Timeout_Multiplier</p>
</td><td><p>2</p>
</td><td><p>Defines connection timeout parameter in the following manner: Timeout Multiplier * 10ms.</p>
</td><td></tr>
</table><h2><a name="ACI_L2CAP_COMMAND_REJECT_EVENT_anchor">ACI_L2CAP_COMMAND_REJECT_EVENT</a></h2><h3>Description</h3><p>This event is generated when the master responds to the connection update request packet
with a command reject packet.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Connection_Handle</p>
</td><td><p>2</p>
</td><td><p>Connection handle referring to the COS Channel where the Disconnection has been received.</p>
</td><td></tr>
<tr><td><p>Identifier</p>
</td><td><p>1</p>
</td><td><p>This is the identifier which associate the request to the response.</p>
</td><td></tr>
<tr><td><p>Reason</p>
</td><td><p>2</p>
</td><td><p>Reason</p>
</td><td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of following data</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Data_Length</p>
</td><td><p>Data field associated with Reason</p>
</td><td></tr>
</table><h2><a name="ACI HAL events_anchor">ACI HAL events</a></h2><h3>ACI HAL events</h3><table width="800" border="1" class="reference">
<tr><th>Vendor specific event name</th><th>Vendor specific event Code</th></tr>
<tr><td><a href="#ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT_anchor">ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT</a></td><td><p>0x0004</p>
</td></tr>
<tr><td><a href="#ACI_HAL_SCAN_REQ_REPORT_EVENT_anchor">ACI_HAL_SCAN_REQ_REPORT_EVENT</a></td><td><p>0x0005</p>
</td></tr>
<tr><td><a href="#ACI_HAL_FW_ERROR_EVENT_anchor">ACI_HAL_FW_ERROR_EVENT</a></td><td><p>0x0006</p>
</td></tr>
</table><h2><a name="ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT_anchor">ACI_HAL_END_OF_RADIO_ACTIVITY_EVENT</a></h2><h3>Description</h3><p>'This event is generated when the device completes a radio activity and provide information when a new radio acitivity will be performed.
Informtation provided includes type of radio activity and absolute time in system ticks when a new radio acitivity is schedule, if any. Application can use this information to schedule user activities synchronous to selected radio activitities. A command <a href="#ACI_HAL_SET_RADIO_ACTIVITY_MASK_anchor">ACI_HAL_SET_RADIO_ACTIVITY_MASK</a> is provided to enable radio activity events of user interests, by default no events are enabled.
User should take into account that enablinng radio events in application with intense radio activity could lead to a fairly high rate of events generated.
Application use cases includes synchronizing notification with connection interval, switiching antenna at the end of advertising or performing flash erase operation while radio is idle.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>Last_State</p>
</td><td><p>1</p>
</td><td><p>Completed radio events</p>
</td><td><li>0x00: Idle</li><li>0x01: Advertising</li><li>0x02: Connection event slave</li><li>0x03: Scanning</li><li>0x04: Connection request</li><li>0x05: Connection event slave</li><li>0x06: TX test mode</li><li>0x07: RX test mode</li></td></tr>
<tr><td><p>Next_State</p>
</td><td><p>1</p>
</td><td><p>Incoming radio events</p>
</td><td><li>0x00: Idle</li><li>0x01: Advertising</li><li>0x02: Connection event slave</li><li>0x03: Scanning</li><li>0x04: Connection request</li><li>0x05: Connection event slave</li><li>0x06: TX test mode</li><li>0x07: RX test mode</li></td></tr>
<tr><td><p>Next_State_SysTime</p>
</td><td><p>4</p>
</td><td><p>32bit absolute current time expressed in internal time units.</p>
</td><td></tr>
</table><h2><a name="ACI_HAL_SCAN_REQ_REPORT_EVENT_anchor">ACI_HAL_SCAN_REQ_REPORT_EVENT</a></h2><h3>Description</h3><p>This event is reported to the application after a scan request is received and a scan reponse
is scheduled to be transmitted.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>RSSI</p>
</td><td><p>1</p>
</td><td><p>N Size: 1 Octet (signed integer)
Units: dBm</p>
</td><td><li>127: RSSI not available</li><li>-127 ... 20</li></td></tr>
<tr><td><p>Peer_Address_Type</p>
</td><td><p>1</p>
</td><td><p>0x00 Public Device Address
0x01 Random Device Address
0x02 Public Identity Address (Corresponds to Resolved Private Address)
0x03 Random (Static) Identity Address (Corresponds to Resolved Private Address)</p>
</td><td><li>0x00: Public Device Address</li><li>0x01: Random Device Address</li><li>0x02: Public Identity Address</li><li>0x03: Random (Static) Identity Address</li></td></tr>
<tr><td><p>Peer_Address</p>
</td><td><p>6</p>
</td><td><p>Public Device Address or Random Device Address of the peer device</p>
</td><td></tr>
</table><h2><a name="ACI_HAL_FW_ERROR_EVENT_anchor">ACI_HAL_FW_ERROR_EVENT</a></h2><h3>Description</h3><p>This event is generated to report firmware error informations.</p><h3>Event parameters</h3><table width="800" border="1" class="reference">
<tr><th>Parameter</th><th>Size</th><th>Description</th><th>Possible values</th></tr>
<tr><td><p>FW_Error_Type</p>
</td><td><p>1</p>
</td><td><p>FW Error type</p>
</td><td><li>0x01: L2CAP recombination failure</li><li>0x02: GATT UNEXPECTED RESPONSE ERROR</li><li>0x03: NVM LEVEL WARNING</li></td></tr>
<tr><td><p>Data_Length</p>
</td><td><p>1</p>
</td><td><p>Length of Data in octets</p>
</td><td></tr>
<tr><td><p>Data</p>
</td><td><p>Data_Length</p>
</td><td><p>The error event info</p>
</td><td></tr>
</table><h1><a name="Status error codes_anchor">Status error codes</a></h1><p>Status error codes are used for the return status of all commands. Only the codes from 0 to 0x3E are used for HCI commands (see Core Specification v5.0, Vol. 2, part D), while more codes are defined for ACI commands (see table below).</p><h2></h2><table width="800" border="1" class="reference">
<tr><th>Status error code</th><th>Description</th></tr>
<tr><td><p>0x00</p>
</td><td><p>Success</p>
</td></tr>
<tr><td><p>0x01</p>
</td><td><p>Unknown HCI Command</p>
</td></tr>
<tr><td><p>0x02</p>
</td><td><p>Unknown Connection Identifier</p>
</td></tr>
<tr><td><p>0x03</p>
</td><td><p>Hardware Failure</p>
</td></tr>
<tr><td><p>0x05</p>
</td><td><p>Authentication Failure</p>
</td></tr>
<tr><td><p>0x06</p>
</td><td><p>PIN or Key Missing</p>
</td></tr>
<tr><td><p>0x07</p>
</td><td><p>Memory Capacity Exceeded</p>
</td></tr>
<tr><td><p>0x08</p>
</td><td><p>Connection Timeout</p>
</td></tr>
<tr><td><p>0x09</p>
</td><td><p>Connection Limit Exceeded</p>
</td></tr>
<tr><td><p>0x0B</p>
</td><td><p>ACL Connection Already Exists</p>
</td></tr>
<tr><td><p>0x0C</p>
</td><td><p>Command Disallowed</p>
</td></tr>
<tr><td><p>0x0D</p>
</td><td><p>Connection Rejected Due To Limited Resources</p>
</td></tr>
<tr><td><p>0x0E</p>
</td><td><p>Connection Rejected Due To Security Reasons</p>
</td></tr>
<tr><td><p>0x0F</p>
</td><td><p>Connection Rejected due to Unacceptable BD_ADDR</p>
</td></tr>
<tr><td><p>0x10</p>
</td><td><p>Connection Accept Timeout Exceeded</p>
</td></tr>
<tr><td><p>0x11</p>
</td><td><p>Unsupported Feature Or Parameter Value</p>
</td></tr>
<tr><td><p>0x12</p>
</td><td><p>Invalid HCI Command Parameters</p>
</td></tr>
<tr><td><p>0x13</p>
</td><td><p>Remote User Terminated Connection</p>
</td></tr>
<tr><td><p>0x14</p>
</td><td><p>Remote Device Terminated Connection due to Low Resources</p>
</td></tr>
<tr><td><p>0x15</p>
</td><td><p>Remote Device Terminated Connection due to Power Off</p>
</td></tr>
<tr><td><p>0x16</p>
</td><td><p>Connection Terminated By Local Host</p>
</td></tr>
<tr><td><p>0x17</p>
</td><td><p>Repeated Attempts</p>
</td></tr>
<tr><td><p>0x18</p>
</td><td><p>Pairing Not Allowed</p>
</td></tr>
<tr><td><p>0x19</p>
</td><td><p>Unknown LMP PDU</p>
</td></tr>
<tr><td><p>0x1A</p>
</td><td><p>Unsupported Remote Feature / Unsupported LMP Feature</p>
</td></tr>
<tr><td><p>0x1E</p>
</td><td><p>Invalid LMP Parameters</p>
</td></tr>
<tr><td><p>0x1F</p>
</td><td><p>Unspecified Error</p>
</td></tr>
<tr><td><p>0x20</p>
</td><td><p>Unsupported LMP Parameter Value</p>
</td></tr>
<tr><td><p>0x21</p>
</td><td><p>Role Change Not Allowed</p>
</td></tr>
<tr><td><p>0x22</p>
</td><td><p>LMP Response Timeout / LL Response Timeout</p>
</td></tr>
<tr><td><p>0x23</p>
</td><td><p>LMP Error Transaction Collision</p>
</td></tr>
<tr><td><p>0x24</p>
</td><td><p>LMP PDU Not Allowed</p>
</td></tr>
<tr><td><p>0x25</p>
</td><td><p>Encryption Mode Not Acceptable</p>
</td></tr>
<tr><td><p>0x26</p>
</td><td><p>Link Key cannot be Changed</p>
</td></tr>
<tr><td><p>0x28</p>
</td><td><p>Instant Passed</p>
</td></tr>
<tr><td><p>0x29</p>
</td><td><p>Pairing With Unit Key Not Supported</p>
</td></tr>
<tr><td><p>0x2A</p>
</td><td><p>Different Transaction Collision</p>
</td></tr>
<tr><td><p>0x2E</p>
</td><td><p>Channel Assessment Not Supported</p>
</td></tr>
<tr><td><p>0x2F</p>
</td><td><p>Insufficient Security</p>
</td></tr>
<tr><td><p>0x30</p>
</td><td><p>Parameter Out Of Mandatory Range</p>
</td></tr>
<tr><td><p>0x32</p>
</td><td><p>Role Switch Pending</p>
</td></tr>
<tr><td><p>0x34</p>
</td><td><p>Reserved Slot Violation</p>
</td></tr>
<tr><td><p>0x35</p>
</td><td><p>Role Switch Failed</p>
</td></tr>
<tr><td><p>0x37</p>
</td><td><p>Secure Simple Pairing Not Supported by Host</p>
</td></tr>
<tr><td><p>0x38</p>
</td><td><p>Host Busy - Pairing</p>
</td></tr>
<tr><td><p>0x39</p>
</td><td><p>Connection Rejected due to No Suitable Channel Found</p>
</td></tr>
<tr><td><p>0x3A</p>
</td><td><p>Controller Busy</p>
</td></tr>
<tr><td><p>0x3B</p>
</td><td><p>Unacceptable Connection Interval</p>
</td></tr>
<tr><td><p>0x3C</p>
</td><td><p>Directed Advertising Timeout</p>
</td></tr>
<tr><td><p>0x3D</p>
</td><td><p>Connection Terminated Due to MIC Failure</p>
</td></tr>
<tr><td><p>0x3E</p>
</td><td><p>Connection Failed to be Established</p>
</td></tr>
<tr><td><p>0x41</p>
</td><td><p>Failed</p>
</td></tr>
<tr><td><p>0x42</p>
</td><td><p>Invalid parameters</p>
</td></tr>
<tr><td><p>0x43</p>
</td><td><p>Busy</p>
</td></tr>
<tr><td><p>0x44</p>
</td><td><p>Invalid length</p>
</td></tr>
<tr><td><p>0x45</p>
</td><td><p>Pending</p>
</td></tr>
<tr><td><p>0x46</p>
</td><td><p>Not allowed</p>
</td></tr>
<tr><td><p>0x47</p>
</td><td><p>GATT error</p>
</td></tr>
<tr><td><p>0x48</p>
</td><td><p>Address not resolved</p>
</td></tr>
<tr><td><p>0x50</p>
</td><td><p>Invalid CID</p>
</td></tr>
<tr><td><p>0x5A</p>
</td><td><p>CSRK not found</p>
</td></tr>
<tr><td><p>0x5B</p>
</td><td><p>IRK not found</p>
</td></tr>
<tr><td><p>0x5C</p>
</td><td><p>Device not found in DB</p>
</td></tr>
<tr><td><p>0x5D</p>
</td><td><p>Security DB full</p>
</td></tr>
<tr><td><p>0x5E</p>
</td><td><p>Device not bonded</p>
</td></tr>
<tr><td><p>0x5F</p>
</td><td><p>Device in blacklist</p>
</td></tr>
<tr><td><p>0x60</p>
</td><td><p>Invalid handle</p>
</td></tr>
<tr><td><p>0x61</p>
</td><td><p>Invalid parameter</p>
</td></tr>
<tr><td><p>0x62</p>
</td><td><p>Out of handles</p>
</td></tr>
<tr><td><p>0x63</p>
</td><td><p>Invalid operation</p>
</td></tr>
<tr><td><p>0x64</p>
</td><td><p>Insufficient resources</p>
</td></tr>
<tr><td><p>0x65</p>
</td><td><p>Insufficient encryption key size</p>
</td></tr>
<tr><td><p>0x66</p>
</td><td><p>Characteristic already exist</p>
</td></tr>
<tr><td><p>0x82</p>
</td><td><p>No valid slot</p>
</td></tr>
<tr><td><p>0x83</p>
</td><td><p>Short window</p>
</td></tr>
<tr><td><p>0x84</p>
</td><td><p>New interval failed</p>
</td></tr>
<tr><td><p>0x85</p>
</td><td><p>Too large interval</p>
</td></tr>
<tr><td><p>0x86</p>
</td><td><p>Slot length failed</p>
</td></tr>
</table></font></body></html>