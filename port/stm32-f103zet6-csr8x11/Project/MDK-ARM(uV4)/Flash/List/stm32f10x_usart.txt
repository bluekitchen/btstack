; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\stm32f10x_usart.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\stm32f10x_usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\Middleware\blue_angel\inc -I..\..\Middleware\bt_callback_manager -I..\..\Middleware\blue_angel\btif -I..\..\Middleware\blue_angel\common -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\blue_angel\src\common -I..\..\Middleware\blue_angel\src\inc -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\blue_angel\platform\rtos -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\ut_manager\Cunit\Headers -I..\..\Middleware\ut_manager\Cunit\interface -I..\..\Middleware\blue_angel\platform\test -I..\..\Middleware\blue_angel\driver -I..\..\Middleware\blue_angel\src\core\hci -I..\..\User\bt\inc -I..\..\Middleware\bt_callback_manager -I..\..\Middleware\at_command -I..\..\Middleware\blue_angel\src\core\gap -I..\..\Middleware\blue_angel\src\core\l2cap -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=522 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DNDEBUG --omf_browse=.\flash\obj\stm32f10x_usart.crf ..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_usart.c]
                          THUMB

                          AREA ||i.USART_ClearFlag||, CODE, READONLY, ALIGN=2

                  USART_ClearFlag PROC
;;;928      */
;;;929    void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;930    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;931      /* Check the parameters */
;;;932      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  481b              LDR      r0,|L1.116|
000008  4284              CMP      r4,r0
00000a  d00b              BEQ      |L1.36|
00000c  481a              LDR      r0,|L1.120|
00000e  4284              CMP      r4,r0
000010  d008              BEQ      |L1.36|
000012  481a              LDR      r0,|L1.124|
000014  4284              CMP      r4,r0
000016  d005              BEQ      |L1.36|
000018  4819              LDR      r0,|L1.128|
00001a  4284              CMP      r4,r0
00001c  d002              BEQ      |L1.36|
00001e  4819              LDR      r0,|L1.132|
000020  4284              CMP      r4,r0
000022  d100              BNE      |L1.38|
                  |L1.36|
000024  e004              B        |L1.48|
                  |L1.38|
000026  f44f7169          MOV      r1,#0x3a4
00002a  4817              LDR      r0,|L1.136|
00002c  f7fffffe          BL       assert_failed
                  |L1.48|
;;;933      assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
000030  f64f409f          MOV      r0,#0xfc9f
000034  4028              ANDS     r0,r0,r5
000036  b908              CBNZ     r0,|L1.60|
000038  b105              CBZ      r5,|L1.60|
00003a  e004              B        |L1.70|
                  |L1.60|
00003c  f24031a5          MOV      r1,#0x3a5
000040  4811              LDR      r0,|L1.136|
000042  f7fffffe          BL       assert_failed
                  |L1.70|
;;;934      /* The CTS flag is not available for UART4 and UART5 */
;;;935      if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
000046  f4057000          AND      r0,r5,#0x200
00004a  f5b07f00          CMP      r0,#0x200
00004e  d10e              BNE      |L1.110|
;;;936      {
;;;937        assert_param(IS_USART_123_PERIPH(USARTx));
000050  4808              LDR      r0,|L1.116|
000052  4284              CMP      r4,r0
000054  d005              BEQ      |L1.98|
000056  4808              LDR      r0,|L1.120|
000058  4284              CMP      r4,r0
00005a  d002              BEQ      |L1.98|
00005c  4807              LDR      r0,|L1.124|
00005e  4284              CMP      r4,r0
000060  d100              BNE      |L1.100|
                  |L1.98|
000062  e004              B        |L1.110|
                  |L1.100|
000064  f24031a9          MOV      r1,#0x3a9
000068  4807              LDR      r0,|L1.136|
00006a  f7fffffe          BL       assert_failed
                  |L1.110|
;;;938      } 
;;;939       
;;;940      USARTx->SR = (uint16_t)~USART_FLAG;
00006e  43e8              MVNS     r0,r5
000070  8020              STRH     r0,[r4,#0]
;;;941    }
000072  bd70              POP      {r4-r6,pc}
;;;942    
                          ENDP

                  |L1.116|
                          DCD      0x40013800
                  |L1.120|
                          DCD      0x40004400
                  |L1.124|
                          DCD      0x40004800
                  |L1.128|
                          DCD      0x40004c00
                  |L1.132|
                          DCD      0x40005000
                  |L1.136|
                          DCD      ||.conststring||

                          AREA ||i.USART_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  USART_ClearITPendingBit PROC
;;;1036     */
;;;1037   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1038   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1039     uint16_t bitpos = 0x00, itmask = 0x00;
000008  2600              MOVS     r6,#0
00000a  2700              MOVS     r7,#0
;;;1040     /* Check the parameters */
;;;1041     assert_param(IS_USART_ALL_PERIPH(USARTx));
00000c  4822              LDR      r0,|L2.152|
00000e  4284              CMP      r4,r0
000010  d00b              BEQ      |L2.42|
000012  4822              LDR      r0,|L2.156|
000014  4284              CMP      r4,r0
000016  d008              BEQ      |L2.42|
000018  4821              LDR      r0,|L2.160|
00001a  4284              CMP      r4,r0
00001c  d005              BEQ      |L2.42|
00001e  4821              LDR      r0,|L2.164|
000020  4284              CMP      r4,r0
000022  d002              BEQ      |L2.42|
000024  4820              LDR      r0,|L2.168|
000026  4284              CMP      r4,r0
000028  d100              BNE      |L2.44|
                  |L2.42|
00002a  e004              B        |L2.54|
                  |L2.44|
00002c  f2404111          MOV      r1,#0x411
000030  481e              LDR      r0,|L2.172|
000032  f7fffffe          BL       assert_failed
                  |L2.54|
;;;1042     assert_param(IS_USART_CLEAR_IT(USART_IT));
000036  f2406026          MOV      r0,#0x626
00003a  4285              CMP      r5,r0
00003c  d00b              BEQ      |L2.86|
00003e  f2405025          MOV      r0,#0x525
000042  4285              CMP      r5,r0
000044  d007              BEQ      |L2.86|
000046  f6400046          MOV      r0,#0x846
00004a  4285              CMP      r5,r0
00004c  d003              BEQ      |L2.86|
00004e  f640106a          MOV      r0,#0x96a
000052  4285              CMP      r5,r0
000054  d100              BNE      |L2.88|
                  |L2.86|
000056  e004              B        |L2.98|
                  |L2.88|
000058  f2404112          MOV      r1,#0x412
00005c  4813              LDR      r0,|L2.172|
00005e  f7fffffe          BL       assert_failed
                  |L2.98|
;;;1043     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1044     if (USART_IT == USART_IT_CTS)
000062  f640106a          MOV      r0,#0x96a
000066  4285              CMP      r5,r0
000068  d10e              BNE      |L2.136|
;;;1045     {
;;;1046       assert_param(IS_USART_123_PERIPH(USARTx));
00006a  480b              LDR      r0,|L2.152|
00006c  4284              CMP      r4,r0
00006e  d005              BEQ      |L2.124|
000070  480a              LDR      r0,|L2.156|
000072  4284              CMP      r4,r0
000074  d002              BEQ      |L2.124|
000076  480a              LDR      r0,|L2.160|
000078  4284              CMP      r4,r0
00007a  d100              BNE      |L2.126|
                  |L2.124|
00007c  e004              B        |L2.136|
                  |L2.126|
00007e  f2404116          MOV      r1,#0x416
000082  480a              LDR      r0,|L2.172|
000084  f7fffffe          BL       assert_failed
                  |L2.136|
;;;1047     }   
;;;1048     
;;;1049     bitpos = USART_IT >> 0x08;
000088  122e              ASRS     r6,r5,#8
;;;1050     itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
00008a  2001              MOVS     r0,#1
00008c  40b0              LSLS     r0,r0,r6
00008e  b287              UXTH     r7,r0
;;;1051     USARTx->SR = (uint16_t)~itmask;
000090  43f8              MVNS     r0,r7
000092  8020              STRH     r0,[r4,#0]
;;;1052   }
000094  e8bd81f0          POP      {r4-r8,pc}
;;;1053   /**
                          ENDP

                  |L2.152|
                          DCD      0x40013800
                  |L2.156|
                          DCD      0x40004400
                  |L2.160|
                          DCD      0x40004800
                  |L2.164|
                          DCD      0x40004c00
                  |L2.168|
                          DCD      0x40005000
                  |L2.172|
                          DCD      ||.conststring||

                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=2

                  USART_ClockInit PROC
;;;307      */
;;;308    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;309    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;310      uint32_t tmpreg = 0x00;
000006  2600              MOVS     r6,#0
;;;311      /* Check the parameters */
;;;312      assert_param(IS_USART_123_PERIPH(USARTx));
000008  4826              LDR      r0,|L3.164|
00000a  4285              CMP      r5,r0
00000c  d005              BEQ      |L3.26|
00000e  4826              LDR      r0,|L3.168|
000010  4285              CMP      r5,r0
000012  d002              BEQ      |L3.26|
000014  4825              LDR      r0,|L3.172|
000016  4285              CMP      r5,r0
000018  d100              BNE      |L3.28|
                  |L3.26|
00001a  e004              B        |L3.38|
                  |L3.28|
00001c  f44f719c          MOV      r1,#0x138
000020  4823              LDR      r0,|L3.176|
000022  f7fffffe          BL       assert_failed
                  |L3.38|
;;;313      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
000026  8820              LDRH     r0,[r4,#0]
000028  b118              CBZ      r0,|L3.50|
00002a  8820              LDRH     r0,[r4,#0]
00002c  f5b06f00          CMP      r0,#0x800
000030  d100              BNE      |L3.52|
                  |L3.50|
000032  e004              B        |L3.62|
                  |L3.52|
000034  f2401139          MOV      r1,#0x139
000038  481d              LDR      r0,|L3.176|
00003a  f7fffffe          BL       assert_failed
                  |L3.62|
;;;314      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
00003e  8860              LDRH     r0,[r4,#2]
000040  b118              CBZ      r0,|L3.74|
000042  8860              LDRH     r0,[r4,#2]
000044  f5b06f80          CMP      r0,#0x400
000048  d100              BNE      |L3.76|
                  |L3.74|
00004a  e004              B        |L3.86|
                  |L3.76|
00004c  f44f719d          MOV      r1,#0x13a
000050  4817              LDR      r0,|L3.176|
000052  f7fffffe          BL       assert_failed
                  |L3.86|
;;;315      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
000056  88a0              LDRH     r0,[r4,#4]
000058  b118              CBZ      r0,|L3.98|
00005a  88a0              LDRH     r0,[r4,#4]
00005c  f5b07f00          CMP      r0,#0x200
000060  d100              BNE      |L3.100|
                  |L3.98|
000062  e004              B        |L3.110|
                  |L3.100|
000064  f240113b          MOV      r1,#0x13b
000068  4811              LDR      r0,|L3.176|
00006a  f7fffffe          BL       assert_failed
                  |L3.110|
;;;316      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
00006e  88e0              LDRH     r0,[r4,#6]
000070  b118              CBZ      r0,|L3.122|
000072  88e0              LDRH     r0,[r4,#6]
000074  f5b07f80          CMP      r0,#0x100
000078  d100              BNE      |L3.124|
                  |L3.122|
00007a  e004              B        |L3.134|
                  |L3.124|
00007c  f44f719e          MOV      r1,#0x13c
000080  480b              LDR      r0,|L3.176|
000082  f7fffffe          BL       assert_failed
                  |L3.134|
;;;317      
;;;318    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;319      tmpreg = USARTx->CR2;
000086  8a2e              LDRH     r6,[r5,#0x10]
;;;320      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;321      tmpreg &= CR2_CLOCK_CLEAR_Mask;
000088  f24f00ff          MOV      r0,#0xf0ff
00008c  4006              ANDS     r6,r6,r0
;;;322      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;323      /* Set CLKEN bit according to USART_Clock value */
;;;324      /* Set CPOL bit according to USART_CPOL value */
;;;325      /* Set CPHA bit according to USART_CPHA value */
;;;326      /* Set LBCL bit according to USART_LastBit value */
;;;327      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
00008e  8820              LDRH     r0,[r4,#0]
000090  8861              LDRH     r1,[r4,#2]
000092  4308              ORRS     r0,r0,r1
000094  88a1              LDRH     r1,[r4,#4]
000096  4308              ORRS     r0,r0,r1
000098  88e1              LDRH     r1,[r4,#6]
00009a  4308              ORRS     r0,r0,r1
00009c  4306              ORRS     r6,r6,r0
;;;328                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;329      /* Write to USART CR2 */
;;;330      USARTx->CR2 = (uint16_t)tmpreg;
00009e  822e              STRH     r6,[r5,#0x10]
;;;331    }
0000a0  bd70              POP      {r4-r6,pc}
;;;332    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L3.164|
                          DCD      0x40013800
                  |L3.168|
                          DCD      0x40004400
                  |L3.172|
                          DCD      0x40004800
                  |L3.176|
                          DCD      ||.conststring||

                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;338      */
;;;339    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;340    {
;;;341      /* USART_ClockInitStruct members default value */
;;;342      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;343      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000004  8041              STRH     r1,[r0,#2]
;;;344      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000006  8081              STRH     r1,[r0,#4]
;;;345      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;346    }
00000a  4770              BX       lr
;;;347    
                          ENDP


                          AREA ||i.USART_Cmd||, CODE, READONLY, ALIGN=2

                  USART_Cmd PROC
;;;356      */
;;;357    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;358    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;359      /* Check the parameters */
;;;360      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4815              LDR      r0,|L5.92|
000008  4284              CMP      r4,r0
00000a  d00b              BEQ      |L5.36|
00000c  4814              LDR      r0,|L5.96|
00000e  4284              CMP      r4,r0
000010  d008              BEQ      |L5.36|
000012  4814              LDR      r0,|L5.100|
000014  4284              CMP      r4,r0
000016  d005              BEQ      |L5.36|
000018  4813              LDR      r0,|L5.104|
00001a  4284              CMP      r4,r0
00001c  d002              BEQ      |L5.36|
00001e  4813              LDR      r0,|L5.108|
000020  4284              CMP      r4,r0
000022  d100              BNE      |L5.38|
                  |L5.36|
000024  e004              B        |L5.48|
                  |L5.38|
000026  f44f71b4          MOV      r1,#0x168
00002a  4811              LDR      r0,|L5.112|
00002c  f7fffffe          BL       assert_failed
                  |L5.48|
;;;361      assert_param(IS_FUNCTIONAL_STATE(NewState));
000030  b10d              CBZ      r5,|L5.54|
000032  2d01              CMP      r5,#1
000034  d100              BNE      |L5.56|
                  |L5.54|
000036  e004              B        |L5.66|
                  |L5.56|
000038  f2401169          MOV      r1,#0x169
00003c  480c              LDR      r0,|L5.112|
00003e  f7fffffe          BL       assert_failed
                  |L5.66|
;;;362      
;;;363      if (NewState != DISABLE)
000042  b125              CBZ      r5,|L5.78|
;;;364      {
;;;365        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;366        USARTx->CR1 |= CR1_UE_Set;
000044  89a0              LDRH     r0,[r4,#0xc]
000046  f4405000          ORR      r0,r0,#0x2000
00004a  81a0              STRH     r0,[r4,#0xc]
00004c  e004              B        |L5.88|
                  |L5.78|
;;;367      }
;;;368      else
;;;369      {
;;;370        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;371        USARTx->CR1 &= CR1_UE_Reset;
00004e  89a0              LDRH     r0,[r4,#0xc]
000050  f64d71ff          MOV      r1,#0xdfff
000054  4008              ANDS     r0,r0,r1
000056  81a0              STRH     r0,[r4,#0xc]
                  |L5.88|
;;;372      }
;;;373    }
000058  bd70              POP      {r4-r6,pc}
;;;374    
                          ENDP

00005a  0000              DCW      0x0000
                  |L5.92|
                          DCD      0x40013800
                  |L5.96|
                          DCD      0x40004400
                  |L5.100|
                          DCD      0x40004800
                  |L5.104|
                          DCD      0x40004c00
                  |L5.108|
                          DCD      0x40005000
                  |L5.112|
                          DCD      ||.conststring||

                          AREA ||i.USART_DMACmd||, CODE, READONLY, ALIGN=2

                  USART_DMACmd PROC
;;;453      */
;;;454    void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;455    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;456      /* Check the parameters */
;;;457      assert_param(IS_USART_ALL_PERIPH(USARTx));
000008  4818              LDR      r0,|L6.108|
00000a  4284              CMP      r4,r0
00000c  d00b              BEQ      |L6.38|
00000e  4818              LDR      r0,|L6.112|
000010  4284              CMP      r4,r0
000012  d008              BEQ      |L6.38|
000014  4817              LDR      r0,|L6.116|
000016  4284              CMP      r4,r0
000018  d005              BEQ      |L6.38|
00001a  4817              LDR      r0,|L6.120|
00001c  4284              CMP      r4,r0
00001e  d002              BEQ      |L6.38|
000020  4816              LDR      r0,|L6.124|
000022  4284              CMP      r4,r0
000024  d100              BNE      |L6.40|
                  |L6.38|
000026  e004              B        |L6.50|
                  |L6.40|
000028  f24011c9          MOV      r1,#0x1c9
00002c  4814              LDR      r0,|L6.128|
00002e  f7fffffe          BL       assert_failed
                  |L6.50|
;;;458      assert_param(IS_USART_DMAREQ(USART_DMAReq));  
000032  f64f703f          MOV      r0,#0xff3f
000036  4028              ANDS     r0,r0,r5
000038  b908              CBNZ     r0,|L6.62|
00003a  b105              CBZ      r5,|L6.62|
00003c  e004              B        |L6.72|
                  |L6.62|
00003e  f44f71e5          MOV      r1,#0x1ca
000042  480f              LDR      r0,|L6.128|
000044  f7fffffe          BL       assert_failed
                  |L6.72|
;;;459      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
000048  b10e              CBZ      r6,|L6.78|
00004a  2e01              CMP      r6,#1
00004c  d100              BNE      |L6.80|
                  |L6.78|
00004e  e004              B        |L6.90|
                  |L6.80|
000050  f24011cb          MOV      r1,#0x1cb
000054  480a              LDR      r0,|L6.128|
000056  f7fffffe          BL       assert_failed
                  |L6.90|
;;;460      if (NewState != DISABLE)
00005a  b11e              CBZ      r6,|L6.100|
;;;461      {
;;;462        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;463           DMAR bits in the USART CR3 register */
;;;464        USARTx->CR3 |= USART_DMAReq;
00005c  8aa0              LDRH     r0,[r4,#0x14]
00005e  4328              ORRS     r0,r0,r5
000060  82a0              STRH     r0,[r4,#0x14]
000062  e002              B        |L6.106|
                  |L6.100|
;;;465      }
;;;466      else
;;;467      {
;;;468        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;469           DMAR bits in the USART CR3 register */
;;;470        USARTx->CR3 &= (uint16_t)~USART_DMAReq;
000064  8aa0              LDRH     r0,[r4,#0x14]
000066  43a8              BICS     r0,r0,r5
000068  82a0              STRH     r0,[r4,#0x14]
                  |L6.106|
;;;471      }
;;;472    }
00006a  bd70              POP      {r4-r6,pc}
;;;473    
                          ENDP

                  |L6.108|
                          DCD      0x40013800
                  |L6.112|
                          DCD      0x40004400
                  |L6.116|
                          DCD      0x40004800
                  |L6.120|
                          DCD      0x40004c00
                  |L6.124|
                          DCD      0x40005000
                  |L6.128|
                          DCD      ||.conststring||

                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;135      */
;;;136    void USART_DeInit(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;137    {
000002  4604              MOV      r4,r0
;;;138      /* Check the parameters */
;;;139      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  482a              LDR      r0,|L7.176|
000006  4284              CMP      r4,r0
000008  d00b              BEQ      |L7.34|
00000a  482a              LDR      r0,|L7.180|
00000c  4284              CMP      r4,r0
00000e  d008              BEQ      |L7.34|
000010  4829              LDR      r0,|L7.184|
000012  4284              CMP      r4,r0
000014  d005              BEQ      |L7.34|
000016  4829              LDR      r0,|L7.188|
000018  4284              CMP      r4,r0
00001a  d002              BEQ      |L7.34|
00001c  4828              LDR      r0,|L7.192|
00001e  4284              CMP      r4,r0
000020  d100              BNE      |L7.36|
                  |L7.34|
000022  e003              B        |L7.44|
                  |L7.36|
000024  218b              MOVS     r1,#0x8b
000026  4827              LDR      r0,|L7.196|
000028  f7fffffe          BL       assert_failed
                  |L7.44|
;;;140    
;;;141      if (USARTx == USART1)
00002c  4820              LDR      r0,|L7.176|
00002e  4284              CMP      r4,r0
000030  d109              BNE      |L7.70|
;;;142      {
;;;143        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
000032  2101              MOVS     r1,#1
000034  0388              LSLS     r0,r1,#14
000036  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;144        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
00003a  2100              MOVS     r1,#0
00003c  f44f4080          MOV      r0,#0x4000
000040  f7fffffe          BL       RCC_APB2PeriphResetCmd
000044  e032              B        |L7.172|
                  |L7.70|
;;;145      }
;;;146      else if (USARTx == USART2)
000046  481b              LDR      r0,|L7.180|
000048  4284              CMP      r4,r0
00004a  d109              BNE      |L7.96|
;;;147      {
;;;148        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
00004c  2101              MOVS     r1,#1
00004e  0448              LSLS     r0,r1,#17
000050  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;149        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
000054  2100              MOVS     r1,#0
000056  f44f3000          MOV      r0,#0x20000
00005a  f7fffffe          BL       RCC_APB1PeriphResetCmd
00005e  e025              B        |L7.172|
                  |L7.96|
;;;150      }
;;;151      else if (USARTx == USART3)
000060  4815              LDR      r0,|L7.184|
000062  4284              CMP      r4,r0
000064  d109              BNE      |L7.122|
;;;152      {
;;;153        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
000066  2101              MOVS     r1,#1
000068  0488              LSLS     r0,r1,#18
00006a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;154        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
00006e  2100              MOVS     r1,#0
000070  f44f2080          MOV      r0,#0x40000
000074  f7fffffe          BL       RCC_APB1PeriphResetCmd
000078  e018              B        |L7.172|
                  |L7.122|
;;;155      }    
;;;156      else if (USARTx == UART4)
00007a  4810              LDR      r0,|L7.188|
00007c  4284              CMP      r4,r0
00007e  d109              BNE      |L7.148|
;;;157      {
;;;158        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
000080  2101              MOVS     r1,#1
000082  04c8              LSLS     r0,r1,#19
000084  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;159        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
000088  2100              MOVS     r1,#0
00008a  f44f2000          MOV      r0,#0x80000
00008e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000092  e00b              B        |L7.172|
                  |L7.148|
;;;160      }    
;;;161      else
;;;162      {
;;;163        if (USARTx == UART5)
000094  480a              LDR      r0,|L7.192|
000096  4284              CMP      r4,r0
000098  d108              BNE      |L7.172|
;;;164        { 
;;;165          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  0508              LSLS     r0,r1,#20
00009e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;166          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
0000a2  2100              MOVS     r1,#0
0000a4  f44f1080          MOV      r0,#0x100000
0000a8  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L7.172|
;;;167        }
;;;168      }
;;;169    }
0000ac  bd10              POP      {r4,pc}
;;;170    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L7.176|
                          DCD      0x40013800
                  |L7.180|
                          DCD      0x40004400
                  |L7.184|
                          DCD      0x40004800
                  |L7.188|
                          DCD      0x40004c00
                  |L7.192|
                          DCD      0x40005000
                  |L7.196|
                          DCD      ||.conststring||

                          AREA ||i.USART_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  USART_GetFlagStatus PROC
;;;879      */
;;;880    FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;881    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;882      FlagStatus bitstatus = RESET;
000006  2600              MOVS     r6,#0
;;;883      /* Check the parameters */
;;;884      assert_param(IS_USART_ALL_PERIPH(USARTx));
000008  4825              LDR      r0,|L8.160|
00000a  4285              CMP      r5,r0
00000c  d00b              BEQ      |L8.38|
00000e  4825              LDR      r0,|L8.164|
000010  4285              CMP      r5,r0
000012  d008              BEQ      |L8.38|
000014  4824              LDR      r0,|L8.168|
000016  4285              CMP      r5,r0
000018  d005              BEQ      |L8.38|
00001a  4824              LDR      r0,|L8.172|
00001c  4285              CMP      r5,r0
00001e  d002              BEQ      |L8.38|
000020  4823              LDR      r0,|L8.176|
000022  4285              CMP      r5,r0
000024  d100              BNE      |L8.40|
                  |L8.38|
000026  e004              B        |L8.50|
                  |L8.40|
000028  f44f715d          MOV      r1,#0x374
00002c  4821              LDR      r0,|L8.180|
00002e  f7fffffe          BL       assert_failed
                  |L8.50|
;;;885      assert_param(IS_USART_FLAG(USART_FLAG));
000032  2c01              CMP      r4,#1
000034  d013              BEQ      |L8.94|
000036  2c80              CMP      r4,#0x80
000038  d011              BEQ      |L8.94|
00003a  2c40              CMP      r4,#0x40
00003c  d00f              BEQ      |L8.94|
00003e  2c20              CMP      r4,#0x20
000040  d00d              BEQ      |L8.94|
000042  2c10              CMP      r4,#0x10
000044  d00b              BEQ      |L8.94|
000046  f5b47f80          CMP      r4,#0x100
00004a  d008              BEQ      |L8.94|
00004c  f5b47f00          CMP      r4,#0x200
000050  d005              BEQ      |L8.94|
000052  2c08              CMP      r4,#8
000054  d003              BEQ      |L8.94|
000056  2c04              CMP      r4,#4
000058  d001              BEQ      |L8.94|
00005a  2c02              CMP      r4,#2
00005c  d100              BNE      |L8.96|
                  |L8.94|
00005e  e004              B        |L8.106|
                  |L8.96|
000060  f2403175          MOV      r1,#0x375
000064  4813              LDR      r0,|L8.180|
000066  f7fffffe          BL       assert_failed
                  |L8.106|
;;;886      /* The CTS flag is not available for UART4 and UART5 */
;;;887      if (USART_FLAG == USART_FLAG_CTS)
00006a  f5b47f00          CMP      r4,#0x200
00006e  d10e              BNE      |L8.142|
;;;888      {
;;;889        assert_param(IS_USART_123_PERIPH(USARTx));
000070  480b              LDR      r0,|L8.160|
000072  4285              CMP      r5,r0
000074  d005              BEQ      |L8.130|
000076  480b              LDR      r0,|L8.164|
000078  4285              CMP      r5,r0
00007a  d002              BEQ      |L8.130|
00007c  480a              LDR      r0,|L8.168|
00007e  4285              CMP      r5,r0
000080  d100              BNE      |L8.132|
                  |L8.130|
000082  e004              B        |L8.142|
                  |L8.132|
000084  f2403179          MOV      r1,#0x379
000088  480a              LDR      r0,|L8.180|
00008a  f7fffffe          BL       assert_failed
                  |L8.142|
;;;890      }  
;;;891      
;;;892      if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
00008e  8828              LDRH     r0,[r5,#0]
000090  4020              ANDS     r0,r0,r4
000092  b108              CBZ      r0,|L8.152|
;;;893      {
;;;894        bitstatus = SET;
000094  2601              MOVS     r6,#1
000096  e000              B        |L8.154|
                  |L8.152|
;;;895      }
;;;896      else
;;;897      {
;;;898        bitstatus = RESET;
000098  2600              MOVS     r6,#0
                  |L8.154|
;;;899      }
;;;900      return bitstatus;
00009a  4630              MOV      r0,r6
;;;901    }
00009c  bd70              POP      {r4-r6,pc}
;;;902    
                          ENDP

00009e  0000              DCW      0x0000
                  |L8.160|
                          DCD      0x40013800
                  |L8.164|
                          DCD      0x40004400
                  |L8.168|
                          DCD      0x40004800
                  |L8.172|
                          DCD      0x40004c00
                  |L8.176|
                          DCD      0x40005000
                  |L8.180|
                          DCD      ||.conststring||

                          AREA ||i.USART_GetITStatus||, CODE, READONLY, ALIGN=2

                  USART_GetITStatus PROC
;;;962      */
;;;963    ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;964    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;965      uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
000008  2700              MOVS     r7,#0
00000a  2600              MOVS     r6,#0
00000c  46b0              MOV      r8,r6
;;;966      ITStatus bitstatus = RESET;
00000e  46b1              MOV      r9,r6
;;;967      /* Check the parameters */
;;;968      assert_param(IS_USART_ALL_PERIPH(USARTx));
000010  483e              LDR      r0,|L9.268|
000012  4285              CMP      r5,r0
000014  d00b              BEQ      |L9.46|
000016  483e              LDR      r0,|L9.272|
000018  4285              CMP      r5,r0
00001a  d008              BEQ      |L9.46|
00001c  483d              LDR      r0,|L9.276|
00001e  4285              CMP      r5,r0
000020  d005              BEQ      |L9.46|
000022  483d              LDR      r0,|L9.280|
000024  4285              CMP      r5,r0
000026  d002              BEQ      |L9.46|
000028  483c              LDR      r0,|L9.284|
00002a  4285              CMP      r5,r0
00002c  d100              BNE      |L9.48|
                  |L9.46|
00002e  e004              B        |L9.58|
                  |L9.48|
000030  f44f7172          MOV      r1,#0x3c8
000034  483a              LDR      r0,|L9.288|
000036  f7fffffe          BL       assert_failed
                  |L9.58|
;;;969      assert_param(IS_USART_GET_IT(USART_IT));
00003a  2c28              CMP      r4,#0x28
00003c  d027              BEQ      |L9.142|
00003e  f2407027          MOV      r0,#0x727
000042  4284              CMP      r4,r0
000044  d023              BEQ      |L9.142|
000046  f2406026          MOV      r0,#0x626
00004a  4284              CMP      r4,r0
00004c  d01f              BEQ      |L9.142|
00004e  f2405025          MOV      r0,#0x525
000052  4284              CMP      r4,r0
000054  d01b              BEQ      |L9.142|
000056  f2404024          MOV      r0,#0x424
00005a  4284              CMP      r4,r0
00005c  d017              BEQ      |L9.142|
00005e  f6400046          MOV      r0,#0x846
000062  4284              CMP      r4,r0
000064  d013              BEQ      |L9.142|
000066  f640106a          MOV      r0,#0x96a
00006a  4284              CMP      r4,r0
00006c  d00f              BEQ      |L9.142|
00006e  f5b47f58          CMP      r4,#0x360
000072  d00c              BEQ      |L9.142|
000074  f2403025          MOV      r0,#0x325
000078  4284              CMP      r4,r0
00007a  d008              BEQ      |L9.142|
00007c  f5b47f58          CMP      r4,#0x360
000080  d005              BEQ      |L9.142|
000082  f5b47f18          CMP      r4,#0x260
000086  d002              BEQ      |L9.142|
000088  f5b47fb0          CMP      r4,#0x160
00008c  d100              BNE      |L9.144|
                  |L9.142|
00008e  e004              B        |L9.154|
                  |L9.144|
000090  f24031c9          MOV      r1,#0x3c9
000094  4822              LDR      r0,|L9.288|
000096  f7fffffe          BL       assert_failed
                  |L9.154|
;;;970      /* The CTS interrupt is not available for UART4 and UART5 */ 
;;;971      if (USART_IT == USART_IT_CTS)
00009a  f640106a          MOV      r0,#0x96a
00009e  4284              CMP      r4,r0
0000a0  d10e              BNE      |L9.192|
;;;972      {
;;;973        assert_param(IS_USART_123_PERIPH(USARTx));
0000a2  481a              LDR      r0,|L9.268|
0000a4  4285              CMP      r5,r0
0000a6  d005              BEQ      |L9.180|
0000a8  4819              LDR      r0,|L9.272|
0000aa  4285              CMP      r5,r0
0000ac  d002              BEQ      |L9.180|
0000ae  4819              LDR      r0,|L9.276|
0000b0  4285              CMP      r5,r0
0000b2  d100              BNE      |L9.182|
                  |L9.180|
0000b4  e004              B        |L9.192|
                  |L9.182|
0000b6  f24031cd          MOV      r1,#0x3cd
0000ba  4819              LDR      r0,|L9.288|
0000bc  f7fffffe          BL       assert_failed
                  |L9.192|
;;;974      }   
;;;975      
;;;976      /* Get the USART register index */
;;;977      usartreg = (((uint8_t)USART_IT) >> 0x05);
0000c0  f3c41842          UBFX     r8,r4,#5,#3
;;;978      /* Get the interrupt position */
;;;979      itmask = USART_IT & IT_Mask;
0000c4  f004061f          AND      r6,r4,#0x1f
;;;980      itmask = (uint32_t)0x01 << itmask;
0000c8  2001              MOVS     r0,#1
0000ca  fa00f606          LSL      r6,r0,r6
;;;981      
;;;982      if (usartreg == 0x01) /* The IT  is in CR1 register */
0000ce  f1b80f01          CMP      r8,#1
0000d2  d102              BNE      |L9.218|
;;;983      {
;;;984        itmask &= USARTx->CR1;
0000d4  89a8              LDRH     r0,[r5,#0xc]
0000d6  4006              ANDS     r6,r6,r0
0000d8  e007              B        |L9.234|
                  |L9.218|
;;;985      }
;;;986      else if (usartreg == 0x02) /* The IT  is in CR2 register */
0000da  f1b80f02          CMP      r8,#2
0000de  d102              BNE      |L9.230|
;;;987      {
;;;988        itmask &= USARTx->CR2;
0000e0  8a28              LDRH     r0,[r5,#0x10]
0000e2  4006              ANDS     r6,r6,r0
0000e4  e001              B        |L9.234|
                  |L9.230|
;;;989      }
;;;990      else /* The IT  is in CR3 register */
;;;991      {
;;;992        itmask &= USARTx->CR3;
0000e6  8aa8              LDRH     r0,[r5,#0x14]
0000e8  4006              ANDS     r6,r6,r0
                  |L9.234|
;;;993      }
;;;994      
;;;995      bitpos = USART_IT >> 0x08;
0000ea  1227              ASRS     r7,r4,#8
;;;996      bitpos = (uint32_t)0x01 << bitpos;
0000ec  2001              MOVS     r0,#1
0000ee  fa00f707          LSL      r7,r0,r7
;;;997      bitpos &= USARTx->SR;
0000f2  8828              LDRH     r0,[r5,#0]
0000f4  4007              ANDS     r7,r7,r0
;;;998      if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
0000f6  b11e              CBZ      r6,|L9.256|
0000f8  b117              CBZ      r7,|L9.256|
;;;999      {
;;;1000       bitstatus = SET;
0000fa  f04f0901          MOV      r9,#1
0000fe  e001              B        |L9.260|
                  |L9.256|
;;;1001     }
;;;1002     else
;;;1003     {
;;;1004       bitstatus = RESET;
000100  f04f0900          MOV      r9,#0
                  |L9.260|
;;;1005     }
;;;1006     
;;;1007     return bitstatus;  
000104  4648              MOV      r0,r9
;;;1008   }
000106  e8bd87f0          POP      {r4-r10,pc}
;;;1009   
                          ENDP

00010a  0000              DCW      0x0000
                  |L9.268|
                          DCD      0x40013800
                  |L9.272|
                          DCD      0x40004400
                  |L9.276|
                          DCD      0x40004800
                  |L9.280|
                          DCD      0x40004c00
                  |L9.284|
                          DCD      0x40005000
                  |L9.288|
                          DCD      ||.conststring||

                          AREA ||i.USART_HalfDuplexCmd||, CODE, READONLY, ALIGN=2

                  USART_HalfDuplexCmd PROC
;;;736      */
;;;737    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;738    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;739      /* Check the parameters */
;;;740      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4815              LDR      r0,|L10.92|
000008  4284              CMP      r4,r0
00000a  d00b              BEQ      |L10.36|
00000c  4814              LDR      r0,|L10.96|
00000e  4284              CMP      r4,r0
000010  d008              BEQ      |L10.36|
000012  4814              LDR      r0,|L10.100|
000014  4284              CMP      r4,r0
000016  d005              BEQ      |L10.36|
000018  4813              LDR      r0,|L10.104|
00001a  4284              CMP      r4,r0
00001c  d002              BEQ      |L10.36|
00001e  4813              LDR      r0,|L10.108|
000020  4284              CMP      r4,r0
000022  d100              BNE      |L10.38|
                  |L10.36|
000024  e004              B        |L10.48|
                  |L10.38|
000026  f44f7139          MOV      r1,#0x2e4
00002a  4811              LDR      r0,|L10.112|
00002c  f7fffffe          BL       assert_failed
                  |L10.48|
;;;741      assert_param(IS_FUNCTIONAL_STATE(NewState));
000030  b10d              CBZ      r5,|L10.54|
000032  2d01              CMP      r5,#1
000034  d100              BNE      |L10.56|
                  |L10.54|
000036  e004              B        |L10.66|
                  |L10.56|
000038  f24021e5          MOV      r1,#0x2e5
00003c  480c              LDR      r0,|L10.112|
00003e  f7fffffe          BL       assert_failed
                  |L10.66|
;;;742      
;;;743      if (NewState != DISABLE)
000042  b125              CBZ      r5,|L10.78|
;;;744      {
;;;745        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;746        USARTx->CR3 |= CR3_HDSEL_Set;
000044  8aa0              LDRH     r0,[r4,#0x14]
000046  f0400008          ORR      r0,r0,#8
00004a  82a0              STRH     r0,[r4,#0x14]
00004c  e004              B        |L10.88|
                  |L10.78|
;;;747      }
;;;748      else
;;;749      {
;;;750        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;751        USARTx->CR3 &= CR3_HDSEL_Reset;
00004e  8aa0              LDRH     r0,[r4,#0x14]
000050  f64f71f7          MOV      r1,#0xfff7
000054  4008              ANDS     r0,r0,r1
000056  82a0              STRH     r0,[r4,#0x14]
                  |L10.88|
;;;752      }
;;;753    }
000058  bd70              POP      {r4-r6,pc}
;;;754    
                          ENDP

00005a  0000              DCW      0x0000
                  |L10.92|
                          DCD      0x40013800
                  |L10.96|
                          DCD      0x40004400
                  |L10.100|
                          DCD      0x40004800
                  |L10.104|
                          DCD      0x40004c00
                  |L10.108|
                          DCD      0x40005000
                  |L10.112|
                          DCD      ||.conststring||

                          AREA ||i.USART_ITConfig||, CODE, READONLY, ALIGN=2

                  USART_ITConfig PROC
;;;393      */
;;;394    void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;395    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;396      uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
00000a  f04f0800          MOV      r8,#0
00000e  46c2              MOV      r10,r8
000010  46c1              MOV      r9,r8
;;;397      uint32_t usartxbase = 0x00;
000012  2600              MOVS     r6,#0
;;;398      /* Check the parameters */
;;;399      assert_param(IS_USART_ALL_PERIPH(USARTx));
000014  4838              LDR      r0,|L11.248|
000016  4285              CMP      r5,r0
000018  d00b              BEQ      |L11.50|
00001a  4838              LDR      r0,|L11.252|
00001c  4285              CMP      r5,r0
00001e  d008              BEQ      |L11.50|
000020  4837              LDR      r0,|L11.256|
000022  4285              CMP      r5,r0
000024  d005              BEQ      |L11.50|
000026  4837              LDR      r0,|L11.260|
000028  4285              CMP      r5,r0
00002a  d002              BEQ      |L11.50|
00002c  4836              LDR      r0,|L11.264|
00002e  4285              CMP      r5,r0
000030  d100              BNE      |L11.52|
                  |L11.50|
000032  e004              B        |L11.62|
                  |L11.52|
000034  f240118f          MOV      r1,#0x18f
000038  4834              LDR      r0,|L11.268|
00003a  f7fffffe          BL       assert_failed
                  |L11.62|
;;;400      assert_param(IS_USART_CONFIG_IT(USART_IT));
00003e  2c28              CMP      r4,#0x28
000040  d019              BEQ      |L11.118|
000042  f2407027          MOV      r0,#0x727
000046  4284              CMP      r4,r0
000048  d015              BEQ      |L11.118|
00004a  f2406026          MOV      r0,#0x626
00004e  4284              CMP      r4,r0
000050  d011              BEQ      |L11.118|
000052  f2405025          MOV      r0,#0x525
000056  4284              CMP      r4,r0
000058  d00d              BEQ      |L11.118|
00005a  f2404024          MOV      r0,#0x424
00005e  4284              CMP      r4,r0
000060  d009              BEQ      |L11.118|
000062  f6400046          MOV      r0,#0x846
000066  4284              CMP      r4,r0
000068  d005              BEQ      |L11.118|
00006a  f640106a          MOV      r0,#0x96a
00006e  4284              CMP      r4,r0
000070  d001              BEQ      |L11.118|
000072  2c60              CMP      r4,#0x60
000074  d100              BNE      |L11.120|
                  |L11.118|
000076  e004              B        |L11.130|
                  |L11.120|
000078  f44f71c8          MOV      r1,#0x190
00007c  4823              LDR      r0,|L11.268|
00007e  f7fffffe          BL       assert_failed
                  |L11.130|
;;;401      assert_param(IS_FUNCTIONAL_STATE(NewState));
000082  b10f              CBZ      r7,|L11.136|
000084  2f01              CMP      r7,#1
000086  d100              BNE      |L11.138|
                  |L11.136|
000088  e004              B        |L11.148|
                  |L11.138|
00008a  f2401191          MOV      r1,#0x191
00008e  481f              LDR      r0,|L11.268|
000090  f7fffffe          BL       assert_failed
                  |L11.148|
;;;402      /* The CTS interrupt is not available for UART4 and UART5 */
;;;403      if (USART_IT == USART_IT_CTS)
000094  f640106a          MOV      r0,#0x96a
000098  4284              CMP      r4,r0
00009a  d10e              BNE      |L11.186|
;;;404      {
;;;405        assert_param(IS_USART_123_PERIPH(USARTx));
00009c  4816              LDR      r0,|L11.248|
00009e  4285              CMP      r5,r0
0000a0  d005              BEQ      |L11.174|
0000a2  4816              LDR      r0,|L11.252|
0000a4  4285              CMP      r5,r0
0000a6  d002              BEQ      |L11.174|
0000a8  4815              LDR      r0,|L11.256|
0000aa  4285              CMP      r5,r0
0000ac  d100              BNE      |L11.176|
                  |L11.174|
0000ae  e004              B        |L11.186|
                  |L11.176|
0000b0  f2401195          MOV      r1,#0x195
0000b4  4815              LDR      r0,|L11.268|
0000b6  f7fffffe          BL       assert_failed
                  |L11.186|
;;;406      }   
;;;407      
;;;408      usartxbase = (uint32_t)USARTx;
0000ba  462e              MOV      r6,r5
;;;409    
;;;410      /* Get the USART register index */
;;;411      usartreg = (((uint8_t)USART_IT) >> 0x05);
0000bc  f3c41842          UBFX     r8,r4,#5,#3
;;;412    
;;;413      /* Get the interrupt position */
;;;414      itpos = USART_IT & IT_Mask;
0000c0  f0040a1f          AND      r10,r4,#0x1f
;;;415      itmask = (((uint32_t)0x01) << itpos);
0000c4  2001              MOVS     r0,#1
0000c6  fa00f90a          LSL      r9,r0,r10
;;;416        
;;;417      if (usartreg == 0x01) /* The IT is in CR1 register */
0000ca  f1b80f01          CMP      r8,#1
0000ce  d101              BNE      |L11.212|
;;;418      {
;;;419        usartxbase += 0x0C;
0000d0  360c              ADDS     r6,r6,#0xc
0000d2  e005              B        |L11.224|
                  |L11.212|
;;;420      }
;;;421      else if (usartreg == 0x02) /* The IT is in CR2 register */
0000d4  f1b80f02          CMP      r8,#2
0000d8  d101              BNE      |L11.222|
;;;422      {
;;;423        usartxbase += 0x10;
0000da  3610              ADDS     r6,r6,#0x10
0000dc  e000              B        |L11.224|
                  |L11.222|
;;;424      }
;;;425      else /* The IT is in CR3 register */
;;;426      {
;;;427        usartxbase += 0x14; 
0000de  3614              ADDS     r6,r6,#0x14
                  |L11.224|
;;;428      }
;;;429      if (NewState != DISABLE)
0000e0  b127              CBZ      r7,|L11.236|
;;;430      {
;;;431        *(__IO uint32_t*)usartxbase  |= itmask;
0000e2  6830              LDR      r0,[r6,#0]
0000e4  ea400009          ORR      r0,r0,r9
0000e8  6030              STR      r0,[r6,#0]
0000ea  e003              B        |L11.244|
                  |L11.236|
;;;432      }
;;;433      else
;;;434      {
;;;435        *(__IO uint32_t*)usartxbase &= ~itmask;
0000ec  6830              LDR      r0,[r6,#0]
0000ee  ea200009          BIC      r0,r0,r9
0000f2  6030              STR      r0,[r6,#0]
                  |L11.244|
;;;436      }
;;;437    }
0000f4  e8bd87f0          POP      {r4-r10,pc}
;;;438    
                          ENDP

                  |L11.248|
                          DCD      0x40013800
                  |L11.252|
                          DCD      0x40004400
                  |L11.256|
                          DCD      0x40004800
                  |L11.260|
                          DCD      0x40004c00
                  |L11.264|
                          DCD      0x40005000
                  |L11.268|
                          DCD      ||.conststring||

                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;181      */
;;;182    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;183    {
000004  b086              SUB      sp,sp,#0x18
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
;;;184      uint32_t tmpreg = 0x00, apbclock = 0x00;
00000a  2600              MOVS     r6,#0
00000c  46b2              MOV      r10,r6
;;;185      uint32_t integerdivider = 0x00;
00000e  bf00              NOP      
;;;186      uint32_t fractionaldivider = 0x00;
000010  46b1              MOV      r9,r6
;;;187      uint32_t usartxbase = 0;
000012  2700              MOVS     r7,#0
;;;188      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;189      /* Check the parameters */
;;;190      assert_param(IS_USART_ALL_PERIPH(USARTx));
000014  486b              LDR      r0,|L12.452|
000016  4285              CMP      r5,r0
000018  d00b              BEQ      |L12.50|
00001a  486b              LDR      r0,|L12.456|
00001c  4285              CMP      r5,r0
00001e  d008              BEQ      |L12.50|
000020  486a              LDR      r0,|L12.460|
000022  4285              CMP      r5,r0
000024  d005              BEQ      |L12.50|
000026  486a              LDR      r0,|L12.464|
000028  4285              CMP      r5,r0
00002a  d002              BEQ      |L12.50|
00002c  4869              LDR      r0,|L12.468|
00002e  4285              CMP      r5,r0
000030  d100              BNE      |L12.52|
                  |L12.50|
000032  e003              B        |L12.60|
                  |L12.52|
000034  21be              MOVS     r1,#0xbe
000036  4868              LDR      r0,|L12.472|
000038  f7fffffe          BL       assert_failed
                  |L12.60|
;;;191      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
00003c  6820              LDR      r0,[r4,#0]
00003e  b120              CBZ      r0,|L12.74|
000040  4966              LDR      r1,|L12.476|
000042  6820              LDR      r0,[r4,#0]
000044  4288              CMP      r0,r1
000046  d200              BCS      |L12.74|
000048  e003              B        |L12.82|
                  |L12.74|
00004a  21bf              MOVS     r1,#0xbf
00004c  4862              LDR      r0,|L12.472|
00004e  f7fffffe          BL       assert_failed
                  |L12.82|
;;;192      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
000052  88a0              LDRH     r0,[r4,#4]
000054  b118              CBZ      r0,|L12.94|
000056  88a0              LDRH     r0,[r4,#4]
000058  f5b05f80          CMP      r0,#0x1000
00005c  d100              BNE      |L12.96|
                  |L12.94|
00005e  e003              B        |L12.104|
                  |L12.96|
000060  21c0              MOVS     r1,#0xc0
000062  485d              LDR      r0,|L12.472|
000064  f7fffffe          BL       assert_failed
                  |L12.104|
;;;193      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
000068  88e0              LDRH     r0,[r4,#6]
00006a  b158              CBZ      r0,|L12.132|
00006c  88e0              LDRH     r0,[r4,#6]
00006e  f5b05f80          CMP      r0,#0x1000
000072  d007              BEQ      |L12.132|
000074  88e0              LDRH     r0,[r4,#6]
000076  f5b05f00          CMP      r0,#0x2000
00007a  d003              BEQ      |L12.132|
00007c  88e0              LDRH     r0,[r4,#6]
00007e  f5b05f40          CMP      r0,#0x3000
000082  d100              BNE      |L12.134|
                  |L12.132|
000084  e003              B        |L12.142|
                  |L12.134|
000086  21c1              MOVS     r1,#0xc1
000088  4853              LDR      r0,|L12.472|
00008a  f7fffffe          BL       assert_failed
                  |L12.142|
;;;194      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
00008e  8920              LDRH     r0,[r4,#8]
000090  b138              CBZ      r0,|L12.162|
000092  8920              LDRH     r0,[r4,#8]
000094  f5b06f80          CMP      r0,#0x400
000098  d003              BEQ      |L12.162|
00009a  8920              LDRH     r0,[r4,#8]
00009c  f5b06fc0          CMP      r0,#0x600
0000a0  d100              BNE      |L12.164|
                  |L12.162|
0000a2  e003              B        |L12.172|
                  |L12.164|
0000a4  21c2              MOVS     r1,#0xc2
0000a6  484c              LDR      r0,|L12.472|
0000a8  f7fffffe          BL       assert_failed
                  |L12.172|
;;;195      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
0000ac  8960              LDRH     r0,[r4,#0xa]
0000ae  f64f71f3          MOV      r1,#0xfff3
0000b2  4008              ANDS     r0,r0,r1
0000b4  b910              CBNZ     r0,|L12.188|
0000b6  8960              LDRH     r0,[r4,#0xa]
0000b8  b100              CBZ      r0,|L12.188|
0000ba  e003              B        |L12.196|
                  |L12.188|
0000bc  21c3              MOVS     r1,#0xc3
0000be  4846              LDR      r0,|L12.472|
0000c0  f7fffffe          BL       assert_failed
                  |L12.196|
;;;196      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
0000c4  89a0              LDRH     r0,[r4,#0xc]
0000c6  b158              CBZ      r0,|L12.224|
0000c8  89a0              LDRH     r0,[r4,#0xc]
0000ca  f5b07f80          CMP      r0,#0x100
0000ce  d007              BEQ      |L12.224|
0000d0  89a0              LDRH     r0,[r4,#0xc]
0000d2  f5b07f00          CMP      r0,#0x200
0000d6  d003              BEQ      |L12.224|
0000d8  89a0              LDRH     r0,[r4,#0xc]
0000da  f5b07f40          CMP      r0,#0x300
0000de  d100              BNE      |L12.226|
                  |L12.224|
0000e0  e003              B        |L12.234|
                  |L12.226|
0000e2  21c4              MOVS     r1,#0xc4
0000e4  483c              LDR      r0,|L12.472|
0000e6  f7fffffe          BL       assert_failed
                  |L12.234|
;;;197      /* The hardware flow control is available only for USART1, USART2 and USART3 */
;;;198      if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
0000ea  89a0              LDRH     r0,[r4,#0xc]
0000ec  b168              CBZ      r0,|L12.266|
;;;199      {
;;;200        assert_param(IS_USART_123_PERIPH(USARTx));
0000ee  4835              LDR      r0,|L12.452|
0000f0  4285              CMP      r5,r0
0000f2  d005              BEQ      |L12.256|
0000f4  4834              LDR      r0,|L12.456|
0000f6  4285              CMP      r5,r0
0000f8  d002              BEQ      |L12.256|
0000fa  4834              LDR      r0,|L12.460|
0000fc  4285              CMP      r5,r0
0000fe  d100              BNE      |L12.258|
                  |L12.256|
000100  e003              B        |L12.266|
                  |L12.258|
000102  21c8              MOVS     r1,#0xc8
000104  4834              LDR      r0,|L12.472|
000106  f7fffffe          BL       assert_failed
                  |L12.266|
;;;201      }
;;;202    
;;;203      usartxbase = (uint32_t)USARTx;
00010a  462f              MOV      r7,r5
;;;204    
;;;205    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;206      tmpreg = USARTx->CR2;
00010c  8a2e              LDRH     r6,[r5,#0x10]
;;;207      /* Clear STOP[13:12] bits */
;;;208      tmpreg &= CR2_STOP_CLEAR_Mask;
00010e  f64c70ff          MOV      r0,#0xcfff
000112  4006              ANDS     r6,r6,r0
;;;209      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;210      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;211      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
000114  88e0              LDRH     r0,[r4,#6]
000116  4306              ORRS     r6,r6,r0
;;;212      
;;;213      /* Write to USART CR2 */
;;;214      USARTx->CR2 = (uint16_t)tmpreg;
000118  822e              STRH     r6,[r5,#0x10]
;;;215    
;;;216    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;217      tmpreg = USARTx->CR1;
00011a  89ae              LDRH     r6,[r5,#0xc]
;;;218      /* Clear M, PCE, PS, TE and RE bits */
;;;219      tmpreg &= CR1_CLEAR_Mask;
00011c  f64e10f3          MOV      r0,#0xe9f3
000120  4006              ANDS     r6,r6,r0
;;;220      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;221      /* Set the M bits according to USART_WordLength value */
;;;222      /* Set PCE and PS bits according to USART_Parity value */
;;;223      /* Set TE and RE bits according to USART_Mode value */
;;;224      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
000122  88a0              LDRH     r0,[r4,#4]
000124  8921              LDRH     r1,[r4,#8]
000126  4308              ORRS     r0,r0,r1
000128  8961              LDRH     r1,[r4,#0xa]
00012a  4308              ORRS     r0,r0,r1
00012c  4306              ORRS     r6,r6,r0
;;;225                USART_InitStruct->USART_Mode;
;;;226      /* Write to USART CR1 */
;;;227      USARTx->CR1 = (uint16_t)tmpreg;
00012e  81ae              STRH     r6,[r5,#0xc]
;;;228    
;;;229    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;230      tmpreg = USARTx->CR3;
000130  8aae              LDRH     r6,[r5,#0x14]
;;;231      /* Clear CTSE and RTSE bits */
;;;232      tmpreg &= CR3_CLEAR_Mask;
000132  f64f40ff          MOV      r0,#0xfcff
000136  4006              ANDS     r6,r6,r0
;;;233      /* Configure the USART HFC -------------------------------------------------*/
;;;234      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;235      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000138  89a0              LDRH     r0,[r4,#0xc]
00013a  4306              ORRS     r6,r6,r0
;;;236      /* Write to USART CR3 */
;;;237      USARTx->CR3 = (uint16_t)tmpreg;
00013c  82ae              STRH     r6,[r5,#0x14]
;;;238    
;;;239    /*---------------------------- USART BRR Configuration -----------------------*/
;;;240      /* Configure the USART Baud Rate -------------------------------------------*/
;;;241      RCC_GetClocksFreq(&RCC_ClocksStatus);
00013e  a801              ADD      r0,sp,#4
000140  f7fffffe          BL       RCC_GetClocksFreq
;;;242      if (usartxbase == USART1_BASE)
000144  481f              LDR      r0,|L12.452|
000146  4287              CMP      r7,r0
000148  d102              BNE      |L12.336|
;;;243      {
;;;244        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
00014a  f8dda010          LDR      r10,[sp,#0x10]
00014e  e001              B        |L12.340|
                  |L12.336|
;;;245      }
;;;246      else
;;;247      {
;;;248        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
000150  f8dda00c          LDR      r10,[sp,#0xc]
                  |L12.340|
;;;249      }
;;;250      
;;;251      /* Determine the integer part */
;;;252      if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
000154  89a8              LDRH     r0,[r5,#0xc]
000156  f4004000          AND      r0,r0,#0x8000
00015a  b140              CBZ      r0,|L12.366|
;;;253      {
;;;254        /* Integer part computing in case Oversampling mode is 8 Samples */
;;;255        integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
00015c  eb0a00ca          ADD      r0,r10,r10,LSL #3
000160  eb00100a          ADD      r0,r0,r10,LSL #4
000164  6821              LDR      r1,[r4,#0]
000166  0049              LSLS     r1,r1,#1
000168  fbb0f8f1          UDIV     r8,r0,r1
00016c  e007              B        |L12.382|
                  |L12.366|
;;;256      }
;;;257      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;258      {
;;;259        /* Integer part computing in case Oversampling mode is 16 Samples */
;;;260        integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
00016e  eb0a00ca          ADD      r0,r10,r10,LSL #3
000172  eb00100a          ADD      r0,r0,r10,LSL #4
000176  6821              LDR      r1,[r4,#0]
000178  0089              LSLS     r1,r1,#2
00017a  fbb0f8f1          UDIV     r8,r0,r1
                  |L12.382|
;;;261      }
;;;262      tmpreg = (integerdivider / 100) << 4;
00017e  2064              MOVS     r0,#0x64
000180  fbb8f0f0          UDIV     r0,r8,r0
000184  0106              LSLS     r6,r0,#4
;;;263    
;;;264      /* Determine the fractional part */
;;;265      fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
000186  0930              LSRS     r0,r6,#4
000188  2164              MOVS     r1,#0x64
00018a  fb018910          MLS      r9,r1,r0,r8
;;;266    
;;;267      /* Implement the fractional part in the register */
;;;268      if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
00018e  89a8              LDRH     r0,[r5,#0xc]
000190  f4004000          AND      r0,r0,#0x8000
000194  b140              CBZ      r0,|L12.424|
;;;269      {
;;;270        tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
000196  2032              MOVS     r0,#0x32
000198  eb0000c9          ADD      r0,r0,r9,LSL #3
00019c  fbb0f0f1          UDIV     r0,r0,r1
0001a0  f0000007          AND      r0,r0,#7
0001a4  4306              ORRS     r6,r6,r0
0001a6  e008              B        |L12.442|
                  |L12.424|
;;;271      }
;;;272      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;273      {
;;;274        tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
0001a8  2032              MOVS     r0,#0x32
0001aa  eb001009          ADD      r0,r0,r9,LSL #4
0001ae  2164              MOVS     r1,#0x64
0001b0  fbb0f0f1          UDIV     r0,r0,r1
0001b4  f000000f          AND      r0,r0,#0xf
0001b8  4306              ORRS     r6,r6,r0
                  |L12.442|
;;;275      }
;;;276      
;;;277      /* Write to USART BRR */
;;;278      USARTx->BRR = (uint16_t)tmpreg;
0001ba  812e              STRH     r6,[r5,#8]
;;;279    }
0001bc  b006              ADD      sp,sp,#0x18
0001be  e8bd87f0          POP      {r4-r10,pc}
;;;280    
                          ENDP

0001c2  0000              DCW      0x0000
                  |L12.452|
                          DCD      0x40013800
                  |L12.456|
                          DCD      0x40004400
                  |L12.460|
                          DCD      0x40004800
                  |L12.464|
                          DCD      0x40004c00
                  |L12.468|
                          DCD      0x40005000
                  |L12.472|
                          DCD      ||.conststring||
                  |L12.476|
                          DCD      0x0044aa21

                          AREA ||i.USART_IrDACmd||, CODE, READONLY, ALIGN=2

                  USART_IrDACmd PROC
;;;842      */
;;;843    void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;844    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;845      /* Check the parameters */
;;;846      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4815              LDR      r0,|L13.92|
000008  4284              CMP      r4,r0
00000a  d00b              BEQ      |L13.36|
00000c  4814              LDR      r0,|L13.96|
00000e  4284              CMP      r4,r0
000010  d008              BEQ      |L13.36|
000012  4814              LDR      r0,|L13.100|
000014  4284              CMP      r4,r0
000016  d005              BEQ      |L13.36|
000018  4813              LDR      r0,|L13.104|
00001a  4284              CMP      r4,r0
00001c  d002              BEQ      |L13.36|
00001e  4813              LDR      r0,|L13.108|
000020  4284              CMP      r4,r0
000022  d100              BNE      |L13.38|
                  |L13.36|
000024  e004              B        |L13.48|
                  |L13.38|
000026  f240314e          MOV      r1,#0x34e
00002a  4811              LDR      r0,|L13.112|
00002c  f7fffffe          BL       assert_failed
                  |L13.48|
;;;847      assert_param(IS_FUNCTIONAL_STATE(NewState));
000030  b10d              CBZ      r5,|L13.54|
000032  2d01              CMP      r5,#1
000034  d100              BNE      |L13.56|
                  |L13.54|
000036  e004              B        |L13.66|
                  |L13.56|
000038  f240314f          MOV      r1,#0x34f
00003c  480c              LDR      r0,|L13.112|
00003e  f7fffffe          BL       assert_failed
                  |L13.66|
;;;848        
;;;849      if (NewState != DISABLE)
000042  b125              CBZ      r5,|L13.78|
;;;850      {
;;;851        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;852        USARTx->CR3 |= CR3_IREN_Set;
000044  8aa0              LDRH     r0,[r4,#0x14]
000046  f0400002          ORR      r0,r0,#2
00004a  82a0              STRH     r0,[r4,#0x14]
00004c  e004              B        |L13.88|
                  |L13.78|
;;;853      }
;;;854      else
;;;855      {
;;;856        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;857        USARTx->CR3 &= CR3_IREN_Reset;
00004e  8aa0              LDRH     r0,[r4,#0x14]
000050  f64f71fd          MOV      r1,#0xfffd
000054  4008              ANDS     r0,r0,r1
000056  82a0              STRH     r0,[r4,#0x14]
                  |L13.88|
;;;858      }
;;;859    }
000058  bd70              POP      {r4-r6,pc}
;;;860    
                          ENDP

00005a  0000              DCW      0x0000
                  |L13.92|
                          DCD      0x40013800
                  |L13.96|
                          DCD      0x40004400
                  |L13.100|
                          DCD      0x40004800
                  |L13.104|
                          DCD      0x40004c00
                  |L13.108|
                          DCD      0x40005000
                  |L13.112|
                          DCD      ||.conststring||

                          AREA ||i.USART_IrDAConfig||, CODE, READONLY, ALIGN=2

                  USART_IrDAConfig PROC
;;;823      */
;;;824    void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
000000  b570              PUSH     {r4-r6,lr}
;;;825    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;826      /* Check the parameters */
;;;827      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4813              LDR      r0,|L14.84|
000008  4284              CMP      r4,r0
00000a  d00b              BEQ      |L14.36|
00000c  4812              LDR      r0,|L14.88|
00000e  4284              CMP      r4,r0
000010  d008              BEQ      |L14.36|
000012  4812              LDR      r0,|L14.92|
000014  4284              CMP      r4,r0
000016  d005              BEQ      |L14.36|
000018  4811              LDR      r0,|L14.96|
00001a  4284              CMP      r4,r0
00001c  d002              BEQ      |L14.36|
00001e  4811              LDR      r0,|L14.100|
000020  4284              CMP      r4,r0
000022  d100              BNE      |L14.38|
                  |L14.36|
000024  e004              B        |L14.48|
                  |L14.38|
000026  f240313b          MOV      r1,#0x33b
00002a  480f              LDR      r0,|L14.104|
00002c  f7fffffe          BL       assert_failed
                  |L14.48|
;;;828      assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
000030  2d04              CMP      r5,#4
000032  d000              BEQ      |L14.54|
000034  b905              CBNZ     r5,|L14.56|
                  |L14.54|
000036  e004              B        |L14.66|
                  |L14.56|
000038  f44f714f          MOV      r1,#0x33c
00003c  480a              LDR      r0,|L14.104|
00003e  f7fffffe          BL       assert_failed
                  |L14.66|
;;;829        
;;;830      USARTx->CR3 &= CR3_IRLP_Mask;
000042  8aa0              LDRH     r0,[r4,#0x14]
000044  f64f71fb          MOV      r1,#0xfffb
000048  4008              ANDS     r0,r0,r1
00004a  82a0              STRH     r0,[r4,#0x14]
;;;831      USARTx->CR3 |= USART_IrDAMode;
00004c  8aa0              LDRH     r0,[r4,#0x14]
00004e  4328              ORRS     r0,r0,r5
000050  82a0              STRH     r0,[r4,#0x14]
;;;832    }
000052  bd70              POP      {r4-r6,pc}
;;;833    
                          ENDP

                  |L14.84|
                          DCD      0x40013800
                  |L14.88|
                          DCD      0x40004400
                  |L14.92|
                          DCD      0x40004800
                  |L14.96|
                          DCD      0x40004c00
                  |L14.100|
                          DCD      0x40005000
                  |L14.104|
                          DCD      ||.conststring||

                          AREA ||i.USART_LINBreakDetectLengthConfig||, CODE, READONLY, ALIGN=2

                  USART_LINBreakDetectLengthConfig PROC
;;;552      */
;;;553    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;554    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;555      /* Check the parameters */
;;;556      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4813              LDR      r0,|L15.84|
000008  4284              CMP      r4,r0
00000a  d00b              BEQ      |L15.36|
00000c  4812              LDR      r0,|L15.88|
00000e  4284              CMP      r4,r0
000010  d008              BEQ      |L15.36|
000012  4812              LDR      r0,|L15.92|
000014  4284              CMP      r4,r0
000016  d005              BEQ      |L15.36|
000018  4811              LDR      r0,|L15.96|
00001a  4284              CMP      r4,r0
00001c  d002              BEQ      |L15.36|
00001e  4811              LDR      r0,|L15.100|
000020  4284              CMP      r4,r0
000022  d100              BNE      |L15.38|
                  |L15.36|
000024  e004              B        |L15.48|
                  |L15.38|
000026  f44f710b          MOV      r1,#0x22c
00002a  480f              LDR      r0,|L15.104|
00002c  f7fffffe          BL       assert_failed
                  |L15.48|
;;;557      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
000030  b10d              CBZ      r5,|L15.54|
000032  2d20              CMP      r5,#0x20
000034  d100              BNE      |L15.56|
                  |L15.54|
000036  e004              B        |L15.66|
                  |L15.56|
000038  f240212d          MOV      r1,#0x22d
00003c  480a              LDR      r0,|L15.104|
00003e  f7fffffe          BL       assert_failed
                  |L15.66|
;;;558      
;;;559      USARTx->CR2 &= CR2_LBDL_Mask;
000042  8a20              LDRH     r0,[r4,#0x10]
000044  f64f71df          MOV      r1,#0xffdf
000048  4008              ANDS     r0,r0,r1
00004a  8220              STRH     r0,[r4,#0x10]
;;;560      USARTx->CR2 |= USART_LINBreakDetectLength;  
00004c  8a20              LDRH     r0,[r4,#0x10]
00004e  4328              ORRS     r0,r0,r5
000050  8220              STRH     r0,[r4,#0x10]
;;;561    }
000052  bd70              POP      {r4-r6,pc}
;;;562    
                          ENDP

                  |L15.84|
                          DCD      0x40013800
                  |L15.88|
                          DCD      0x40004400
                  |L15.92|
                          DCD      0x40004800
                  |L15.96|
                          DCD      0x40004c00
                  |L15.100|
                          DCD      0x40005000
                  |L15.104|
                          DCD      ||.conststring||

                          AREA ||i.USART_LINCmd||, CODE, READONLY, ALIGN=2

                  USART_LINCmd PROC
;;;571      */
;;;572    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;573    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;574      /* Check the parameters */
;;;575      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4815              LDR      r0,|L16.92|
000008  4284              CMP      r4,r0
00000a  d00b              BEQ      |L16.36|
00000c  4814              LDR      r0,|L16.96|
00000e  4284              CMP      r4,r0
000010  d008              BEQ      |L16.36|
000012  4814              LDR      r0,|L16.100|
000014  4284              CMP      r4,r0
000016  d005              BEQ      |L16.36|
000018  4813              LDR      r0,|L16.104|
00001a  4284              CMP      r4,r0
00001c  d002              BEQ      |L16.36|
00001e  4813              LDR      r0,|L16.108|
000020  4284              CMP      r4,r0
000022  d100              BNE      |L16.38|
                  |L16.36|
000024  e004              B        |L16.48|
                  |L16.38|
000026  f240213f          MOV      r1,#0x23f
00002a  4811              LDR      r0,|L16.112|
00002c  f7fffffe          BL       assert_failed
                  |L16.48|
;;;576      assert_param(IS_FUNCTIONAL_STATE(NewState));
000030  b10d              CBZ      r5,|L16.54|
000032  2d01              CMP      r5,#1
000034  d100              BNE      |L16.56|
                  |L16.54|
000036  e004              B        |L16.66|
                  |L16.56|
000038  f44f7110          MOV      r1,#0x240
00003c  480c              LDR      r0,|L16.112|
00003e  f7fffffe          BL       assert_failed
                  |L16.66|
;;;577      
;;;578      if (NewState != DISABLE)
000042  b125              CBZ      r5,|L16.78|
;;;579      {
;;;580        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;581        USARTx->CR2 |= CR2_LINEN_Set;
000044  8a20              LDRH     r0,[r4,#0x10]
000046  f4404080          ORR      r0,r0,#0x4000
00004a  8220              STRH     r0,[r4,#0x10]
00004c  e004              B        |L16.88|
                  |L16.78|
;;;582      }
;;;583      else
;;;584      {
;;;585        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;586        USARTx->CR2 &= CR2_LINEN_Reset;
00004e  8a20              LDRH     r0,[r4,#0x10]
000050  f64b71ff          MOV      r1,#0xbfff
000054  4008              ANDS     r0,r0,r1
000056  8220              STRH     r0,[r4,#0x10]
                  |L16.88|
;;;587      }
;;;588    }
000058  bd70              POP      {r4-r6,pc}
;;;589    
                          ENDP

00005a  0000              DCW      0x0000
                  |L16.92|
                          DCD      0x40013800
                  |L16.96|
                          DCD      0x40004400
                  |L16.100|
                          DCD      0x40004800
                  |L16.104|
                          DCD      0x40004c00
                  |L16.108|
                          DCD      0x40005000
                  |L16.112|
                          DCD      ||.conststring||

                          AREA ||i.USART_OneBitMethodCmd||, CODE, READONLY, ALIGN=2

                  USART_OneBitMethodCmd PROC
;;;794      */
;;;795    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;796    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;797      /* Check the parameters */
;;;798      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4815              LDR      r0,|L17.92|
000008  4284              CMP      r4,r0
00000a  d00b              BEQ      |L17.36|
00000c  4814              LDR      r0,|L17.96|
00000e  4284              CMP      r4,r0
000010  d008              BEQ      |L17.36|
000012  4814              LDR      r0,|L17.100|
000014  4284              CMP      r4,r0
000016  d005              BEQ      |L17.36|
000018  4813              LDR      r0,|L17.104|
00001a  4284              CMP      r4,r0
00001c  d002              BEQ      |L17.36|
00001e  4813              LDR      r0,|L17.108|
000020  4284              CMP      r4,r0
000022  d100              BNE      |L17.38|
                  |L17.36|
000024  e004              B        |L17.48|
                  |L17.38|
000026  f240311e          MOV      r1,#0x31e
00002a  4811              LDR      r0,|L17.112|
00002c  f7fffffe          BL       assert_failed
                  |L17.48|
;;;799      assert_param(IS_FUNCTIONAL_STATE(NewState));
000030  b10d              CBZ      r5,|L17.54|
000032  2d01              CMP      r5,#1
000034  d100              BNE      |L17.56|
                  |L17.54|
000036  e004              B        |L17.66|
                  |L17.56|
000038  f240311f          MOV      r1,#0x31f
00003c  480c              LDR      r0,|L17.112|
00003e  f7fffffe          BL       assert_failed
                  |L17.66|
;;;800      
;;;801      if (NewState != DISABLE)
000042  b125              CBZ      r5,|L17.78|
;;;802      {
;;;803        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;804        USARTx->CR3 |= CR3_ONEBITE_Set;
000044  8aa0              LDRH     r0,[r4,#0x14]
000046  f4406000          ORR      r0,r0,#0x800
00004a  82a0              STRH     r0,[r4,#0x14]
00004c  e004              B        |L17.88|
                  |L17.78|
;;;805      }
;;;806      else
;;;807      {
;;;808        /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */
;;;809        USARTx->CR3 &= CR3_ONEBITE_Reset;
00004e  8aa0              LDRH     r0,[r4,#0x14]
000050  f24f71ff          MOV      r1,#0xf7ff
000054  4008              ANDS     r0,r0,r1
000056  82a0              STRH     r0,[r4,#0x14]
                  |L17.88|
;;;810      }
;;;811    }
000058  bd70              POP      {r4-r6,pc}
;;;812    
                          ENDP

00005a  0000              DCW      0x0000
                  |L17.92|
                          DCD      0x40013800
                  |L17.96|
                          DCD      0x40004400
                  |L17.100|
                          DCD      0x40004800
                  |L17.104|
                          DCD      0x40004c00
                  |L17.108|
                          DCD      0x40005000
                  |L17.112|
                          DCD      ||.conststring||

                          AREA ||i.USART_OverSampling8Cmd||, CODE, READONLY, ALIGN=2

                  USART_OverSampling8Cmd PROC
;;;767      */
;;;768    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;769    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;770      /* Check the parameters */
;;;771      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4814              LDR      r0,|L18.88|
000008  4284              CMP      r4,r0
00000a  d00b              BEQ      |L18.36|
00000c  4813              LDR      r0,|L18.92|
00000e  4284              CMP      r4,r0
000010  d008              BEQ      |L18.36|
000012  4813              LDR      r0,|L18.96|
000014  4284              CMP      r4,r0
000016  d005              BEQ      |L18.36|
000018  4812              LDR      r0,|L18.100|
00001a  4284              CMP      r4,r0
00001c  d002              BEQ      |L18.36|
00001e  4812              LDR      r0,|L18.104|
000020  4284              CMP      r4,r0
000022  d100              BNE      |L18.38|
                  |L18.36|
000024  e004              B        |L18.48|
                  |L18.38|
000026  f2403103          MOV      r1,#0x303
00002a  4810              LDR      r0,|L18.108|
00002c  f7fffffe          BL       assert_failed
                  |L18.48|
;;;772      assert_param(IS_FUNCTIONAL_STATE(NewState));
000030  b10d              CBZ      r5,|L18.54|
000032  2d01              CMP      r5,#1
000034  d100              BNE      |L18.56|
                  |L18.54|
000036  e004              B        |L18.66|
                  |L18.56|
000038  f44f7141          MOV      r1,#0x304
00003c  480b              LDR      r0,|L18.108|
00003e  f7fffffe          BL       assert_failed
                  |L18.66|
;;;773      
;;;774      if (NewState != DISABLE)
000042  b125              CBZ      r5,|L18.78|
;;;775      {
;;;776        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;777        USARTx->CR1 |= CR1_OVER8_Set;
000044  89a0              LDRH     r0,[r4,#0xc]
000046  f4404000          ORR      r0,r0,#0x8000
00004a  81a0              STRH     r0,[r4,#0xc]
00004c  e003              B        |L18.86|
                  |L18.78|
;;;778      }
;;;779      else
;;;780      {
;;;781        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;782        USARTx->CR1 &= CR1_OVER8_Reset;
00004e  89a0              LDRH     r0,[r4,#0xc]
000050  f3c0000e          UBFX     r0,r0,#0,#15
000054  81a0              STRH     r0,[r4,#0xc]
                  |L18.86|
;;;783      }
;;;784    }
000056  bd70              POP      {r4-r6,pc}
;;;785    
                          ENDP

                  |L18.88|
                          DCD      0x40013800
                  |L18.92|
                          DCD      0x40004400
                  |L18.96|
                          DCD      0x40004800
                  |L18.100|
                          DCD      0x40004c00
                  |L18.104|
                          DCD      0x40005000
                  |L18.108|
                          DCD      ||.conststring||

                          AREA ||i.USART_ReceiveData||, CODE, READONLY, ALIGN=2

                  USART_ReceiveData PROC
;;;614      */
;;;615    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;616    {
000002  4604              MOV      r4,r0
;;;617      /* Check the parameters */
;;;618      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  480c              LDR      r0,|L19.56|
000006  4284              CMP      r4,r0
000008  d00b              BEQ      |L19.34|
00000a  480c              LDR      r0,|L19.60|
00000c  4284              CMP      r4,r0
00000e  d008              BEQ      |L19.34|
000010  480b              LDR      r0,|L19.64|
000012  4284              CMP      r4,r0
000014  d005              BEQ      |L19.34|
000016  480b              LDR      r0,|L19.68|
000018  4284              CMP      r4,r0
00001a  d002              BEQ      |L19.34|
00001c  480a              LDR      r0,|L19.72|
00001e  4284              CMP      r4,r0
000020  d100              BNE      |L19.36|
                  |L19.34|
000022  e004              B        |L19.46|
                  |L19.36|
000024  f240216a          MOV      r1,#0x26a
000028  4808              LDR      r0,|L19.76|
00002a  f7fffffe          BL       assert_failed
                  |L19.46|
;;;619      
;;;620      /* Receive Data */
;;;621      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
00002e  88a0              LDRH     r0,[r4,#4]
000030  f3c00008          UBFX     r0,r0,#0,#9
;;;622    }
000034  bd10              POP      {r4,pc}
;;;623    
                          ENDP

000036  0000              DCW      0x0000
                  |L19.56|
                          DCD      0x40013800
                  |L19.60|
                          DCD      0x40004400
                  |L19.64|
                          DCD      0x40004800
                  |L19.68|
                          DCD      0x40004c00
                  |L19.72|
                          DCD      0x40005000
                  |L19.76|
                          DCD      ||.conststring||

                          AREA ||i.USART_ReceiverWakeUpCmd||, CODE, READONLY, ALIGN=2

                  USART_ReceiverWakeUpCmd PROC
;;;523      */
;;;524    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;525    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;526      /* Check the parameters */
;;;527      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4815              LDR      r0,|L20.92|
000008  4284              CMP      r4,r0
00000a  d00b              BEQ      |L20.36|
00000c  4814              LDR      r0,|L20.96|
00000e  4284              CMP      r4,r0
000010  d008              BEQ      |L20.36|
000012  4814              LDR      r0,|L20.100|
000014  4284              CMP      r4,r0
000016  d005              BEQ      |L20.36|
000018  4813              LDR      r0,|L20.104|
00001a  4284              CMP      r4,r0
00001c  d002              BEQ      |L20.36|
00001e  4813              LDR      r0,|L20.108|
000020  4284              CMP      r4,r0
000022  d100              BNE      |L20.38|
                  |L20.36|
000024  e004              B        |L20.48|
                  |L20.38|
000026  f240210f          MOV      r1,#0x20f
00002a  4811              LDR      r0,|L20.112|
00002c  f7fffffe          BL       assert_failed
                  |L20.48|
;;;528      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
000030  b10d              CBZ      r5,|L20.54|
000032  2d01              CMP      r5,#1
000034  d100              BNE      |L20.56|
                  |L20.54|
000036  e004              B        |L20.66|
                  |L20.56|
000038  f44f7104          MOV      r1,#0x210
00003c  480c              LDR      r0,|L20.112|
00003e  f7fffffe          BL       assert_failed
                  |L20.66|
;;;529      
;;;530      if (NewState != DISABLE)
000042  b125              CBZ      r5,|L20.78|
;;;531      {
;;;532        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;533        USARTx->CR1 |= CR1_RWU_Set;
000044  89a0              LDRH     r0,[r4,#0xc]
000046  f0400002          ORR      r0,r0,#2
00004a  81a0              STRH     r0,[r4,#0xc]
00004c  e004              B        |L20.88|
                  |L20.78|
;;;534      }
;;;535      else
;;;536      {
;;;537        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;538        USARTx->CR1 &= CR1_RWU_Reset;
00004e  89a0              LDRH     r0,[r4,#0xc]
000050  f64f71fd          MOV      r1,#0xfffd
000054  4008              ANDS     r0,r0,r1
000056  81a0              STRH     r0,[r4,#0xc]
                  |L20.88|
;;;539      }
;;;540    }
000058  bd70              POP      {r4-r6,pc}
;;;541    
                          ENDP

00005a  0000              DCW      0x0000
                  |L20.92|
                          DCD      0x40013800
                  |L20.96|
                          DCD      0x40004400
                  |L20.100|
                          DCD      0x40004800
                  |L20.104|
                          DCD      0x40004c00
                  |L20.108|
                          DCD      0x40005000
                  |L20.112|
                          DCD      ||.conststring||

                          AREA ||i.USART_SendBreak||, CODE, READONLY, ALIGN=2

                  USART_SendBreak PROC
;;;630      */
;;;631    void USART_SendBreak(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;632    {
000002  4604              MOV      r4,r0
;;;633      /* Check the parameters */
;;;634      assert_param(IS_USART_ALL_PERIPH(USARTx));
000004  480c              LDR      r0,|L21.56|
000006  4284              CMP      r4,r0
000008  d00b              BEQ      |L21.34|
00000a  480c              LDR      r0,|L21.60|
00000c  4284              CMP      r4,r0
00000e  d008              BEQ      |L21.34|
000010  480b              LDR      r0,|L21.64|
000012  4284              CMP      r4,r0
000014  d005              BEQ      |L21.34|
000016  480b              LDR      r0,|L21.68|
000018  4284              CMP      r4,r0
00001a  d002              BEQ      |L21.34|
00001c  480a              LDR      r0,|L21.72|
00001e  4284              CMP      r4,r0
000020  d100              BNE      |L21.36|
                  |L21.34|
000022  e004              B        |L21.46|
                  |L21.36|
000024  f240217a          MOV      r1,#0x27a
000028  4808              LDR      r0,|L21.76|
00002a  f7fffffe          BL       assert_failed
                  |L21.46|
;;;635      
;;;636      /* Send break characters */
;;;637      USARTx->CR1 |= CR1_SBK_Set;
00002e  89a0              LDRH     r0,[r4,#0xc]
000030  f0400001          ORR      r0,r0,#1
000034  81a0              STRH     r0,[r4,#0xc]
;;;638    }
000036  bd10              POP      {r4,pc}
;;;639    
                          ENDP

                  |L21.56|
                          DCD      0x40013800
                  |L21.60|
                          DCD      0x40004400
                  |L21.64|
                          DCD      0x40004800
                  |L21.68|
                          DCD      0x40004c00
                  |L21.72|
                          DCD      0x40005000
                  |L21.76|
                          DCD      ||.conststring||

                          AREA ||i.USART_SendData||, CODE, READONLY, ALIGN=2

                  USART_SendData PROC
;;;597      */
;;;598    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;599    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;600      /* Check the parameters */
;;;601      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4811              LDR      r0,|L22.76|
000008  4284              CMP      r4,r0
00000a  d00b              BEQ      |L22.36|
00000c  4810              LDR      r0,|L22.80|
00000e  4284              CMP      r4,r0
000010  d008              BEQ      |L22.36|
000012  4810              LDR      r0,|L22.84|
000014  4284              CMP      r4,r0
000016  d005              BEQ      |L22.36|
000018  480f              LDR      r0,|L22.88|
00001a  4284              CMP      r4,r0
00001c  d002              BEQ      |L22.36|
00001e  480f              LDR      r0,|L22.92|
000020  4284              CMP      r4,r0
000022  d100              BNE      |L22.38|
                  |L22.36|
000024  e004              B        |L22.48|
                  |L22.38|
000026  f2402159          MOV      r1,#0x259
00002a  480d              LDR      r0,|L22.96|
00002c  f7fffffe          BL       assert_failed
                  |L22.48|
;;;602      assert_param(IS_USART_DATA(Data)); 
000030  f5b57f00          CMP      r5,#0x200
000034  da00              BGE      |L22.56|
000036  e004              B        |L22.66|
                  |L22.56|
000038  f240215a          MOV      r1,#0x25a
00003c  4808              LDR      r0,|L22.96|
00003e  f7fffffe          BL       assert_failed
                  |L22.66|
;;;603        
;;;604      /* Transmit Data */
;;;605      USARTx->DR = (Data & (uint16_t)0x01FF);
000042  f3c50008          UBFX     r0,r5,#0,#9
000046  80a0              STRH     r0,[r4,#4]
;;;606    }
000048  bd70              POP      {r4-r6,pc}
;;;607    
                          ENDP

00004a  0000              DCW      0x0000
                  |L22.76|
                          DCD      0x40013800
                  |L22.80|
                          DCD      0x40004400
                  |L22.84|
                          DCD      0x40004800
                  |L22.88|
                          DCD      0x40004c00
                  |L22.92|
                          DCD      0x40005000
                  |L22.96|
                          DCD      ||.conststring||

                          AREA ||i.USART_SetAddress||, CODE, READONLY, ALIGN=2

                  USART_SetAddress PROC
;;;481      */
;;;482    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000000  b570              PUSH     {r4-r6,lr}
;;;483    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;484      /* Check the parameters */
;;;485      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4813              LDR      r0,|L23.84|
000008  4284              CMP      r4,r0
00000a  d00b              BEQ      |L23.36|
00000c  4812              LDR      r0,|L23.88|
00000e  4284              CMP      r4,r0
000010  d008              BEQ      |L23.36|
000012  4812              LDR      r0,|L23.92|
000014  4284              CMP      r4,r0
000016  d005              BEQ      |L23.36|
000018  4811              LDR      r0,|L23.96|
00001a  4284              CMP      r4,r0
00001c  d002              BEQ      |L23.36|
00001e  4811              LDR      r0,|L23.100|
000020  4284              CMP      r4,r0
000022  d100              BNE      |L23.38|
                  |L23.36|
000024  e004              B        |L23.48|
                  |L23.38|
000026  f24011e5          MOV      r1,#0x1e5
00002a  480f              LDR      r0,|L23.104|
00002c  f7fffffe          BL       assert_failed
                  |L23.48|
;;;486      assert_param(IS_USART_ADDRESS(USART_Address)); 
000030  2d0f              CMP      r5,#0xf
000032  dc00              BGT      |L23.54|
000034  e004              B        |L23.64|
                  |L23.54|
000036  f44f71f3          MOV      r1,#0x1e6
00003a  480b              LDR      r0,|L23.104|
00003c  f7fffffe          BL       assert_failed
                  |L23.64|
;;;487        
;;;488      /* Clear the USART address */
;;;489      USARTx->CR2 &= CR2_Address_Mask;
000040  8a20              LDRH     r0,[r4,#0x10]
000042  f64f71f0          MOV      r1,#0xfff0
000046  4008              ANDS     r0,r0,r1
000048  8220              STRH     r0,[r4,#0x10]
;;;490      /* Set the USART address node */
;;;491      USARTx->CR2 |= USART_Address;
00004a  8a20              LDRH     r0,[r4,#0x10]
00004c  4328              ORRS     r0,r0,r5
00004e  8220              STRH     r0,[r4,#0x10]
;;;492    }
000050  bd70              POP      {r4-r6,pc}
;;;493    
                          ENDP

000052  0000              DCW      0x0000
                  |L23.84|
                          DCD      0x40013800
                  |L23.88|
                          DCD      0x40004400
                  |L23.92|
                          DCD      0x40004800
                  |L23.96|
                          DCD      0x40004c00
                  |L23.100|
                          DCD      0x40005000
                  |L23.104|
                          DCD      ||.conststring||

                          AREA ||i.USART_SetGuardTime||, CODE, READONLY, ALIGN=2

                  USART_SetGuardTime PROC
;;;646      */
;;;647    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
000000  b570              PUSH     {r4-r6,lr}
;;;648    {    
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;649      /* Check the parameters */
;;;650      assert_param(IS_USART_123_PERIPH(USARTx));
000006  480b              LDR      r0,|L24.52|
000008  4284              CMP      r4,r0
00000a  d005              BEQ      |L24.24|
00000c  480a              LDR      r0,|L24.56|
00000e  4284              CMP      r4,r0
000010  d002              BEQ      |L24.24|
000012  480a              LDR      r0,|L24.60|
000014  4284              CMP      r4,r0
000016  d100              BNE      |L24.26|
                  |L24.24|
000018  e004              B        |L24.36|
                  |L24.26|
00001a  f240218a          MOV      r1,#0x28a
00001e  4808              LDR      r0,|L24.64|
000020  f7fffffe          BL       assert_failed
                  |L24.36|
;;;651      
;;;652      /* Clear the USART Guard time */
;;;653      USARTx->GTPR &= GTPR_LSB_Mask;
000024  8b20              LDRH     r0,[r4,#0x18]
000026  b2c0              UXTB     r0,r0
000028  8320              STRH     r0,[r4,#0x18]
;;;654      /* Set the USART guard time */
;;;655      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
00002a  8b20              LDRH     r0,[r4,#0x18]
00002c  ea402005          ORR      r0,r0,r5,LSL #8
000030  8320              STRH     r0,[r4,#0x18]
;;;656    }
000032  bd70              POP      {r4-r6,pc}
;;;657    
                          ENDP

                  |L24.52|
                          DCD      0x40013800
                  |L24.56|
                          DCD      0x40004400
                  |L24.60|
                          DCD      0x40004800
                  |L24.64|
                          DCD      ||.conststring||

                          AREA ||i.USART_SetPrescaler||, CODE, READONLY, ALIGN=2

                  USART_SetPrescaler PROC
;;;666      */
;;;667    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000000  b570              PUSH     {r4-r6,lr}
;;;668    { 
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;669      /* Check the parameters */
;;;670      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  480e              LDR      r0,|L25.64|
000008  4284              CMP      r4,r0
00000a  d00b              BEQ      |L25.36|
00000c  480d              LDR      r0,|L25.68|
00000e  4284              CMP      r4,r0
000010  d008              BEQ      |L25.36|
000012  480d              LDR      r0,|L25.72|
000014  4284              CMP      r4,r0
000016  d005              BEQ      |L25.36|
000018  480c              LDR      r0,|L25.76|
00001a  4284              CMP      r4,r0
00001c  d002              BEQ      |L25.36|
00001e  480c              LDR      r0,|L25.80|
000020  4284              CMP      r4,r0
000022  d100              BNE      |L25.38|
                  |L25.36|
000024  e004              B        |L25.48|
                  |L25.38|
000026  f240219e          MOV      r1,#0x29e
00002a  480a              LDR      r0,|L25.84|
00002c  f7fffffe          BL       assert_failed
                  |L25.48|
;;;671      
;;;672      /* Clear the USART prescaler */
;;;673      USARTx->GTPR &= GTPR_MSB_Mask;
000030  8b20              LDRH     r0,[r4,#0x18]
000032  f400407f          AND      r0,r0,#0xff00
000036  8320              STRH     r0,[r4,#0x18]
;;;674      /* Set the USART prescaler */
;;;675      USARTx->GTPR |= USART_Prescaler;
000038  8b20              LDRH     r0,[r4,#0x18]
00003a  4328              ORRS     r0,r0,r5
00003c  8320              STRH     r0,[r4,#0x18]
;;;676    }
00003e  bd70              POP      {r4-r6,pc}
;;;677    
                          ENDP

                  |L25.64|
                          DCD      0x40013800
                  |L25.68|
                          DCD      0x40004400
                  |L25.72|
                          DCD      0x40004800
                  |L25.76|
                          DCD      0x40004c00
                  |L25.80|
                          DCD      0x40005000
                  |L25.84|
                          DCD      ||.conststring||

                          AREA ||i.USART_SmartCardCmd||, CODE, READONLY, ALIGN=2

                  USART_SmartCardCmd PROC
;;;685      */
;;;686    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;687    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;688      /* Check the parameters */
;;;689      assert_param(IS_USART_123_PERIPH(USARTx));
000006  4812              LDR      r0,|L26.80|
000008  4284              CMP      r4,r0
00000a  d005              BEQ      |L26.24|
00000c  4811              LDR      r0,|L26.84|
00000e  4284              CMP      r4,r0
000010  d002              BEQ      |L26.24|
000012  4811              LDR      r0,|L26.88|
000014  4284              CMP      r4,r0
000016  d100              BNE      |L26.26|
                  |L26.24|
000018  e004              B        |L26.36|
                  |L26.26|
00001a  f24021b1          MOV      r1,#0x2b1
00001e  480f              LDR      r0,|L26.92|
000020  f7fffffe          BL       assert_failed
                  |L26.36|
;;;690      assert_param(IS_FUNCTIONAL_STATE(NewState));
000024  b10d              CBZ      r5,|L26.42|
000026  2d01              CMP      r5,#1
000028  d100              BNE      |L26.44|
                  |L26.42|
00002a  e004              B        |L26.54|
                  |L26.44|
00002c  f24021b2          MOV      r1,#0x2b2
000030  480a              LDR      r0,|L26.92|
000032  f7fffffe          BL       assert_failed
                  |L26.54|
;;;691      if (NewState != DISABLE)
000036  b125              CBZ      r5,|L26.66|
;;;692      {
;;;693        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;694        USARTx->CR3 |= CR3_SCEN_Set;
000038  8aa0              LDRH     r0,[r4,#0x14]
00003a  f0400020          ORR      r0,r0,#0x20
00003e  82a0              STRH     r0,[r4,#0x14]
000040  e004              B        |L26.76|
                  |L26.66|
;;;695      }
;;;696      else
;;;697      {
;;;698        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;699        USARTx->CR3 &= CR3_SCEN_Reset;
000042  8aa0              LDRH     r0,[r4,#0x14]
000044  f64f71df          MOV      r1,#0xffdf
000048  4008              ANDS     r0,r0,r1
00004a  82a0              STRH     r0,[r4,#0x14]
                  |L26.76|
;;;700      }
;;;701    }
00004c  bd70              POP      {r4-r6,pc}
;;;702    
                          ENDP

00004e  0000              DCW      0x0000
                  |L26.80|
                          DCD      0x40013800
                  |L26.84|
                          DCD      0x40004400
                  |L26.88|
                          DCD      0x40004800
                  |L26.92|
                          DCD      ||.conststring||

                          AREA ||i.USART_SmartCardNACKCmd||, CODE, READONLY, ALIGN=2

                  USART_SmartCardNACKCmd PROC
;;;710      */
;;;711    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;712    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;713      /* Check the parameters */
;;;714      assert_param(IS_USART_123_PERIPH(USARTx));  
000006  4812              LDR      r0,|L27.80|
000008  4284              CMP      r4,r0
00000a  d005              BEQ      |L27.24|
00000c  4811              LDR      r0,|L27.84|
00000e  4284              CMP      r4,r0
000010  d002              BEQ      |L27.24|
000012  4811              LDR      r0,|L27.88|
000014  4284              CMP      r4,r0
000016  d100              BNE      |L27.26|
                  |L27.24|
000018  e004              B        |L27.36|
                  |L27.26|
00001a  f24021ca          MOV      r1,#0x2ca
00001e  480f              LDR      r0,|L27.92|
000020  f7fffffe          BL       assert_failed
                  |L27.36|
;;;715      assert_param(IS_FUNCTIONAL_STATE(NewState));
000024  b10d              CBZ      r5,|L27.42|
000026  2d01              CMP      r5,#1
000028  d100              BNE      |L27.44|
                  |L27.42|
00002a  e004              B        |L27.54|
                  |L27.44|
00002c  f24021cb          MOV      r1,#0x2cb
000030  480a              LDR      r0,|L27.92|
000032  f7fffffe          BL       assert_failed
                  |L27.54|
;;;716      if (NewState != DISABLE)
000036  b125              CBZ      r5,|L27.66|
;;;717      {
;;;718        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;719        USARTx->CR3 |= CR3_NACK_Set;
000038  8aa0              LDRH     r0,[r4,#0x14]
00003a  f0400010          ORR      r0,r0,#0x10
00003e  82a0              STRH     r0,[r4,#0x14]
000040  e004              B        |L27.76|
                  |L27.66|
;;;720      }
;;;721      else
;;;722      {
;;;723        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;724        USARTx->CR3 &= CR3_NACK_Reset;
000042  8aa0              LDRH     r0,[r4,#0x14]
000044  f64f71ef          MOV      r1,#0xffef
000048  4008              ANDS     r0,r0,r1
00004a  82a0              STRH     r0,[r4,#0x14]
                  |L27.76|
;;;725      }
;;;726    }
00004c  bd70              POP      {r4-r6,pc}
;;;727    
                          ENDP

00004e  0000              DCW      0x0000
                  |L27.80|
                          DCD      0x40013800
                  |L27.84|
                          DCD      0x40004400
                  |L27.88|
                          DCD      0x40004800
                  |L27.92|
                          DCD      ||.conststring||

                          AREA ||i.USART_StructInit||, CODE, READONLY, ALIGN=1

                  USART_StructInit PROC
;;;286      */
;;;287    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;288    {
;;;289      /* USART_InitStruct members default value */
;;;290      USART_InitStruct->USART_BaudRate = 9600;
000004  6001              STR      r1,[r0,#0]
;;;291      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;292      USART_InitStruct->USART_StopBits = USART_StopBits_1;
00000a  80c1              STRH     r1,[r0,#6]
;;;293      USART_InitStruct->USART_Parity = USART_Parity_No ;
00000c  8101              STRH     r1,[r0,#8]
;;;294      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00000e  210c              MOVS     r1,#0xc
000010  8141              STRH     r1,[r0,#0xa]
;;;295      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000012  2100              MOVS     r1,#0
000014  8181              STRH     r1,[r0,#0xc]
;;;296    }
000016  4770              BX       lr
;;;297    
                          ENDP


                          AREA ||i.USART_WakeUpConfig||, CODE, READONLY, ALIGN=2

                  USART_WakeUpConfig PROC
;;;504      */
;;;505    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
000000  b570              PUSH     {r4-r6,lr}
;;;506    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;507      /* Check the parameters */
;;;508      assert_param(IS_USART_ALL_PERIPH(USARTx));
000006  4814              LDR      r0,|L29.88|
000008  4284              CMP      r4,r0
00000a  d00b              BEQ      |L29.36|
00000c  4813              LDR      r0,|L29.92|
00000e  4284              CMP      r4,r0
000010  d008              BEQ      |L29.36|
000012  4813              LDR      r0,|L29.96|
000014  4284              CMP      r4,r0
000016  d005              BEQ      |L29.36|
000018  4812              LDR      r0,|L29.100|
00001a  4284              CMP      r4,r0
00001c  d002              BEQ      |L29.36|
00001e  4812              LDR      r0,|L29.104|
000020  4284              CMP      r4,r0
000022  d100              BNE      |L29.38|
                  |L29.36|
000024  e004              B        |L29.48|
                  |L29.38|
000026  f44f71fe          MOV      r1,#0x1fc
00002a  4810              LDR      r0,|L29.108|
00002c  f7fffffe          BL       assert_failed
                  |L29.48|
;;;509      assert_param(IS_USART_WAKEUP(USART_WakeUp));
000030  b115              CBZ      r5,|L29.56|
000032  f5b56f00          CMP      r5,#0x800
000036  d100              BNE      |L29.58|
                  |L29.56|
000038  e004              B        |L29.68|
                  |L29.58|
00003a  f24011fd          MOV      r1,#0x1fd
00003e  480b              LDR      r0,|L29.108|
000040  f7fffffe          BL       assert_failed
                  |L29.68|
;;;510      
;;;511      USARTx->CR1 &= CR1_WAKE_Mask;
000044  89a0              LDRH     r0,[r4,#0xc]
000046  f24f71ff          MOV      r1,#0xf7ff
00004a  4008              ANDS     r0,r0,r1
00004c  81a0              STRH     r0,[r4,#0xc]
;;;512      USARTx->CR1 |= USART_WakeUp;
00004e  89a0              LDRH     r0,[r4,#0xc]
000050  4328              ORRS     r0,r0,r5
000052  81a0              STRH     r0,[r4,#0xc]
;;;513    }
000054  bd70              POP      {r4-r6,pc}
;;;514    
                          ENDP

000056  0000              DCW      0x0000
                  |L29.88|
                          DCD      0x40013800
                  |L29.92|
                          DCD      0x40004400
                  |L29.96|
                          DCD      0x40004800
                  |L29.100|
                          DCD      0x40004c00
                  |L29.104|
                          DCD      0x40005000
                  |L29.108|
                          DCD      ||.conststring||

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000004  2e5c4c69
000008  62726172
00000c  6965735c
000010  53544d33
000014  32463130
000018  785f5374
00001c  64506572
000020  6970685f
000024  44726976
000028  65725c73
00002c  72635c73
000030  746d    
000032  33326631          DCB      "32f10x_usart.c",0
000036  30785f75
00003a  73617274
00003e  2e6300  

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f10x_usart_c_9565154b____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32f10x_usart_c_9565154b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f10x_usart_c_9565154b____REVSH|
#line 128
|__asm___17_stm32f10x_usart_c_9565154b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
