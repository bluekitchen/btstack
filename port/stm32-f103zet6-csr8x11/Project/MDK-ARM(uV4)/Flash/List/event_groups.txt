; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\event_groups.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\event_groups.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\Middleware\blue_angel\inc -I..\..\Middleware\bt_callback_manager -I..\..\Middleware\blue_angel\btif -I..\..\Middleware\blue_angel\common -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\blue_angel\src\common -I..\..\Middleware\blue_angel\src\inc -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\blue_angel\platform\rtos -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\ut_manager\Cunit\Headers -I..\..\Middleware\ut_manager\Cunit\interface -I..\..\Middleware\blue_angel\platform\test -I..\..\Middleware\blue_angel\driver -I..\..\Middleware\blue_angel\src\core\hci -I..\..\User\bt\inc -I..\..\Middleware\bt_callback_manager -I..\..\Middleware\at_command -I..\..\Middleware\blue_angel\src\core\gap -I..\..\Middleware\blue_angel\src\core\l2cap -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=522 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DNDEBUG --omf_browse=.\flash\obj\event_groups.crf ..\..\FreeRTOS\event_groups.c]
                          THUMB

                          AREA ||i.prvTestWaitCondition||, CODE, READONLY, ALIGN=1

                  prvTestWaitCondition PROC
;;;612    
;;;613    static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
000000  b510              PUSH     {r4,lr}
;;;614    {
000002  4603              MOV      r3,r0
;;;615    BaseType_t xWaitConditionMet = pdFALSE;
000004  2000              MOVS     r0,#0
;;;616    
;;;617    	if( xWaitForAllBits == pdFALSE )
000006  b922              CBNZ     r2,|L1.18|
;;;618    	{
;;;619    		/* Task only has to wait for one bit within uxBitsToWaitFor to be
;;;620    		set.  Is one already set? */
;;;621    		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
000008  ea030401          AND      r4,r3,r1
00000c  b134              CBZ      r4,|L1.28|
;;;622    		{
;;;623    			xWaitConditionMet = pdTRUE;
00000e  2001              MOVS     r0,#1
000010  e004              B        |L1.28|
                  |L1.18|
;;;624    		}
;;;625    		else
;;;626    		{
;;;627    			mtCOVERAGE_TEST_MARKER();
;;;628    		}
;;;629    	}
;;;630    	else
;;;631    	{
;;;632    		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
;;;633    		Are they set already? */
;;;634    		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
000012  ea030401          AND      r4,r3,r1
000016  428c              CMP      r4,r1
000018  d100              BNE      |L1.28|
;;;635    		{
;;;636    			xWaitConditionMet = pdTRUE;
00001a  2001              MOVS     r0,#1
                  |L1.28|
;;;637    		}
;;;638    		else
;;;639    		{
;;;640    			mtCOVERAGE_TEST_MARKER();
;;;641    		}
;;;642    	}
;;;643    
;;;644    	return xWaitConditionMet;
;;;645    }
00001c  bd10              POP      {r4,pc}
;;;646    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vEventGroupClearBitsCallback||, CODE, READONLY, ALIGN=1

                  vEventGroupClearBitsCallback PROC
;;;606    an interrupt. */
;;;607    void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
000000  b570              PUSH     {r4-r6,lr}
;;;608    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;609    	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       xEventGroupClearBits
;;;610    }
00000e  bd70              POP      {r4-r6,pc}
;;;611    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vEventGroupDelete||, CODE, READONLY, ALIGN=1

                  vEventGroupDelete PROC
;;;573    
;;;574    void vEventGroupDelete( EventGroupHandle_t xEventGroup )
000000  b570              PUSH     {r4-r6,lr}
;;;575    {
000002  4605              MOV      r5,r0
;;;576    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000004  462e              MOV      r6,r5
;;;577    const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
000006  1d34              ADDS     r4,r6,#4
;;;578    
;;;579    	vTaskSuspendAll();
000008  f7fffffe          BL       vTaskSuspendAll
;;;580    	{
;;;581    		traceEVENT_GROUP_DELETE( xEventGroup );
;;;582    
;;;583    		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
00000c  e011              B        |L3.50|
                  |L3.14|
;;;584    		{
;;;585    			/* Unblock the task, returning 0 as the event list is being deleted
;;;586    			and	cannot therefore have any bits set. */
;;;587    			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
00000e  f1040008          ADD      r0,r4,#8
000012  68e1              LDR      r1,[r4,#0xc]
000014  4281              CMP      r1,r0
000016  d001              BEQ      |L3.28|
000018  2001              MOVS     r0,#1
00001a  e000              B        |L3.30|
                  |L3.28|
00001c  2000              MOVS     r0,#0
                  |L3.30|
00001e  b918              CBNZ     r0,|L3.40|
000020  f7fffffe          BL       ulPortSetInterruptMask
000024  bf00              NOP      
                  |L3.38|
000026  e7fe              B        |L3.38|
                  |L3.40|
;;;588    			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
000028  f04f7100          MOV      r1,#0x2000000
00002c  68e0              LDR      r0,[r4,#0xc]
00002e  f7fffffe          BL       xTaskRemoveFromUnorderedEventList
                  |L3.50|
000032  6820              LDR      r0,[r4,#0]            ;583
000034  2800              CMP      r0,#0                 ;583
000036  d1ea              BNE      |L3.14|
;;;589    		}
;;;590    
;;;591    		vPortFree( pxEventBits );
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       vPortFree
;;;592    	}
;;;593    	( void ) xTaskResumeAll();
00003e  f7fffffe          BL       xTaskResumeAll
;;;594    }
000042  bd70              POP      {r4-r6,pc}
;;;595    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vEventGroupSetBitsCallback||, CODE, READONLY, ALIGN=1

                  vEventGroupSetBitsCallback PROC
;;;598    an interrupt. */
;;;599    void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
000000  b570              PUSH     {r4-r6,lr}
;;;600    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;601    	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       xEventGroupSetBits
;;;602    }
00000e  bd70              POP      {r4-r6,pc}
;;;603    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupClearBits||, CODE, READONLY, ALIGN=1

                  xEventGroupClearBits PROC
;;;421    
;;;422    EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;423    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;424    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000008  462c              MOV      r4,r5
;;;425    EventBits_t uxReturn;
;;;426    
;;;427    	/* Check the user is not attempting to clear the bits used by the kernel
;;;428    	itself. */
;;;429    	configASSERT( xEventGroup );
00000a  b91d              CBNZ     r5,|L5.20|
00000c  f7fffffe          BL       ulPortSetInterruptMask
000010  bf00              NOP      
                  |L5.18|
000012  e7fe              B        |L5.18|
                  |L5.20|
;;;430    	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
000014  f006407f          AND      r0,r6,#0xff000000
000018  b908              CBNZ     r0,|L5.30|
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L5.32|
                  |L5.30|
00001e  2000              MOVS     r0,#0
                  |L5.32|
000020  b918              CBNZ     r0,|L5.42|
000022  f7fffffe          BL       ulPortSetInterruptMask
000026  bf00              NOP      
                  |L5.40|
000028  e7fe              B        |L5.40|
                  |L5.42|
;;;431    
;;;432    	taskENTER_CRITICAL();
00002a  f7fffffe          BL       vPortEnterCritical
;;;433    	{
;;;434    		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
;;;435    
;;;436    		/* The value returned is the event group value prior to the bits being
;;;437    		cleared. */
;;;438    		uxReturn = pxEventBits->uxEventBits;
00002e  6827              LDR      r7,[r4,#0]
;;;439    
;;;440    		/* Clear the bits. */
;;;441    		pxEventBits->uxEventBits &= ~uxBitsToClear;
000030  6820              LDR      r0,[r4,#0]
000032  43b0              BICS     r0,r0,r6
000034  6020              STR      r0,[r4,#0]
;;;442    	}
;;;443    	taskEXIT_CRITICAL();
000036  f7fffffe          BL       vPortExitCritical
;;;444    
;;;445    	return uxReturn;
00003a  4638              MOV      r0,r7
;;;446    }
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;447    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupCreate||, CODE, READONLY, ALIGN=1

                  xEventGroupCreate PROC
;;;137    
;;;138    EventGroupHandle_t xEventGroupCreate( void )
000000  b510              PUSH     {r4,lr}
;;;139    {
;;;140    EventGroup_t *pxEventBits;
;;;141    
;;;142    	pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
000002  2018              MOVS     r0,#0x18
000004  f7fffffe          BL       pvPortMalloc
000008  4604              MOV      r4,r0
;;;143    	if( pxEventBits != NULL )
00000a  b124              CBZ      r4,|L6.22|
;;;144    	{
;;;145    		pxEventBits->uxEventBits = 0;
00000c  2000              MOVS     r0,#0
00000e  6020              STR      r0,[r4,#0]
;;;146    		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
000010  1d20              ADDS     r0,r4,#4
000012  f7fffffe          BL       vListInitialise
                  |L6.22|
;;;147    		traceEVENT_GROUP_CREATE( pxEventBits );
;;;148    	}
;;;149    	else
;;;150    	{
;;;151    		traceEVENT_GROUP_CREATE_FAILED();
;;;152    	}
;;;153    
;;;154    	return ( EventGroupHandle_t ) pxEventBits;
000016  4620              MOV      r0,r4
;;;155    }
000018  bd10              POP      {r4,pc}
;;;156    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupGetBitsFromISR||, CODE, READONLY, ALIGN=1

                  xEventGroupGetBitsFromISR PROC
;;;463    
;;;464    EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;465    {
000004  4604              MOV      r4,r0
;;;466    UBaseType_t uxSavedInterruptStatus;
;;;467    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000006  4625              MOV      r5,r4
;;;468    EventBits_t uxReturn;
;;;469    
;;;470    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000008  f7fffffe          BL       ulPortSetInterruptMask
00000c  4607              MOV      r7,r0
;;;471    	{
;;;472    		uxReturn = pxEventBits->uxEventBits;
00000e  682e              LDR      r6,[r5,#0]
;;;473    	}
;;;474    	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       vPortClearInterruptMask
;;;475    
;;;476    	return uxReturn;
000016  4630              MOV      r0,r6
;;;477    }
000018  e8bd81f0          POP      {r4-r8,pc}
;;;478    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupSetBits||, CODE, READONLY, ALIGN=1

                  xEventGroupSetBits PROC
;;;479    
;;;480    EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;481    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;482    ListItem_t *pxListItem, *pxNext;
;;;483    ListItem_t const *pxListEnd;
;;;484    List_t *pxList;
;;;485    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
000008  2000              MOVS     r0,#0
00000a  9001              STR      r0,[sp,#4]
;;;486    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
00000c  463c              MOV      r4,r7
;;;487    BaseType_t xMatchFound = pdFALSE;
00000e  9000              STR      r0,[sp,#0]
;;;488    
;;;489    	/* Check the user is not attempting to set the bits used by the kernel
;;;490    	itself. */
;;;491    	configASSERT( xEventGroup );
000010  b91f              CBNZ     r7,|L8.26|
000012  f7fffffe          BL       ulPortSetInterruptMask
000016  bf00              NOP      
                  |L8.24|
000018  e7fe              B        |L8.24|
                  |L8.26|
;;;492    	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
00001a  f008407f          AND      r0,r8,#0xff000000
00001e  b908              CBNZ     r0,|L8.36|
000020  2001              MOVS     r0,#1
000022  e000              B        |L8.38|
                  |L8.36|
000024  2000              MOVS     r0,#0
                  |L8.38|
000026  b918              CBNZ     r0,|L8.48|
000028  f7fffffe          BL       ulPortSetInterruptMask
00002c  bf00              NOP      
                  |L8.46|
00002e  e7fe              B        |L8.46|
                  |L8.48|
;;;493    
;;;494    	pxList = &( pxEventBits->xTasksWaitingForBits );
000030  f1040904          ADD      r9,r4,#4
;;;495    	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
000034  f1090008          ADD      r0,r9,#8
000038  9002              STR      r0,[sp,#8]
;;;496    	vTaskSuspendAll();
00003a  f7fffffe          BL       vTaskSuspendAll
;;;497    	{
;;;498    		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
;;;499    
;;;500    		pxListItem = listGET_HEAD_ENTRY( pxList );
00003e  f8d9600c          LDR      r6,[r9,#0xc]
;;;501    
;;;502    		/* Set the bits. */
;;;503    		pxEventBits->uxEventBits |= uxBitsToSet;
000042  6820              LDR      r0,[r4,#0]
000044  ea400008          ORR      r0,r0,r8
000048  6020              STR      r0,[r4,#0]
;;;504    
;;;505    		/* See if the new bit value should unblock any tasks. */
;;;506    		while( pxListItem != pxListEnd )
00004a  e026              B        |L8.154|
                  |L8.76|
;;;507    		{
;;;508    			pxNext = listGET_NEXT( pxListItem );
00004c  f8d6b004          LDR      r11,[r6,#4]
;;;509    			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
000050  6835              LDR      r5,[r6,#0]
;;;510    			xMatchFound = pdFALSE;
000052  2000              MOVS     r0,#0
000054  9000              STR      r0,[sp,#0]
;;;511    
;;;512    			/* Split the bits waited for from the control bits. */
;;;513    			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
000056  f0054a7f          AND      r10,r5,#0xff000000
;;;514    			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
00005a  f025457f          BIC      r5,r5,#0xff000000
;;;515    
;;;516    			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
00005e  f00a6080          AND      r0,r10,#0x4000000
000062  b928              CBNZ     r0,|L8.112|
;;;517    			{
;;;518    				/* Just looking for single bit being set. */
;;;519    				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
000064  6820              LDR      r0,[r4,#0]
000066  4028              ANDS     r0,r0,r5
000068  b140              CBZ      r0,|L8.124|
;;;520    				{
;;;521    					xMatchFound = pdTRUE;
00006a  2001              MOVS     r0,#1
00006c  9000              STR      r0,[sp,#0]
00006e  e005              B        |L8.124|
                  |L8.112|
;;;522    				}
;;;523    				else
;;;524    				{
;;;525    					mtCOVERAGE_TEST_MARKER();
;;;526    				}
;;;527    			}
;;;528    			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
000070  6820              LDR      r0,[r4,#0]
000072  4028              ANDS     r0,r0,r5
000074  42a8              CMP      r0,r5
000076  d101              BNE      |L8.124|
;;;529    			{
;;;530    				/* All bits are set. */
;;;531    				xMatchFound = pdTRUE;
000078  2001              MOVS     r0,#1
00007a  9000              STR      r0,[sp,#0]
                  |L8.124|
;;;532    			}
;;;533    			else
;;;534    			{
;;;535    				/* Need all bits to be set, but not all the bits were set. */
;;;536    			}
;;;537    
;;;538    			if( xMatchFound != pdFALSE )
00007c  9800              LDR      r0,[sp,#0]
00007e  b158              CBZ      r0,|L8.152|
;;;539    			{
;;;540    				/* The bits match.  Should the bits be cleared on exit? */
;;;541    				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
000080  f00a7080          AND      r0,r10,#0x1000000
000084  b110              CBZ      r0,|L8.140|
;;;542    				{
;;;543    					uxBitsToClear |= uxBitsWaitedFor;
000086  9801              LDR      r0,[sp,#4]
000088  4328              ORRS     r0,r0,r5
00008a  9001              STR      r0,[sp,#4]
                  |L8.140|
;;;544    				}
;;;545    				else
;;;546    				{
;;;547    					mtCOVERAGE_TEST_MARKER();
;;;548    				}
;;;549    
;;;550    				/* Store the actual event flag value in the task's event list
;;;551    				item before removing the task from the event list.  The
;;;552    				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
;;;553    				that is was unblocked due to its required bits matching, rather
;;;554    				than because it timed out. */
;;;555    				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
00008c  6820              LDR      r0,[r4,#0]
00008e  f0407100          ORR      r1,r0,#0x2000000
000092  4630              MOV      r0,r6
000094  f7fffffe          BL       xTaskRemoveFromUnorderedEventList
                  |L8.152|
;;;556    			}
;;;557    
;;;558    			/* Move onto the next list item.  Note pxListItem->pxNext is not
;;;559    			used here as the list item may have been removed from the event list
;;;560    			and inserted into the ready/pending reading list. */
;;;561    			pxListItem = pxNext;
000098  465e              MOV      r6,r11
                  |L8.154|
00009a  9802              LDR      r0,[sp,#8]            ;506
00009c  4286              CMP      r6,r0                 ;506
00009e  d1d5              BNE      |L8.76|
;;;562    		}
;;;563    
;;;564    		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
;;;565    		bit was set in the control word. */
;;;566    		pxEventBits->uxEventBits &= ~uxBitsToClear;
0000a0  6820              LDR      r0,[r4,#0]
0000a2  9901              LDR      r1,[sp,#4]
0000a4  4388              BICS     r0,r0,r1
0000a6  6020              STR      r0,[r4,#0]
;;;567    	}
;;;568    	( void ) xTaskResumeAll();
0000a8  f7fffffe          BL       xTaskResumeAll
;;;569    
;;;570    	return pxEventBits->uxEventBits;
0000ac  6820              LDR      r0,[r4,#0]
;;;571    }
0000ae  e8bd8ffe          POP      {r1-r11,pc}
;;;572    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupSync||, CODE, READONLY, ALIGN=1

                  xEventGroupSync PROC
;;;157    
;;;158    EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;159    {
000004  4683              MOV      r11,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
;;;160    EventBits_t uxOriginalBitValue, uxReturn;
;;;161    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
00000c  465d              MOV      r5,r11
;;;162    BaseType_t xAlreadyYielded;
;;;163    BaseType_t xTimeoutOccurred = pdFALSE;
00000e  2000              MOVS     r0,#0
000010  9000              STR      r0,[sp,#0]
;;;164    
;;;165    	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
000012  f004407f          AND      r0,r4,#0xff000000
000016  b908              CBNZ     r0,|L9.28|
000018  2001              MOVS     r0,#1
00001a  e000              B        |L9.30|
                  |L9.28|
00001c  2000              MOVS     r0,#0
                  |L9.30|
00001e  b918              CBNZ     r0,|L9.40|
000020  f7fffffe          BL       ulPortSetInterruptMask
000024  bf00              NOP      
                  |L9.38|
000026  e7fe              B        |L9.38|
                  |L9.40|
;;;166    	configASSERT( uxBitsToWaitFor != 0 );
000028  b10c              CBZ      r4,|L9.46|
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L9.48|
                  |L9.46|
00002e  2000              MOVS     r0,#0
                  |L9.48|
000030  b918              CBNZ     r0,|L9.58|
000032  f7fffffe          BL       ulPortSetInterruptMask
000036  bf00              NOP      
                  |L9.56|
000038  e7fe              B        |L9.56|
                  |L9.58|
;;;167    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;168    	{
;;;169    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
00003a  f7fffffe          BL       xTaskGetSchedulerState
00003e  b900              CBNZ     r0,|L9.66|
000040  b90f              CBNZ     r7,|L9.70|
                  |L9.66|
000042  2001              MOVS     r0,#1
000044  e000              B        |L9.72|
                  |L9.70|
000046  2000              MOVS     r0,#0
                  |L9.72|
000048  b918              CBNZ     r0,|L9.82|
00004a  f7fffffe          BL       ulPortSetInterruptMask
00004e  bf00              NOP      
                  |L9.80|
000050  e7fe              B        |L9.80|
                  |L9.82|
;;;170    	}
;;;171    	#endif
;;;172    
;;;173    	vTaskSuspendAll();
000052  f7fffffe          BL       vTaskSuspendAll
;;;174    	{
;;;175    		uxOriginalBitValue = pxEventBits->uxEventBits;
000056  f8d59000          LDR      r9,[r5,#0]
;;;176    
;;;177    		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
00005a  4641              MOV      r1,r8
00005c  4658              MOV      r0,r11
00005e  f7fffffe          BL       xEventGroupSetBits
;;;178    
;;;179    		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
000062  ea490008          ORR      r0,r9,r8
000066  4020              ANDS     r0,r0,r4
000068  42a0              CMP      r0,r4
00006a  d106              BNE      |L9.122|
;;;180    		{
;;;181    			/* All the rendezvous bits are now set - no need to block. */
;;;182    			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
00006c  ea490608          ORR      r6,r9,r8
;;;183    
;;;184    			/* Rendezvous always clear the bits.  They will have been cleared
;;;185    			already unless this is the only task in the rendezvous. */
;;;186    			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
000070  6828              LDR      r0,[r5,#0]
000072  43a0              BICS     r0,r0,r4
000074  6028              STR      r0,[r5,#0]
;;;187    
;;;188    			xTicksToWait = 0;
000076  2700              MOVS     r7,#0
000078  e009              B        |L9.142|
                  |L9.122|
;;;189    		}
;;;190    		else
;;;191    		{
;;;192    			if( xTicksToWait != ( TickType_t ) 0 )
00007a  b13f              CBZ      r7,|L9.140|
;;;193    			{
;;;194    				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
;;;195    
;;;196    				/* Store the bits that the calling task is waiting for in the
;;;197    				task's event list item so the kernel knows when a match is
;;;198    				found.  Then enter the blocked state. */
;;;199    				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
00007c  f04461a0          ORR      r1,r4,#0x5000000
000080  463a              MOV      r2,r7
000082  1d28              ADDS     r0,r5,#4
000084  f7fffffe          BL       vTaskPlaceOnUnorderedEventList
;;;200    
;;;201    				/* This assignment is obsolete as uxReturn will get set after
;;;202    				the task unblocks, but some compilers mistakenly generate a
;;;203    				warning about uxReturn being returned without being set if the
;;;204    				assignment is omitted. */
;;;205    				uxReturn = 0;
000088  2600              MOVS     r6,#0
00008a  e000              B        |L9.142|
                  |L9.140|
;;;206    			}
;;;207    			else
;;;208    			{
;;;209    				/* The rendezvous bits were not set, but no block time was
;;;210    				specified - just return the current event bit value. */
;;;211    				uxReturn = pxEventBits->uxEventBits;
00008c  682e              LDR      r6,[r5,#0]
                  |L9.142|
;;;212    			}
;;;213    		}
;;;214    	}
;;;215    	xAlreadyYielded = xTaskResumeAll();
00008e  f7fffffe          BL       xTaskResumeAll
000092  4682              MOV      r10,r0
;;;216    
;;;217    	if( xTicksToWait != ( TickType_t ) 0 )
000094  b1d7              CBZ      r7,|L9.204|
;;;218    	{
;;;219    		if( xAlreadyYielded == pdFALSE )
000096  f1ba0f00          CMP      r10,#0
00009a  d101              BNE      |L9.160|
;;;220    		{
;;;221    			portYIELD_WITHIN_API();
00009c  f7fffffe          BL       vPortYield
                  |L9.160|
;;;222    		}
;;;223    		else
;;;224    		{
;;;225    			mtCOVERAGE_TEST_MARKER();
;;;226    		}
;;;227    
;;;228    		/* The task blocked to wait for its required bits to be set - at this
;;;229    		point either the required bits were set or the block time expired.  If
;;;230    		the required bits were set they will have been stored in the task's
;;;231    		event list item, and they should now be retrieved then cleared. */
;;;232    		uxReturn = uxTaskResetEventItemValue();
0000a0  f7fffffe          BL       uxTaskResetEventItemValue
0000a4  4606              MOV      r6,r0
;;;233    
;;;234    		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
0000a6  f0067000          AND      r0,r6,#0x2000000
0000aa  b968              CBNZ     r0,|L9.200|
;;;235    		{
;;;236    			/* The task timed out, just return the current event bit value. */
;;;237    			taskENTER_CRITICAL();
0000ac  f7fffffe          BL       vPortEnterCritical
;;;238    			{
;;;239    				uxReturn = pxEventBits->uxEventBits;
0000b0  682e              LDR      r6,[r5,#0]
;;;240    
;;;241    				/* Although the task got here because it timed out before the
;;;242    				bits it was waiting for were set, it is possible that since it
;;;243    				unblocked another task has set the bits.  If this is the case
;;;244    				then it needs to clear the bits before exiting. */
;;;245    				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
0000b2  ea060004          AND      r0,r6,r4
0000b6  42a0              CMP      r0,r4
0000b8  d102              BNE      |L9.192|
;;;246    				{
;;;247    					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
0000ba  6828              LDR      r0,[r5,#0]
0000bc  43a0              BICS     r0,r0,r4
0000be  6028              STR      r0,[r5,#0]
                  |L9.192|
;;;248    				}
;;;249    				else
;;;250    				{
;;;251    					mtCOVERAGE_TEST_MARKER();
;;;252    				}
;;;253    			}
;;;254    			taskEXIT_CRITICAL();
0000c0  f7fffffe          BL       vPortExitCritical
;;;255    
;;;256    			xTimeoutOccurred = pdTRUE;
0000c4  2001              MOVS     r0,#1
0000c6  9000              STR      r0,[sp,#0]
                  |L9.200|
;;;257    		}
;;;258    		else
;;;259    		{
;;;260    			/* The task unblocked because the bits were set. */
;;;261    		}
;;;262    
;;;263    		/* Control bits might be set as the task had blocked should not be
;;;264    		returned. */
;;;265    		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
0000c8  f026467f          BIC      r6,r6,#0xff000000
                  |L9.204|
;;;266    	}
;;;267    
;;;268    	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
;;;269    
;;;270    	return uxReturn;
0000cc  4630              MOV      r0,r6
;;;271    }
0000ce  e8bd8ff8          POP      {r3-r11,pc}
;;;272    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupWaitBits||, CODE, READONLY, ALIGN=1

                  xEventGroupWaitBits PROC
;;;273    
;;;274    EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;275    {
000004  b083              SUB      sp,sp,#0xc
000006  4681              MOV      r9,r0
000008  460d              MOV      r5,r1
00000a  4617              MOV      r7,r2
00000c  f8dd8040          LDR      r8,[sp,#0x40]
;;;276    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000010  464c              MOV      r4,r9
;;;277    EventBits_t uxReturn, uxControlBits = 0;
000012  f04f0a00          MOV      r10,#0
;;;278    BaseType_t xWaitConditionMet, xAlreadyYielded;
;;;279    BaseType_t xTimeoutOccurred = pdFALSE;
000016  2000              MOVS     r0,#0
000018  9001              STR      r0,[sp,#4]
;;;280    
;;;281    	/* Check the user is not attempting to wait on the bits used by the kernel
;;;282    	itself, and that at least one bit is being requested. */
;;;283    	configASSERT( xEventGroup );
00001a  f1b90f00          CMP      r9,#0
00001e  d103              BNE      |L10.40|
000020  f7fffffe          BL       ulPortSetInterruptMask
000024  bf00              NOP      
                  |L10.38|
000026  e7fe              B        |L10.38|
                  |L10.40|
;;;284    	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
000028  f005407f          AND      r0,r5,#0xff000000
00002c  b908              CBNZ     r0,|L10.50|
00002e  2001              MOVS     r0,#1
000030  e000              B        |L10.52|
                  |L10.50|
000032  2000              MOVS     r0,#0
                  |L10.52|
000034  b918              CBNZ     r0,|L10.62|
000036  f7fffffe          BL       ulPortSetInterruptMask
00003a  bf00              NOP      
                  |L10.60|
00003c  e7fe              B        |L10.60|
                  |L10.62|
;;;285    	configASSERT( uxBitsToWaitFor != 0 );
00003e  b10d              CBZ      r5,|L10.68|
000040  2001              MOVS     r0,#1
000042  e000              B        |L10.70|
                  |L10.68|
000044  2000              MOVS     r0,#0
                  |L10.70|
000046  b918              CBNZ     r0,|L10.80|
000048  f7fffffe          BL       ulPortSetInterruptMask
00004c  bf00              NOP      
                  |L10.78|
00004e  e7fe              B        |L10.78|
                  |L10.80|
;;;286    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;287    	{
;;;288    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
000050  f7fffffe          BL       xTaskGetSchedulerState
000054  b910              CBNZ     r0,|L10.92|
000056  f1b80f00          CMP      r8,#0
00005a  d101              BNE      |L10.96|
                  |L10.92|
00005c  2001              MOVS     r0,#1
00005e  e000              B        |L10.98|
                  |L10.96|
000060  2000              MOVS     r0,#0
                  |L10.98|
000062  b918              CBNZ     r0,|L10.108|
000064  f7fffffe          BL       ulPortSetInterruptMask
000068  bf00              NOP      
                  |L10.106|
00006a  e7fe              B        |L10.106|
                  |L10.108|
;;;289    	}
;;;290    	#endif
;;;291    
;;;292    	vTaskSuspendAll();
00006c  f7fffffe          BL       vTaskSuspendAll
;;;293    	{
;;;294    		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
000070  6820              LDR      r0,[r4,#0]
000072  9000              STR      r0,[sp,#0]
;;;295    
;;;296    		/* Check to see if the wait condition is already met or not. */
;;;297    		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
000074  4629              MOV      r1,r5
000076  9a06              LDR      r2,[sp,#0x18]
000078  9800              LDR      r0,[sp,#0]
00007a  f7fffffe          BL       prvTestWaitCondition
00007e  9002              STR      r0,[sp,#8]
;;;298    
;;;299    		if( xWaitConditionMet != pdFALSE )
000080  9802              LDR      r0,[sp,#8]
000082  b138              CBZ      r0,|L10.148|
;;;300    		{
;;;301    			/* The wait condition has already been met so there is no need to
;;;302    			block. */
;;;303    			uxReturn = uxCurrentEventBits;
000084  9e00              LDR      r6,[sp,#0]
;;;304    			xTicksToWait = ( TickType_t ) 0;
000086  f04f0800          MOV      r8,#0
;;;305    
;;;306    			/* Clear the wait bits if requested to do so. */
;;;307    			if( xClearOnExit != pdFALSE )
00008a  b1b7              CBZ      r7,|L10.186|
;;;308    			{
;;;309    				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
00008c  6820              LDR      r0,[r4,#0]
00008e  43a8              BICS     r0,r0,r5
000090  6020              STR      r0,[r4,#0]
000092  e012              B        |L10.186|
                  |L10.148|
;;;310    			}
;;;311    			else
;;;312    			{
;;;313    				mtCOVERAGE_TEST_MARKER();
;;;314    			}
;;;315    		}
;;;316    		else if( xTicksToWait == ( TickType_t ) 0 )
000094  f1b80f00          CMP      r8,#0
000098  d101              BNE      |L10.158|
;;;317    		{
;;;318    			/* The wait condition has not been met, but no block time was
;;;319    			specified, so just return the current value. */
;;;320    			uxReturn = uxCurrentEventBits;
00009a  9e00              LDR      r6,[sp,#0]
00009c  e00d              B        |L10.186|
                  |L10.158|
;;;321    		}
;;;322    		else
;;;323    		{
;;;324    			/* The task is going to block to wait for its required bits to be
;;;325    			set.  uxControlBits are used to remember the specified behaviour of
;;;326    			this call to xEventGroupWaitBits() - for use when the event bits
;;;327    			unblock the task. */
;;;328    			if( xClearOnExit != pdFALSE )
00009e  b10f              CBZ      r7,|L10.164|
;;;329    			{
;;;330    				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
0000a0  f04a7a80          ORR      r10,r10,#0x1000000
                  |L10.164|
;;;331    			}
;;;332    			else
;;;333    			{
;;;334    				mtCOVERAGE_TEST_MARKER();
;;;335    			}
;;;336    
;;;337    			if( xWaitForAllBits != pdFALSE )
0000a4  9806              LDR      r0,[sp,#0x18]
0000a6  b108              CBZ      r0,|L10.172|
;;;338    			{
;;;339    				uxControlBits |= eventWAIT_FOR_ALL_BITS;
0000a8  f04a6a80          ORR      r10,r10,#0x4000000
                  |L10.172|
;;;340    			}
;;;341    			else
;;;342    			{
;;;343    				mtCOVERAGE_TEST_MARKER();
;;;344    			}
;;;345    
;;;346    			/* Store the bits that the calling task is waiting for in the
;;;347    			task's event list item so the kernel knows when a match is
;;;348    			found.  Then enter the blocked state. */
;;;349    			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
0000ac  ea45010a          ORR      r1,r5,r10
0000b0  4642              MOV      r2,r8
0000b2  1d20              ADDS     r0,r4,#4
0000b4  f7fffffe          BL       vTaskPlaceOnUnorderedEventList
;;;350    
;;;351    			/* This is obsolete as it will get set after the task unblocks, but
;;;352    			some compilers mistakenly generate a warning about the variable
;;;353    			being returned without being set if it is not done. */
;;;354    			uxReturn = 0;
0000b8  2600              MOVS     r6,#0
                  |L10.186|
;;;355    
;;;356    			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
;;;357    		}
;;;358    	}
;;;359    	xAlreadyYielded = xTaskResumeAll();
0000ba  f7fffffe          BL       xTaskResumeAll
0000be  4683              MOV      r11,r0
;;;360    
;;;361    	if( xTicksToWait != ( TickType_t ) 0 )
0000c0  f1b80f00          CMP      r8,#0
0000c4  d01d              BEQ      |L10.258|
;;;362    	{
;;;363    		if( xAlreadyYielded == pdFALSE )
0000c6  f1bb0f00          CMP      r11,#0
0000ca  d101              BNE      |L10.208|
;;;364    		{
;;;365    			portYIELD_WITHIN_API();
0000cc  f7fffffe          BL       vPortYield
                  |L10.208|
;;;366    		}
;;;367    		else
;;;368    		{
;;;369    			mtCOVERAGE_TEST_MARKER();
;;;370    		}
;;;371    
;;;372    		/* The task blocked to wait for its required bits to be set - at this
;;;373    		point either the required bits were set or the block time expired.  If
;;;374    		the required bits were set they will have been stored in the task's
;;;375    		event list item, and they should now be retrieved then cleared. */
;;;376    		uxReturn = uxTaskResetEventItemValue();
0000d0  f7fffffe          BL       uxTaskResetEventItemValue
0000d4  4606              MOV      r6,r0
;;;377    
;;;378    		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
0000d6  f0067000          AND      r0,r6,#0x2000000
0000da  b980              CBNZ     r0,|L10.254|
;;;379    		{
;;;380    			taskENTER_CRITICAL();
0000dc  f7fffffe          BL       vPortEnterCritical
;;;381    			{
;;;382    				/* The task timed out, just return the current event bit value. */
;;;383    				uxReturn = pxEventBits->uxEventBits;
0000e0  6826              LDR      r6,[r4,#0]
;;;384    
;;;385    				/* It is possible that the event bits were updated between this
;;;386    				task leaving the Blocked state and running again. */
;;;387    				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
0000e2  4629              MOV      r1,r5
0000e4  4630              MOV      r0,r6
0000e6  9a06              LDR      r2,[sp,#0x18]
0000e8  f7fffffe          BL       prvTestWaitCondition
0000ec  b118              CBZ      r0,|L10.246|
;;;388    				{
;;;389    					if( xClearOnExit != pdFALSE )
0000ee  b117              CBZ      r7,|L10.246|
;;;390    					{
;;;391    						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
0000f0  6820              LDR      r0,[r4,#0]
0000f2  43a8              BICS     r0,r0,r5
0000f4  6020              STR      r0,[r4,#0]
                  |L10.246|
;;;392    					}
;;;393    					else
;;;394    					{
;;;395    						mtCOVERAGE_TEST_MARKER();
;;;396    					}
;;;397    				}
;;;398    				else
;;;399    				{
;;;400    					mtCOVERAGE_TEST_MARKER();
;;;401    				}
;;;402    			}
;;;403    			taskEXIT_CRITICAL();
0000f6  f7fffffe          BL       vPortExitCritical
;;;404    
;;;405    			/* Prevent compiler warnings when trace macros are not used. */
;;;406    			xTimeoutOccurred = pdFALSE;
0000fa  2000              MOVS     r0,#0
0000fc  9001              STR      r0,[sp,#4]
                  |L10.254|
;;;407    		}
;;;408    		else
;;;409    		{
;;;410    			/* The task unblocked because the bits were set. */
;;;411    		}
;;;412    
;;;413    		/* The task blocked so control bits may have been set. */
;;;414    		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
0000fe  f026467f          BIC      r6,r6,#0xff000000
                  |L10.258|
;;;415    	}
;;;416    	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
;;;417    
;;;418    	return uxReturn;
000102  4630              MOV      r0,r6
;;;419    }
000104  b007              ADD      sp,sp,#0x1c
000106  e8bd8ff0          POP      {r4-r11,pc}
;;;420    /*-----------------------------------------------------------*/
                          ENDP

