; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\timers.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\timers.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\Middleware\blue_angel\inc -I..\..\Middleware\bt_callback_manager -I..\..\Middleware\blue_angel\btif -I..\..\Middleware\blue_angel\common -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\blue_angel\src\common -I..\..\Middleware\blue_angel\src\inc -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\blue_angel\platform\rtos -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\ut_manager\Cunit\Headers -I..\..\Middleware\ut_manager\Cunit\interface -I..\..\Middleware\blue_angel\platform\test -I..\..\Middleware\blue_angel\driver -I..\..\Middleware\blue_angel\src\core\hci -I..\..\User\bt\inc -I..\..\Middleware\bt_callback_manager -I..\..\Middleware\at_command -I..\..\Middleware\blue_angel\src\core\gap -I..\..\Middleware\blue_angel\src\core\l2cap -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=522 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DNDEBUG --omf_browse=.\flash\obj\timers.crf ..\..\FreeRTOS\timers.c]
                          THUMB

                          AREA ||i.pcTimerGetTimerName||, CODE, READONLY, ALIGN=1

                  pcTimerGetTimerName PROC
;;;371    
;;;372    const char * pcTimerGetTimerName( TimerHandle_t xTimer )
000000  b570              PUSH     {r4-r6,lr}
;;;373    {
000002  4604              MOV      r4,r0
;;;374    Timer_t *pxTimer = ( Timer_t * ) xTimer;
000004  4625              MOV      r5,r4
;;;375    
;;;376    	configASSERT( xTimer );
000006  b91c              CBNZ     r4,|L1.16|
000008  f7fffffe          BL       ulPortSetInterruptMask
00000c  bf00              NOP      
                  |L1.14|
00000e  e7fe              B        |L1.14|
                  |L1.16|
;;;377    	return pxTimer->pcTimerName;
000010  6828              LDR      r0,[r5,#0]
;;;378    }
000012  bd70              POP      {r4-r6,pc}
;;;379    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCheckForValidListAndQueue||, CODE, READONLY, ALIGN=2

                  prvCheckForValidListAndQueue PROC
;;;779    
;;;780    static void prvCheckForValidListAndQueue( void )
000000  b510              PUSH     {r4,lr}
;;;781    {
;;;782    	/* Check that the list from which active timers are referenced, and the
;;;783    	queue used to communicate with the timer service, have been
;;;784    	initialised. */
;;;785    	taskENTER_CRITICAL();
000002  f7fffffe          BL       vPortEnterCritical
;;;786    	{
;;;787    		if( xTimerQueue == NULL )
000006  4810              LDR      r0,|L2.72|
000008  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00000a  b9c8              CBNZ     r0,|L2.64|
;;;788    		{
;;;789    			vListInitialise( &xActiveTimerList1 );
00000c  480f              LDR      r0,|L2.76|
00000e  f7fffffe          BL       vListInitialise
;;;790    			vListInitialise( &xActiveTimerList2 );
000012  480f              LDR      r0,|L2.80|
000014  f7fffffe          BL       vListInitialise
;;;791    			pxCurrentTimerList = &xActiveTimerList1;
000018  480c              LDR      r0,|L2.76|
00001a  490e              LDR      r1,|L2.84|
00001c  6008              STR      r0,[r1,#0]  ; pxCurrentTimerList
;;;792    			pxOverflowTimerList = &xActiveTimerList2;
00001e  480c              LDR      r0,|L2.80|
000020  490d              LDR      r1,|L2.88|
000022  6008              STR      r0,[r1,#0]  ; pxOverflowTimerList
;;;793    			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
000024  2200              MOVS     r2,#0
000026  210c              MOVS     r1,#0xc
000028  200a              MOVS     r0,#0xa
00002a  f7fffffe          BL       xQueueGenericCreate
00002e  4906              LDR      r1,|L2.72|
000030  6008              STR      r0,[r1,#0]  ; xTimerQueue
;;;794    			configASSERT( xTimerQueue );
000032  4608              MOV      r0,r1
000034  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000036  b918              CBNZ     r0,|L2.64|
000038  f7fffffe          BL       ulPortSetInterruptMask
00003c  bf00              NOP      
                  |L2.62|
00003e  e7fe              B        |L2.62|
                  |L2.64|
;;;795    
;;;796    			#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;797    			{
;;;798    				if( xTimerQueue != NULL )
;;;799    				{
;;;800    					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
;;;801    				}
;;;802    				else
;;;803    				{
;;;804    					mtCOVERAGE_TEST_MARKER();
;;;805    				}
;;;806    			}
;;;807    			#endif /* configQUEUE_REGISTRY_SIZE */
;;;808    		}
;;;809    		else
;;;810    		{
;;;811    			mtCOVERAGE_TEST_MARKER();
;;;812    		}
;;;813    	}
;;;814    	taskEXIT_CRITICAL();
000040  f7fffffe          BL       vPortExitCritical
;;;815    }
000044  bd10              POP      {r4,pc}
;;;816    /*-----------------------------------------------------------*/
                          ENDP

000046  0000              DCW      0x0000
                  |L2.72|
                          DCD      xTimerQueue
                  |L2.76|
                          DCD      xActiveTimerList1
                  |L2.80|
                          DCD      xActiveTimerList2
                  |L2.84|
                          DCD      pxCurrentTimerList
                  |L2.88|
                          DCD      pxOverflowTimerList

                          AREA ||i.prvGetNextExpireTime||, CODE, READONLY, ALIGN=2

                  prvGetNextExpireTime PROC
;;;504    
;;;505    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
000000  4601              MOV      r1,r0
;;;506    {
;;;507    TickType_t xNextExpireTime;
;;;508    
;;;509    	/* Timers are listed in expiry time order, with the head of the list
;;;510    	referencing the task that will expire first.  Obtain the time at which
;;;511    	the timer with the nearest expiry time will expire.  If there are no
;;;512    	active timers then just set the next expire time to 0.  That will cause
;;;513    	this task to unblock when the tick count overflows, at which point the
;;;514    	timer lists will be switched and the next expiry time can be
;;;515    	re-assessed.  */
;;;516    	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
000002  4a08              LDR      r2,|L3.36|
000004  6812              LDR      r2,[r2,#0]  ; pxCurrentTimerList
000006  6812              LDR      r2,[r2,#0]
000008  b90a              CBNZ     r2,|L3.14|
00000a  2201              MOVS     r2,#1
00000c  e000              B        |L3.16|
                  |L3.14|
00000e  2200              MOVS     r2,#0
                  |L3.16|
000010  600a              STR      r2,[r1,#0]
;;;517    	if( *pxListWasEmpty == pdFALSE )
000012  680a              LDR      r2,[r1,#0]
000014  b922              CBNZ     r2,|L3.32|
;;;518    	{
;;;519    		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
000016  4a03              LDR      r2,|L3.36|
000018  6812              LDR      r2,[r2,#0]  ; pxCurrentTimerList
00001a  68d2              LDR      r2,[r2,#0xc]
00001c  6810              LDR      r0,[r2,#0]
00001e  e000              B        |L3.34|
                  |L3.32|
;;;520    	}
;;;521    	else
;;;522    	{
;;;523    		/* Ensure the task unblocks when the tick count rolls over. */
;;;524    		xNextExpireTime = ( TickType_t ) 0U;
000020  2000              MOVS     r0,#0
                  |L3.34|
;;;525    	}
;;;526    
;;;527    	return xNextExpireTime;
;;;528    }
000022  4770              BX       lr
;;;529    /*-----------------------------------------------------------*/
                          ENDP

                  |L3.36|
                          DCD      pxCurrentTimerList

                          AREA ||i.prvInsertTimerInActiveList||, CODE, READONLY, ALIGN=2

                  prvInsertTimerInActiveList PROC
;;;553    
;;;554    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;555    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;556    BaseType_t xProcessTimerNow = pdFALSE;
00000c  f04f0800          MOV      r8,#0
;;;557    
;;;558    	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
000010  6065              STR      r5,[r4,#4]
;;;559    	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
000012  6124              STR      r4,[r4,#0x10]
;;;560    
;;;561    	if( xNextExpiryTime <= xTimeNow )
000014  42b5              CMP      r5,r6
000016  d80c              BHI      |L4.50|
;;;562    	{
;;;563    		/* Has the expiry time elapsed between the command to start/reset a
;;;564    		timer was issued, and the time the command was processed? */
;;;565    		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
000018  1bf0              SUBS     r0,r6,r7
00001a  69a1              LDR      r1,[r4,#0x18]
00001c  4288              CMP      r0,r1
00001e  d302              BCC      |L4.38|
;;;566    		{
;;;567    			/* The time between a command being issued and the command being
;;;568    			processed actually exceeds the timers period.  */
;;;569    			xProcessTimerNow = pdTRUE;
000020  f04f0801          MOV      r8,#1
000024  e011              B        |L4.74|
                  |L4.38|
;;;570    		}
;;;571    		else
;;;572    		{
;;;573    			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
000026  1d21              ADDS     r1,r4,#4
000028  4809              LDR      r0,|L4.80|
00002a  6800              LDR      r0,[r0,#0]  ; pxOverflowTimerList
00002c  f7fffffe          BL       vListInsert
000030  e00b              B        |L4.74|
                  |L4.50|
;;;574    		}
;;;575    	}
;;;576    	else
;;;577    	{
;;;578    		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
000032  42be              CMP      r6,r7
000034  d204              BCS      |L4.64|
000036  42bd              CMP      r5,r7
000038  d302              BCC      |L4.64|
;;;579    		{
;;;580    			/* If, since the command was issued, the tick count has overflowed
;;;581    			but the expiry time has not, then the timer must have already passed
;;;582    			its expiry time and should be processed immediately. */
;;;583    			xProcessTimerNow = pdTRUE;
00003a  f04f0801          MOV      r8,#1
00003e  e004              B        |L4.74|
                  |L4.64|
;;;584    		}
;;;585    		else
;;;586    		{
;;;587    			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
000040  1d21              ADDS     r1,r4,#4
000042  4804              LDR      r0,|L4.84|
000044  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
000046  f7fffffe          BL       vListInsert
                  |L4.74|
;;;588    		}
;;;589    	}
;;;590    
;;;591    	return xProcessTimerNow;
00004a  4640              MOV      r0,r8
;;;592    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;593    /*-----------------------------------------------------------*/
                          ENDP

                  |L4.80|
                          DCD      pxOverflowTimerList
                  |L4.84|
                          DCD      pxCurrentTimerList

                          AREA ||i.prvProcessExpiredTimer||, CODE, READONLY, ALIGN=2

                  prvProcessExpiredTimer PROC
;;;380    
;;;381    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
000000  b5f8              PUSH     {r3-r7,lr}
;;;382    {
000002  4605              MOV      r5,r0
000004  460f              MOV      r7,r1
;;;383    BaseType_t xResult;
;;;384    Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
000006  4813              LDR      r0,|L5.84|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  68c4              LDR      r4,[r0,#0xc]
;;;385    
;;;386    	/* Remove the timer from the list of active timers.  A check has already
;;;387    	been performed to ensure the list is not empty. */
;;;388    	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       uxListRemove
;;;389    	traceTIMER_EXPIRED( pxTimer );
;;;390    
;;;391    	/* If the timer is an auto reload timer then calculate the next
;;;392    	expiry time and re-insert the timer in the list of active timers. */
;;;393    	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
000014  69e0              LDR      r0,[r4,#0x1c]
000016  2801              CMP      r0,#1
000018  d117              BNE      |L5.74|
;;;394    	{
;;;395    		/* The timer is inserted into a list using a time relative to anything
;;;396    		other than the current time.  It will therefore be inserted into the
;;;397    		correct list relative to the time this task thinks it is now. */
;;;398    		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  1941              ADDS     r1,r0,r5
00001e  462b              MOV      r3,r5
000020  463a              MOV      r2,r7
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       prvInsertTimerInActiveList
000028  2801              CMP      r0,#1
00002a  d10e              BNE      |L5.74|
;;;399    		{
;;;400    			/* The timer expired before it was added to the active timer
;;;401    			list.  Reload it now.  */
;;;402    			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
00002c  2000              MOVS     r0,#0
00002e  4603              MOV      r3,r0
000030  462a              MOV      r2,r5
000032  4601              MOV      r1,r0
000034  9000              STR      r0,[sp,#0]
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       xTimerGenericCommand
00003c  4606              MOV      r6,r0
;;;403    			configASSERT( xResult );
00003e  b91e              CBNZ     r6,|L5.72|
000040  f7fffffe          BL       ulPortSetInterruptMask
000044  bf00              NOP      
                  |L5.70|
000046  e7fe              B        |L5.70|
                  |L5.72|
;;;404    			( void ) xResult;
000048  bf00              NOP      
                  |L5.74|
;;;405    		}
;;;406    		else
;;;407    		{
;;;408    			mtCOVERAGE_TEST_MARKER();
;;;409    		}
;;;410    	}
;;;411    	else
;;;412    	{
;;;413    		mtCOVERAGE_TEST_MARKER();
;;;414    	}
;;;415    
;;;416    	/* Call the timer callback. */
;;;417    	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
00004a  4620              MOV      r0,r4
00004c  6a61              LDR      r1,[r4,#0x24]
00004e  4788              BLX      r1
;;;418    }
000050  bdf8              POP      {r3-r7,pc}
;;;419    /*-----------------------------------------------------------*/
                          ENDP

000052  0000              DCW      0x0000
                  |L5.84|
                          DCD      pxCurrentTimerList

                          AREA ||i.prvProcessReceivedCommands||, CODE, READONLY, ALIGN=2

                  prvProcessReceivedCommands PROC
;;;594    
;;;595    static void	prvProcessReceivedCommands( void )
000000  b570              PUSH     {r4-r6,lr}
;;;596    {
000002  b086              SUB      sp,sp,#0x18
;;;597    DaemonTaskMessage_t xMessage;
;;;598    Timer_t *pxTimer;
;;;599    BaseType_t xTimerListsWereSwitched, xResult;
;;;600    TickType_t xTimeNow;
;;;601    
;;;602    	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
000004  e05d              B        |L6.194|
                  |L6.6|
;;;603    	{
;;;604    		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
;;;605    		{
;;;606    			/* Negative commands are pended function calls rather than timer
;;;607    			commands. */
;;;608    			if( xMessage.xMessageID < ( BaseType_t ) 0 )
;;;609    			{
;;;610    				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
;;;611    
;;;612    				/* The timer uses the xCallbackParameters member to request a
;;;613    				callback be executed.  Check the callback is not NULL. */
;;;614    				configASSERT( pxCallback );
;;;615    
;;;616    				/* Call the function. */
;;;617    				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
;;;618    			}
;;;619    			else
;;;620    			{
;;;621    				mtCOVERAGE_TEST_MARKER();
;;;622    			}
;;;623    		}
;;;624    		#endif /* INCLUDE_xTimerPendFunctionCall */
;;;625    
;;;626    		/* Commands that are positive are timer commands rather than pended
;;;627    		function calls. */
;;;628    		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
000006  9803              LDR      r0,[sp,#0xc]
000008  2800              CMP      r0,#0
00000a  db5a              BLT      |L6.194|
;;;629    		{
;;;630    			/* The messages uses the xTimerParameters member to work on a
;;;631    			software timer. */
;;;632    			pxTimer = xMessage.u.xTimerParameters.pxTimer;
00000c  9c05              LDR      r4,[sp,#0x14]
;;;633    
;;;634    			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
00000e  6960              LDR      r0,[r4,#0x14]
000010  b908              CBNZ     r0,|L6.22|
000012  2001              MOVS     r0,#1
000014  e000              B        |L6.24|
                  |L6.22|
000016  2000              MOVS     r0,#0
                  |L6.24|
000018  b910              CBNZ     r0,|L6.32|
;;;635    			{
;;;636    				/* The timer is in a list, remove it. */
;;;637    				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
00001a  1d20              ADDS     r0,r4,#4
00001c  f7fffffe          BL       uxListRemove
                  |L6.32|
;;;638    			}
;;;639    			else
;;;640    			{
;;;641    				mtCOVERAGE_TEST_MARKER();
;;;642    			}
;;;643    
;;;644    			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
;;;645    
;;;646    			/* In this case the xTimerListsWereSwitched parameter is not used, but
;;;647    			it must be present in the function call.  prvSampleTimeNow() must be
;;;648    			called after the message is received from xTimerQueue so there is no
;;;649    			possibility of a higher priority task adding a message to the message
;;;650    			queue with a time that is ahead of the timer daemon task (because it
;;;651    			pre-empted the timer daemon task after the xTimeNow value was set). */
;;;652    			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
000020  a802              ADD      r0,sp,#8
000022  f7fffffe          BL       prvSampleTimeNow
000026  4605              MOV      r5,r0
;;;653    
;;;654    			switch( xMessage.xMessageID )
000028  9803              LDR      r0,[sp,#0xc]
00002a  280a              CMP      r0,#0xa
00002c  d247              BCS      |L6.190|
00002e  e8dff000          TBB      [pc,r0]
000032  0905              DCB      0x09,0x05
000034  072b2d42          DCB      0x07,0x2b,0x2d,0x42
000038  06082c2e          DCB      0x06,0x08,0x2c,0x2e
;;;655    			{
;;;656    				case tmrCOMMAND_START :
;;;657    			    case tmrCOMMAND_START_FROM_ISR :
00003c  bf00              NOP      
;;;658    			    case tmrCOMMAND_RESET :
00003e  bf00              NOP      
;;;659    			    case tmrCOMMAND_RESET_FROM_ISR :
000040  bf00              NOP      
;;;660    				case tmrCOMMAND_START_DONT_TRACE :
000042  bf00              NOP      
;;;661    					/* Start or restart a timer. */
;;;662    					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
000044  9804              LDR      r0,[sp,#0x10]
000046  69a2              LDR      r2,[r4,#0x18]
000048  1881              ADDS     r1,r0,r2
00004a  4603              MOV      r3,r0
00004c  462a              MOV      r2,r5
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       prvInsertTimerInActiveList
000054  2801              CMP      r0,#1
000056  d116              BNE      |L6.134|
;;;663    					{
;;;664    						/* The timer expired before it was added to the active
;;;665    						timer list.  Process it now. */
;;;666    						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
000058  4620              MOV      r0,r4
00005a  6a61              LDR      r1,[r4,#0x24]
00005c  4788              BLX      r1
;;;667    						traceTIMER_EXPIRED( pxTimer );
;;;668    
;;;669    						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
00005e  69e0              LDR      r0,[r4,#0x1c]
000060  2801              CMP      r0,#1
000062  d110              BNE      |L6.134|
;;;670    						{
;;;671    							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
000064  2000              MOVS     r0,#0
000066  9000              STR      r0,[sp,#0]
000068  9804              LDR      r0,[sp,#0x10]
00006a  69a1              LDR      r1,[r4,#0x18]
00006c  1842              ADDS     r2,r0,r1
00006e  2300              MOVS     r3,#0
000070  4619              MOV      r1,r3
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       xTimerGenericCommand
000078  4606              MOV      r6,r0
;;;672    							configASSERT( xResult );
00007a  b91e              CBNZ     r6,|L6.132|
00007c  f7fffffe          BL       ulPortSetInterruptMask
000080  bf00              NOP      
                  |L6.130|
000082  e7fe              B        |L6.130|
                  |L6.132|
;;;673    							( void ) xResult;
000084  bf00              NOP      
                  |L6.134|
;;;674    						}
;;;675    						else
;;;676    						{
;;;677    							mtCOVERAGE_TEST_MARKER();
;;;678    						}
;;;679    					}
;;;680    					else
;;;681    					{
;;;682    						mtCOVERAGE_TEST_MARKER();
;;;683    					}
;;;684    					break;
000086  e01b              B        |L6.192|
;;;685    
;;;686    				case tmrCOMMAND_STOP :
;;;687    				case tmrCOMMAND_STOP_FROM_ISR :
000088  bf00              NOP      
;;;688    					/* The timer has already been removed from the active list.
;;;689    					There is nothing to do here. */
;;;690    					break;
00008a  e019              B        |L6.192|
;;;691    
;;;692    				case tmrCOMMAND_CHANGE_PERIOD :
;;;693    				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
00008c  bf00              NOP      
;;;694    					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
00008e  9804              LDR      r0,[sp,#0x10]
000090  61a0              STR      r0,[r4,#0x18]
;;;695    					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
000092  69a0              LDR      r0,[r4,#0x18]
000094  b108              CBZ      r0,|L6.154|
000096  2001              MOVS     r0,#1
000098  e000              B        |L6.156|
                  |L6.154|
00009a  2000              MOVS     r0,#0
                  |L6.156|
00009c  b918              CBNZ     r0,|L6.166|
00009e  f7fffffe          BL       ulPortSetInterruptMask
0000a2  bf00              NOP      
                  |L6.164|
0000a4  e7fe              B        |L6.164|
                  |L6.166|
;;;696    
;;;697    					/* The new period does not really have a reference, and can be
;;;698    					longer or shorter than the old one.  The command time is
;;;699    					therefore set to the current time, and as the period cannot be
;;;700    					zero the next expiry time can only be in the future, meaning
;;;701    					(unlike for the xTimerStart() case above) there is no fail case
;;;702    					that needs to be handled here. */
;;;703    					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
0000a6  69a0              LDR      r0,[r4,#0x18]
0000a8  1941              ADDS     r1,r0,r5
0000aa  462b              MOV      r3,r5
0000ac  462a              MOV      r2,r5
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       prvInsertTimerInActiveList
;;;704    					break;
0000b4  e004              B        |L6.192|
;;;705    
;;;706    				case tmrCOMMAND_DELETE :
;;;707    					/* The timer has already been removed from the active list,
;;;708    					just free up the memory. */
;;;709    					vPortFree( pxTimer );
0000b6  4620              MOV      r0,r4
0000b8  f7fffffe          BL       vPortFree
;;;710    					break;
0000bc  e000              B        |L6.192|
                  |L6.190|
;;;711    
;;;712    				default	:
;;;713    					/* Don't expect to get here. */
;;;714    					break;
0000be  bf00              NOP      
                  |L6.192|
0000c0  bf00              NOP                            ;684
                  |L6.194|
0000c2  2300              MOVS     r3,#0                 ;602
0000c4  461a              MOV      r2,r3                 ;602
0000c6  a903              ADD      r1,sp,#0xc            ;602
0000c8  4803              LDR      r0,|L6.216|
0000ca  6800              LDR      r0,[r0,#0]            ;602  ; xTimerQueue
0000cc  f7fffffe          BL       xQueueGenericReceive
0000d0  2800              CMP      r0,#0                 ;602
0000d2  d198              BNE      |L6.6|
;;;715    			}
;;;716    		}
;;;717    	}
;;;718    }
0000d4  b006              ADD      sp,sp,#0x18
0000d6  bd70              POP      {r4-r6,pc}
;;;719    /*-----------------------------------------------------------*/
                          ENDP

                  |L6.216|
                          DCD      xTimerQueue

                          AREA ||i.prvProcessTimerOrBlockTask||, CODE, READONLY, ALIGN=2

                  prvProcessTimerOrBlockTask PROC
;;;444    
;;;445    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
000000  b5f8              PUSH     {r3-r7,lr}
;;;446    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;447    TickType_t xTimeNow;
;;;448    BaseType_t xTimerListsWereSwitched;
;;;449    
;;;450    	vTaskSuspendAll();
000006  f7fffffe          BL       vTaskSuspendAll
;;;451    	{
;;;452    		/* Obtain the time now to make an assessment as to whether the timer
;;;453    		has expired or not.  If obtaining the time causes the lists to switch
;;;454    		then don't process this timer as any timers that remained in the list
;;;455    		when the lists were switched will have been processed within the
;;;456    		prvSampleTimeNow() function. */
;;;457    		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       prvSampleTimeNow
000010  4606              MOV      r6,r0
;;;458    		if( xTimerListsWereSwitched == pdFALSE )
000012  9800              LDR      r0,[sp,#0]
000014  b9f0              CBNZ     r0,|L7.84|
;;;459    		{
;;;460    			/* The tick count has not overflowed, has the timer expired? */
;;;461    			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
000016  b944              CBNZ     r4,|L7.42|
000018  42b5              CMP      r5,r6
00001a  d806              BHI      |L7.42|
;;;462    			{
;;;463    				( void ) xTaskResumeAll();
00001c  f7fffffe          BL       xTaskResumeAll
;;;464    				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
000020  4631              MOV      r1,r6
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       prvProcessExpiredTimer
000028  e016              B        |L7.88|
                  |L7.42|
;;;465    			}
;;;466    			else
;;;467    			{
;;;468    				/* The tick count has not overflowed, and the next expire
;;;469    				time has not been reached yet.  This task should therefore
;;;470    				block to wait for the next expire time or a command to be
;;;471    				received - whichever comes first.  The following line cannot
;;;472    				be reached unless xNextExpireTime > xTimeNow, except in the
;;;473    				case when the current timer list is empty. */
;;;474    				if( xListWasEmpty != pdFALSE )
00002a  b13c              CBZ      r4,|L7.60|
;;;475    				{
;;;476    					/* The current timer list is empty - is the overflow list
;;;477    					also empty? */
;;;478    					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
00002c  480b              LDR      r0,|L7.92|
00002e  6800              LDR      r0,[r0,#0]  ; pxOverflowTimerList
000030  6800              LDR      r0,[r0,#0]
000032  b908              CBNZ     r0,|L7.56|
000034  2001              MOVS     r0,#1
000036  e000              B        |L7.58|
                  |L7.56|
000038  2000              MOVS     r0,#0
                  |L7.58|
00003a  4604              MOV      r4,r0
                  |L7.60|
;;;479    				}
;;;480    
;;;481    				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
00003c  1ba9              SUBS     r1,r5,r6
00003e  4622              MOV      r2,r4
000040  4807              LDR      r0,|L7.96|
000042  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000044  f7fffffe          BL       vQueueWaitForMessageRestricted
;;;482    
;;;483    				if( xTaskResumeAll() == pdFALSE )
000048  f7fffffe          BL       xTaskResumeAll
00004c  b920              CBNZ     r0,|L7.88|
;;;484    				{
;;;485    					/* Yield to wait for either a command to arrive, or the
;;;486    					block time to expire.  If a command arrived between the
;;;487    					critical section being exited and this yield then the yield
;;;488    					will not cause the task to block. */
;;;489    					portYIELD_WITHIN_API();
00004e  f7fffffe          BL       vPortYield
000052  e001              B        |L7.88|
                  |L7.84|
;;;490    				}
;;;491    				else
;;;492    				{
;;;493    					mtCOVERAGE_TEST_MARKER();
;;;494    				}
;;;495    			}
;;;496    		}
;;;497    		else
;;;498    		{
;;;499    			( void ) xTaskResumeAll();
000054  f7fffffe          BL       xTaskResumeAll
                  |L7.88|
;;;500    		}
;;;501    	}
;;;502    }
000058  bdf8              POP      {r3-r7,pc}
;;;503    /*-----------------------------------------------------------*/
                          ENDP

00005a  0000              DCW      0x0000
                  |L7.92|
                          DCD      pxOverflowTimerList
                  |L7.96|
                          DCD      xTimerQueue

                          AREA ||i.prvSampleTimeNow||, CODE, READONLY, ALIGN=2

                  prvSampleTimeNow PROC
;;;530    
;;;531    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
000000  b570              PUSH     {r4-r6,lr}
;;;532    {
000002  4604              MOV      r4,r0
;;;533    TickType_t xTimeNow;
;;;534    PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
;;;535    
;;;536    	xTimeNow = xTaskGetTickCount();
000004  f7fffffe          BL       xTaskGetTickCount
000008  4605              MOV      r5,r0
;;;537    
;;;538    	if( xTimeNow < xLastTime )
00000a  4807              LDR      r0,|L8.40|
00000c  6800              LDR      r0,[r0,#0]  ; xLastTime
00000e  4285              CMP      r5,r0
000010  d204              BCS      |L8.28|
;;;539    	{
;;;540    		prvSwitchTimerLists();
000012  f7fffffe          BL       prvSwitchTimerLists
;;;541    		*pxTimerListsWereSwitched = pdTRUE;
000016  2001              MOVS     r0,#1
000018  6020              STR      r0,[r4,#0]
00001a  e001              B        |L8.32|
                  |L8.28|
;;;542    	}
;;;543    	else
;;;544    	{
;;;545    		*pxTimerListsWereSwitched = pdFALSE;
00001c  2000              MOVS     r0,#0
00001e  6020              STR      r0,[r4,#0]
                  |L8.32|
;;;546    	}
;;;547    
;;;548    	xLastTime = xTimeNow;
000020  4801              LDR      r0,|L8.40|
000022  6005              STR      r5,[r0,#0]  ; xLastTime
;;;549    
;;;550    	return xTimeNow;
000024  4628              MOV      r0,r5
;;;551    }
000026  bd70              POP      {r4-r6,pc}
;;;552    /*-----------------------------------------------------------*/
                          ENDP

                  |L8.40|
                          DCD      xLastTime

                          AREA ||i.prvSwitchTimerLists||, CODE, READONLY, ALIGN=2

                  prvSwitchTimerLists PROC
;;;720    
;;;721    static void prvSwitchTimerLists( void )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;722    {
;;;723    TickType_t xNextExpireTime, xReloadTime;
;;;724    List_t *pxTemp;
;;;725    Timer_t *pxTimer;
;;;726    BaseType_t xResult;
;;;727    
;;;728    	/* The tick count has overflowed.  The timer lists must be switched.
;;;729    	If there are any timers still referenced from the current timer list
;;;730    	then they must have expired and should be processed before the lists
;;;731    	are switched. */
;;;732    	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
000004  e02b              B        |L9.94|
                  |L9.6|
;;;733    	{
;;;734    		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
000006  4820              LDR      r0,|L9.136|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  6805              LDR      r5,[r0,#0]
;;;735    
;;;736    		/* Remove the timer from the list. */
;;;737    		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
00000e  481e              LDR      r0,|L9.136|
000010  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
000012  68c0              LDR      r0,[r0,#0xc]
000014  68c4              LDR      r4,[r0,#0xc]
;;;738    		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
000016  1d20              ADDS     r0,r4,#4
000018  f7fffffe          BL       uxListRemove
;;;739    		traceTIMER_EXPIRED( pxTimer );
;;;740    
;;;741    		/* Execute its callback, then send a command to restart the timer if
;;;742    		it is an auto-reload timer.  It cannot be restarted here as the lists
;;;743    		have not yet been switched. */
;;;744    		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
00001c  4620              MOV      r0,r4
00001e  6a61              LDR      r1,[r4,#0x24]
000020  4788              BLX      r1
;;;745    
;;;746    		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
000022  69e0              LDR      r0,[r4,#0x1c]
000024  2801              CMP      r0,#1
000026  d11a              BNE      |L9.94|
;;;747    		{
;;;748    			/* Calculate the reload value, and if the reload value results in
;;;749    			the timer going into the same timer list then it has already expired
;;;750    			and the timer should be re-inserted into the current list so it is
;;;751    			processed again within this loop.  Otherwise a command should be sent
;;;752    			to restart the timer to ensure it is only inserted into a list after
;;;753    			the lists have been swapped. */
;;;754    			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
000028  69a0              LDR      r0,[r4,#0x18]
00002a  1946              ADDS     r6,r0,r5
;;;755    			if( xReloadTime > xNextExpireTime )
00002c  42ae              CMP      r6,r5
00002e  d907              BLS      |L9.64|
;;;756    			{
;;;757    				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
000030  6066              STR      r6,[r4,#4]
;;;758    				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
000032  6124              STR      r4,[r4,#0x10]
;;;759    				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
000034  1d21              ADDS     r1,r4,#4
000036  4814              LDR      r0,|L9.136|
000038  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
00003a  f7fffffe          BL       vListInsert
00003e  e00e              B        |L9.94|
                  |L9.64|
;;;760    			}
;;;761    			else
;;;762    			{
;;;763    				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
000040  2000              MOVS     r0,#0
000042  4603              MOV      r3,r0
000044  462a              MOV      r2,r5
000046  4601              MOV      r1,r0
000048  9000              STR      r0,[sp,#0]
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       xTimerGenericCommand
000050  4607              MOV      r7,r0
;;;764    				configASSERT( xResult );
000052  b91f              CBNZ     r7,|L9.92|
000054  f7fffffe          BL       ulPortSetInterruptMask
000058  bf00              NOP      
                  |L9.90|
00005a  e7fe              B        |L9.90|
                  |L9.92|
;;;765    				( void ) xResult;
00005c  bf00              NOP      
                  |L9.94|
00005e  480a              LDR      r0,|L9.136|
000060  6800              LDR      r0,[r0,#0]            ;732  ; pxCurrentTimerList
000062  6800              LDR      r0,[r0,#0]            ;732
000064  b908              CBNZ     r0,|L9.106|
000066  2001              MOVS     r0,#1                 ;732
000068  e000              B        |L9.108|
                  |L9.106|
00006a  2000              MOVS     r0,#0                 ;732
                  |L9.108|
00006c  2800              CMP      r0,#0                 ;732
00006e  d0ca              BEQ      |L9.6|
;;;766    			}
;;;767    		}
;;;768    		else
;;;769    		{
;;;770    			mtCOVERAGE_TEST_MARKER();
;;;771    		}
;;;772    	}
;;;773    
;;;774    	pxTemp = pxCurrentTimerList;
000070  4805              LDR      r0,|L9.136|
000072  f8d08000          LDR      r8,[r0,#0]  ; pxCurrentTimerList
;;;775    	pxCurrentTimerList = pxOverflowTimerList;
000076  4805              LDR      r0,|L9.140|
000078  6800              LDR      r0,[r0,#0]  ; pxOverflowTimerList
00007a  4903              LDR      r1,|L9.136|
00007c  6008              STR      r0,[r1,#0]  ; pxCurrentTimerList
;;;776    	pxOverflowTimerList = pxTemp;
00007e  4803              LDR      r0,|L9.140|
000080  f8c08000          STR      r8,[r0,#0]  ; pxOverflowTimerList
;;;777    }
000084  e8bd83f8          POP      {r3-r9,pc}
;;;778    /*-----------------------------------------------------------*/
                          ENDP

                  |L9.136|
                          DCD      pxCurrentTimerList
                  |L9.140|
                          DCD      pxOverflowTimerList

                          AREA ||i.prvTimerTask||, CODE, READONLY, ALIGN=1

                  prvTimerTask PROC
;;;420    
;;;421    static void prvTimerTask( void *pvParameters )
000000  b508              PUSH     {r3,lr}
;;;422    {
;;;423    TickType_t xNextExpireTime;
;;;424    BaseType_t xListWasEmpty;
;;;425    
;;;426    	/* Just to avoid compiler warnings. */
;;;427    	( void ) pvParameters;
;;;428    
;;;429    	for( ;; )
000002  bf00              NOP      
                  |L10.4|
;;;430    	{
;;;431    		/* Query the timers list to see if it contains any timers, and if so,
;;;432    		obtain the time at which the next timer will expire. */
;;;433    		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       prvGetNextExpireTime
00000a  4604              MOV      r4,r0
;;;434    
;;;435    		/* If a timer has expired, process it.  Otherwise, block this task
;;;436    		until either a timer does expire, or a command is received. */
;;;437    		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
00000c  4620              MOV      r0,r4
00000e  9900              LDR      r1,[sp,#0]
000010  f7fffffe          BL       prvProcessTimerOrBlockTask
;;;438    
;;;439    		/* Empty the command queue. */
;;;440    		prvProcessReceivedCommands();
000014  f7fffffe          BL       prvProcessReceivedCommands
000018  e7f4              B        |L10.4|
;;;441    	}
;;;442    }
;;;443    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.pvTimerGetTimerID||, CODE, READONLY, ALIGN=1

                  pvTimerGetTimerID PROC
;;;838    
;;;839    void *pvTimerGetTimerID( const TimerHandle_t xTimer )
000000  b570              PUSH     {r4-r6,lr}
;;;840    {
000002  4604              MOV      r4,r0
;;;841    Timer_t * const pxTimer = ( Timer_t * ) xTimer;
000004  4626              MOV      r6,r4
;;;842    void *pvReturn;
;;;843    
;;;844    	configASSERT( xTimer );
000006  b91c              CBNZ     r4,|L11.16|
000008  f7fffffe          BL       ulPortSetInterruptMask
00000c  bf00              NOP      
                  |L11.14|
00000e  e7fe              B        |L11.14|
                  |L11.16|
;;;845    
;;;846    	taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;847    	{
;;;848    		pvReturn = pxTimer->pvTimerID;
000014  6a35              LDR      r5,[r6,#0x20]
;;;849    	}
;;;850    	taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;851    
;;;852    	return pvReturn;
00001a  4628              MOV      r0,r5
;;;853    }
00001c  bd70              POP      {r4-r6,pc}
;;;854    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vTimerSetTimerID||, CODE, READONLY, ALIGN=1

                  vTimerSetTimerID PROC
;;;855    
;;;856    void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
000000  b570              PUSH     {r4-r6,lr}
;;;857    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;858    Timer_t * const pxTimer = ( Timer_t * ) xTimer;
000006  4626              MOV      r6,r4
;;;859    
;;;860    	configASSERT( xTimer );
000008  b91c              CBNZ     r4,|L12.18|
00000a  f7fffffe          BL       ulPortSetInterruptMask
00000e  bf00              NOP      
                  |L12.16|
000010  e7fe              B        |L12.16|
                  |L12.18|
;;;861    
;;;862    	taskENTER_CRITICAL();
000012  f7fffffe          BL       vPortEnterCritical
;;;863    	{
;;;864    		pxTimer->pvTimerID = pvNewID;
000016  6235              STR      r5,[r6,#0x20]
;;;865    	}
;;;866    	taskEXIT_CRITICAL();
000018  f7fffffe          BL       vPortExitCritical
;;;867    }
00001c  bd70              POP      {r4-r6,pc}
;;;868    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xTimerCreate||, CODE, READONLY, ALIGN=1

                  xTimerCreate PROC
;;;274    
;;;275    TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;276    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;277    Timer_t *pxNewTimer;
;;;278    
;;;279    	/* Allocate the timer structure. */
;;;280    	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
000010  b90d              CBNZ     r5,|L13.22|
;;;281    	{
;;;282    		pxNewTimer = NULL;
000012  2400              MOVS     r4,#0
000014  e010              B        |L13.56|
                  |L13.22|
;;;283    	}
;;;284    	else
;;;285    	{
;;;286    		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
000016  2028              MOVS     r0,#0x28
000018  f7fffffe          BL       pvPortMalloc
00001c  4604              MOV      r4,r0
;;;287    		if( pxNewTimer != NULL )
00001e  b15c              CBZ      r4,|L13.56|
;;;288    		{
;;;289    			/* Ensure the infrastructure used by the timer service task has been
;;;290    			created/initialised. */
;;;291    			prvCheckForValidListAndQueue();
000020  f7fffffe          BL       prvCheckForValidListAndQueue
;;;292    
;;;293    			/* Initialise the timer structure members using the function parameters. */
;;;294    			pxNewTimer->pcTimerName = pcTimerName;
000024  6026              STR      r6,[r4,#0]
;;;295    			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
000026  61a5              STR      r5,[r4,#0x18]
;;;296    			pxNewTimer->uxAutoReload = uxAutoReload;
000028  61e7              STR      r7,[r4,#0x1c]
;;;297    			pxNewTimer->pvTimerID = pvTimerID;
00002a  f8c48020          STR      r8,[r4,#0x20]
;;;298    			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
00002e  f8c49024          STR      r9,[r4,#0x24]
;;;299    			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
000032  1d20              ADDS     r0,r4,#4
000034  f7fffffe          BL       vListInitialiseItem
                  |L13.56|
;;;300    
;;;301    			traceTIMER_CREATE( pxNewTimer );
;;;302    		}
;;;303    		else
;;;304    		{
;;;305    			traceTIMER_CREATE_FAILED();
;;;306    		}
;;;307    	}
;;;308    
;;;309    	/* 0 is not a valid value for xTimerPeriodInTicks. */
;;;310    	configASSERT( ( xTimerPeriodInTicks > 0 ) );
000038  b10d              CBZ      r5,|L13.62|
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L13.64|
                  |L13.62|
00003e  2000              MOVS     r0,#0
                  |L13.64|
000040  b918              CBNZ     r0,|L13.74|
000042  f7fffffe          BL       ulPortSetInterruptMask
000046  bf00              NOP      
                  |L13.72|
000048  e7fe              B        |L13.72|
                  |L13.74|
;;;311    
;;;312    	return ( TimerHandle_t ) pxNewTimer;
00004a  4620              MOV      r0,r4
;;;313    }
00004c  e8bd87f0          POP      {r4-r10,pc}
;;;314    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xTimerCreateTimerTask||, CODE, READONLY, ALIGN=2

                  xTimerCreateTimerTask PROC
;;;239    
;;;240    BaseType_t xTimerCreateTimerTask( void )
000000  b51f              PUSH     {r0-r4,lr}
;;;241    {
;;;242    BaseType_t xReturn = pdFAIL;
000002  2400              MOVS     r4,#0
;;;243    
;;;244    	/* This function is called when the scheduler is started if
;;;245    	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
;;;246    	timer service task has been created/initialised.  If timers have already
;;;247    	been created then the initialisation will already have been performed. */
;;;248    	prvCheckForValidListAndQueue();
000004  f7fffffe          BL       prvCheckForValidListAndQueue
;;;249    
;;;250    	if( xTimerQueue != NULL )
000008  480c              LDR      r0,|L14.60|
00000a  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00000c  b168              CBZ      r0,|L14.42|
;;;251    	{
;;;252    		#if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
;;;253    		{
;;;254    			/* Create the timer task, storing its handle in xTimerTaskHandle so
;;;255    			it can be returned by the xTimerGetTimerDaemonTaskHandle() function. */
;;;256    			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
;;;257    		}
;;;258    		#else
;;;259    		{
;;;260    			/* Create the timer task without storing its handle. */
;;;261    			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
00000e  2000              MOVS     r0,#0
000010  2302              MOVS     r3,#2
000012  e9cd3000          STRD     r3,r0,[sp,#0]
000016  9002              STR      r0,[sp,#8]
000018  4603              MOV      r3,r0
00001a  f44f7280          MOV      r2,#0x100
00001e  a108              ADR      r1,|L14.64|
000020  9003              STR      r0,[sp,#0xc]
000022  4809              LDR      r0,|L14.72|
000024  f7fffffe          BL       xTaskGenericCreate
000028  4604              MOV      r4,r0
                  |L14.42|
;;;262    		}
;;;263    		#endif
;;;264    	}
;;;265    	else
;;;266    	{
;;;267    		mtCOVERAGE_TEST_MARKER();
;;;268    	}
;;;269    
;;;270    	configASSERT( xReturn );
00002a  b91c              CBNZ     r4,|L14.52|
00002c  f7fffffe          BL       ulPortSetInterruptMask
000030  bf00              NOP      
                  |L14.50|
000032  e7fe              B        |L14.50|
                  |L14.52|
;;;271    	return xReturn;
000034  4620              MOV      r0,r4
;;;272    }
000036  b004              ADD      sp,sp,#0x10
000038  bd10              POP      {r4,pc}
;;;273    /*-----------------------------------------------------------*/
                          ENDP

00003a  0000              DCW      0x0000
                  |L14.60|
                          DCD      xTimerQueue
                  |L14.64|
000040  546d7220          DCB      "Tmr Svc",0
000044  53766300
                  |L14.72|
                          DCD      prvTimerTask

                          AREA ||i.xTimerGenericCommand||, CODE, READONLY, ALIGN=2

                  xTimerGenericCommand PROC
;;;315    
;;;316    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;317    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
;;;318    BaseType_t xReturn = pdFAIL;
000010  f04f0900          MOV      r9,#0
;;;319    DaemonTaskMessage_t xMessage;
;;;320    
;;;321    	configASSERT( xTimer );
000014  b91c              CBNZ     r4,|L15.30|
000016  f7fffffe          BL       ulPortSetInterruptMask
00001a  bf00              NOP      
                  |L15.28|
00001c  e7fe              B        |L15.28|
                  |L15.30|
;;;322    
;;;323    	/* Send a message to the timer service task to perform a particular action
;;;324    	on a particular timer definition. */
;;;325    	if( xTimerQueue != NULL )
00001e  4814              LDR      r0,|L15.112|
000020  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000022  b310              CBZ      r0,|L15.106|
;;;326    	{
;;;327    		/* Send a command to the timer service task to start the xTimer timer. */
;;;328    		xMessage.xMessageID = xCommandID;
000024  9500              STR      r5,[sp,#0]
;;;329    		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
000026  9601              STR      r6,[sp,#4]
;;;330    		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
000028  9402              STR      r4,[sp,#8]
;;;331    
;;;332    		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
00002a  2d06              CMP      r5,#6
00002c  da15              BGE      |L15.90|
;;;333    		{
;;;334    			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
00002e  f7fffffe          BL       xTaskGetSchedulerState
000032  2802              CMP      r0,#2
000034  d108              BNE      |L15.72|
;;;335    			{
;;;336    				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
000036  2300              MOVS     r3,#0
000038  4642              MOV      r2,r8
00003a  4669              MOV      r1,sp
00003c  480c              LDR      r0,|L15.112|
00003e  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000040  f7fffffe          BL       xQueueGenericSend
000044  4681              MOV      r9,r0
000046  e010              B        |L15.106|
                  |L15.72|
;;;337    			}
;;;338    			else
;;;339    			{
;;;340    				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
000048  2300              MOVS     r3,#0
00004a  461a              MOV      r2,r3
00004c  4669              MOV      r1,sp
00004e  4808              LDR      r0,|L15.112|
000050  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000052  f7fffffe          BL       xQueueGenericSend
000056  4681              MOV      r9,r0
000058  e007              B        |L15.106|
                  |L15.90|
;;;341    			}
;;;342    		}
;;;343    		else
;;;344    		{
;;;345    			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
00005a  2300              MOVS     r3,#0
00005c  463a              MOV      r2,r7
00005e  4669              MOV      r1,sp
000060  4803              LDR      r0,|L15.112|
000062  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000064  f7fffffe          BL       xQueueGenericSendFromISR
000068  4681              MOV      r9,r0
                  |L15.106|
;;;346    		}
;;;347    
;;;348    		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
;;;349    	}
;;;350    	else
;;;351    	{
;;;352    		mtCOVERAGE_TEST_MARKER();
;;;353    	}
;;;354    
;;;355    	return xReturn;
00006a  4648              MOV      r0,r9
;;;356    }
00006c  e8bd83fe          POP      {r1-r9,pc}
;;;357    /*-----------------------------------------------------------*/
                          ENDP

                  |L15.112|
                          DCD      xTimerQueue

                          AREA ||i.xTimerIsTimerActive||, CODE, READONLY, ALIGN=1

                  xTimerIsTimerActive PROC
;;;817    
;;;818    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
000000  b570              PUSH     {r4-r6,lr}
;;;819    {
000002  4604              MOV      r4,r0
;;;820    BaseType_t xTimerIsInActiveList;
;;;821    Timer_t *pxTimer = ( Timer_t * ) xTimer;
000004  4626              MOV      r6,r4
;;;822    
;;;823    	configASSERT( xTimer );
000006  b91c              CBNZ     r4,|L16.16|
000008  f7fffffe          BL       ulPortSetInterruptMask
00000c  bf00              NOP      
                  |L16.14|
00000e  e7fe              B        |L16.14|
                  |L16.16|
;;;824    
;;;825    	/* Is the timer in the list of active timers? */
;;;826    	taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;827    	{
;;;828    		/* Checking to see if it is in the NULL list in effect checks to see if
;;;829    		it is referenced from either the current or the overflow timer lists in
;;;830    		one go, but the logic has to be reversed, hence the '!'. */
;;;831    		xTimerIsInActiveList = ( BaseType_t ) !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
000014  6970              LDR      r0,[r6,#0x14]
000016  b908              CBNZ     r0,|L16.28|
000018  2001              MOVS     r0,#1
00001a  e000              B        |L16.30|
                  |L16.28|
00001c  2000              MOVS     r0,#0
                  |L16.30|
00001e  f0800501          EOR      r5,r0,#1
;;;832    	}
;;;833    	taskEXIT_CRITICAL();
000022  f7fffffe          BL       vPortExitCritical
;;;834    
;;;835    	return xTimerIsInActiveList;
000026  4628              MOV      r0,r5
;;;836    } /*lint !e818 Can't be pointer to const due to the typedef. */
000028  bd70              POP      {r4-r6,pc}
;;;837    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  xActiveTimerList1
                          %        20
                  xActiveTimerList2
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTimerList
                          DCD      0x00000000
                  pxOverflowTimerList
                          DCD      0x00000000
                  xTimerQueue
                          DCD      0x00000000
                  xLastTime
                          DCD      0x00000000
