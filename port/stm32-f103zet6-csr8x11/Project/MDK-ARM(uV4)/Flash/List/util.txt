; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\util.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\util.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\Middleware\blue_angel\inc -I..\..\Middleware\bt_callback_manager -I..\..\Middleware\blue_angel\btif -I..\..\Middleware\blue_angel\common -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\blue_angel\src\common -I..\..\Middleware\blue_angel\src\inc -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\blue_angel\platform\rtos -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\ut_manager\Cunit\Headers -I..\..\Middleware\ut_manager\Cunit\interface -I..\..\Middleware\blue_angel\platform\test -I..\..\Middleware\blue_angel\driver -I..\..\Middleware\blue_angel\src\core\hci -I..\..\User\bt\inc -I..\..\Middleware\bt_callback_manager -I..\..\Middleware\at_command -I..\..\Middleware\blue_angel\src\core\gap -I..\..\Middleware\blue_angel\src\core\l2cap -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=522 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DNDEBUG --omf_browse=.\flash\obj\util.crf ..\..\Middleware\ut_manager\Cunit\Sources\Framework\Util.c]
                          THUMB

                          AREA ||i.CU_compare_strings||, CODE, READONLY, ALIGN=1

                  CU_compare_strings PROC
;;;184    /*------------------------------------------------------------------------*/
;;;185    int CU_compare_strings(const char* szSrc, const char* szDest)
000000  b570              PUSH     {r4-r6,lr}
;;;186    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;187      assert(NULL != szSrc);
;;;188      assert(NULL != szDest);
;;;189    
;;;190    	while (('\0' != *szSrc) && ('\0' != *szDest) && (toupper(*szSrc) == toupper(*szDest))) {
000006  e001              B        |L1.12|
                  |L1.8|
;;;191    		szSrc++;
000008  1c64              ADDS     r4,r4,#1
;;;192    		szDest++;
00000a  1c6d              ADDS     r5,r5,#1
                  |L1.12|
00000c  7820              LDRB     r0,[r4,#0]            ;190
00000e  b150              CBZ      r0,|L1.38|
000010  7828              LDRB     r0,[r5,#0]            ;190
000012  b140              CBZ      r0,|L1.38|
000014  7820              LDRB     r0,[r4,#0]            ;190
000016  f7fffffe          BL       toupper
00001a  4606              MOV      r6,r0                 ;190
00001c  7828              LDRB     r0,[r5,#0]            ;190
00001e  f7fffffe          BL       toupper
000022  4286              CMP      r6,r0                 ;190
000024  d0f0              BEQ      |L1.8|
                  |L1.38|
;;;193    	}
;;;194    
;;;195    	return (int)(*szSrc - *szDest);
000026  7820              LDRB     r0,[r4,#0]
000028  7829              LDRB     r1,[r5,#0]
00002a  1a40              SUBS     r0,r0,r1
;;;196    }
00002c  bd70              POP      {r4-r6,pc}
;;;197    
                          ENDP


                          AREA ||i.CU_number_width||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  CU_number_width PROC
;;;244    /*------------------------------------------------------------------------*/
;;;245    size_t CU_number_width(int number)
000000  b510              PUSH     {r4,lr}
;;;246    {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
;;;247    	char buf[33];
;;;248    
;;;249    	snprintf(buf, 33, "%d", number);
000006  4623              MOV      r3,r4
000008  a206              ADR      r2,|L2.36|
00000a  2121              MOVS     r1,#0x21
00000c  a801              ADD      r0,sp,#4
00000e  f7fffffe          BL       __2snprintf
;;;250    	buf[32] = '\0';
000012  2000              MOVS     r0,#0
000014  f88d0024          STRB     r0,[sp,#0x24]
;;;251    	return (strlen(buf));
000018  a801              ADD      r0,sp,#4
00001a  f7fffffe          BL       strlen
;;;252    }
00001e  b00a              ADD      sp,sp,#0x28
000020  bd10              POP      {r4,pc}
;;;253    
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
000024  256400            DCB      "%d",0
000027  00                DCB      0

                          AREA ||i.CU_translate_special_characters||, CODE, READONLY, ALIGN=2

                  CU_translate_special_characters PROC
;;;94     
;;;95     size_t CU_translate_special_characters(const char *szSrc, char *szDest, size_t maxlen)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;96     {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;97     /* old implementation
;;;98       size_t count = 0;
;;;99     	size_t src = 0;
;;;100    	size_t dest = 0;
;;;101    	size_t length = 0;
;;;102    	int conv_index;
;;;103    
;;;104      assert(NULL != szSrc);
;;;105      assert(NULL != szDest);
;;;106    
;;;107    	length = strlen(szSrc);
;;;108    	memset(szDest, 0, maxlen);
;;;109    	while ((dest < maxlen) && (src < length)) {
;;;110    
;;;111    		if ((-1 != (conv_index = get_index(szSrc[src]))) &&
;;;112            ((dest + strlen(CU_bindings[conv_index].replacement)) < maxlen)) {
;;;113    			strcat(szDest, CU_bindings[conv_index].replacement);
;;;114    			dest += strlen(CU_bindings[conv_index].replacement);
;;;115    			++count;
;;;116    		} else {
;;;117    			szDest[dest++] = szSrc[src];
;;;118    		}
;;;119    
;;;120    		++src;
;;;121    	}
;;;122    
;;;123    	return count;
;;;124    */
;;;125      size_t count = 0;
00000a  f04f0900          MOV      r9,#0
;;;126      size_t repl_len;
;;;127      int conv_index;
;;;128      char *dest_start = szDest;
00000e  46a2              MOV      r10,r4
;;;129    
;;;130      assert(NULL != szSrc);
;;;131      assert(NULL != szDest);
;;;132    
;;;133      /* only process if destination buffer not 0-length */
;;;134      if (maxlen > 0) {
000010  2d00              CMP      r5,#0
000012  d031              BEQ      |L3.120|
;;;135    
;;;136        while ((maxlen > 0) && (*szSrc != '\0')) {
000014  e023              B        |L3.94|
                  |L3.22|
;;;137          conv_index = get_index(*szSrc);
000016  7830              LDRB     r0,[r6,#0]
000018  f7fffffe          BL       get_index
00001c  4680              MOV      r8,r0
;;;138          if (-1 != conv_index) {
00001e  f1b83fff          CMP      r8,#0xffffffff
000022  d017              BEQ      |L3.84|
;;;139            if (maxlen > (repl_len = strlen(CU_bindings[conv_index].replacement))) {
000024  4916              LDR      r1,|L3.128|
000026  eb0101c8          ADD      r1,r1,r8,LSL #3
00002a  6848              LDR      r0,[r1,#4]
00002c  f7fffffe          BL       strlen
000030  4607              MOV      r7,r0
000032  42a8              CMP      r0,r5
000034  d20c              BCS      |L3.80|
;;;140    			    memcpy(szDest, CU_bindings[conv_index].replacement, repl_len);
000036  4812              LDR      r0,|L3.128|
000038  eb0000c8          ADD      r0,r0,r8,LSL #3
00003c  463a              MOV      r2,r7
00003e  6841              LDR      r1,[r0,#4]
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       __aeabi_memcpy
;;;141    			    szDest += repl_len;
000046  443c              ADD      r4,r4,r7
;;;142              maxlen -= repl_len;
000048  1bed              SUBS     r5,r5,r7
;;;143    			    ++count;
00004a  f1090901          ADD      r9,r9,#1
00004e  e005              B        |L3.92|
                  |L3.80|
;;;144            } else {
;;;145              maxlen = 0;   /* ran out of room - abort conversion */
000050  2500              MOVS     r5,#0
;;;146              break;
000052  e008              B        |L3.102|
                  |L3.84|
;;;147            }
;;;148    		  } else {
;;;149    			  *szDest++ = *szSrc;
000054  7830              LDRB     r0,[r6,#0]
000056  f8040b01          STRB     r0,[r4],#1
;;;150            --maxlen;
00005a  1e6d              SUBS     r5,r5,#1
                  |L3.92|
;;;151    		  }
;;;152    		  ++szSrc;
00005c  1c76              ADDS     r6,r6,#1
                  |L3.94|
00005e  b115              CBZ      r5,|L3.102|
000060  7830              LDRB     r0,[r6,#0]            ;136
000062  2800              CMP      r0,#0                 ;136
000064  d1d7              BNE      |L3.22|
                  |L3.102|
000066  bf00              NOP                            ;146
;;;153    	  }
;;;154    
;;;155        if (0 == maxlen) {
000068  b925              CBNZ     r5,|L3.116|
;;;156          *dest_start = '\0';   /* ran out of room - return empty string in szDest */
00006a  2000              MOVS     r0,#0
00006c  f88a0000          STRB     r0,[r10,#0]
;;;157          count = 0;
000070  4681              MOV      r9,r0
000072  e001              B        |L3.120|
                  |L3.116|
;;;158        } else {
;;;159          *szDest = '\0';       /* had room - make sure szDest has a terminating \0 */
000074  2000              MOVS     r0,#0
000076  7020              STRB     r0,[r4,#0]
                  |L3.120|
;;;160        }
;;;161      }
;;;162    	return count;
000078  4648              MOV      r0,r9
;;;163    }
00007a  e8bd87f0          POP      {r4-r10,pc}
;;;164    
                          ENDP

00007e  0000              DCW      0x0000
                  |L3.128|
                          DCD      CU_bindings

                          AREA ||i.CU_translated_strlen||, CODE, READONLY, ALIGN=2

                  CU_translated_strlen PROC
;;;165    /*------------------------------------------------------------------------*/
;;;166    size_t CU_translated_strlen(const char* szSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;167    {
000002  4604              MOV      r4,r0
;;;168    	size_t count = 0;
000004  2500              MOVS     r5,#0
;;;169      int conv_index;
;;;170    
;;;171      assert(NULL != szSrc);
;;;172    
;;;173    	while (*szSrc != '\0') {
000006  e010              B        |L4.42|
                  |L4.8|
;;;174        if (-1 != (conv_index = get_index(*szSrc))) {
000008  7820              LDRB     r0,[r4,#0]
00000a  f7fffffe          BL       get_index
00000e  4606              MOV      r6,r0
000010  f1b03fff          CMP      r0,#0xffffffff
000014  d007              BEQ      |L4.38|
;;;175          count += strlen(CU_bindings[conv_index].replacement);
000016  4907              LDR      r1,|L4.52|
000018  eb0101c6          ADD      r1,r1,r6,LSL #3
00001c  6848              LDR      r0,[r1,#4]
00001e  f7fffffe          BL       strlen
000022  4405              ADD      r5,r5,r0
000024  e000              B        |L4.40|
                  |L4.38|
;;;176        } else {
;;;177          ++count;
000026  1c6d              ADDS     r5,r5,#1
                  |L4.40|
;;;178        }
;;;179        ++szSrc;
000028  1c64              ADDS     r4,r4,#1
                  |L4.42|
00002a  7820              LDRB     r0,[r4,#0]            ;173
00002c  2800              CMP      r0,#0                 ;173
00002e  d1eb              BNE      |L4.8|
;;;180      }
;;;181    	return count;
000030  4628              MOV      r0,r5
;;;182    }
000032  bd70              POP      {r4-r6,pc}
;;;183    
                          ENDP

                  |L4.52|
                          DCD      CU_bindings

                          AREA ||i.CU_trim||, CODE, READONLY, ALIGN=1

                  CU_trim PROC
;;;198    /*------------------------------------------------------------------------*/
;;;199    void CU_trim(char* szString)
000000  b510              PUSH     {r4,lr}
;;;200    {
000002  4604              MOV      r4,r0
;;;201    	CU_trim_left(szString);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CU_trim_left
;;;202    	CU_trim_right(szString);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       CU_trim_right
;;;203    }
000010  bd10              POP      {r4,pc}
;;;204    
                          ENDP


                          AREA ||i.CU_trim_left||, CODE, READONLY, ALIGN=1

                  CU_trim_left PROC
;;;205    /*------------------------------------------------------------------------*/
;;;206    void CU_trim_left(char* szString)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;207    {
000004  4605              MOV      r5,r0
;;;208    	int nOffset = 0;
000006  2700              MOVS     r7,#0
;;;209    	char* szSrc = szString;
000008  462c              MOV      r4,r5
;;;210    	char* szDest = szString;
00000a  462e              MOV      r6,r5
;;;211    
;;;212    	assert(NULL != szString);
;;;213    
;;;214    	/* Scan for the spaces in the starting of string. */
;;;215    	for (; '\0' != *szSrc; szSrc++, nOffset++) {
00000c  e00a              B        |L6.36|
                  |L6.14|
;;;216    		if (!isspace(*szSrc)) {
00000e  f7fffffe          BL       __rt_ctype_table
000012  6800              LDR      r0,[r0,#0]
000014  7821              LDRB     r1,[r4,#0]
000016  5c40              LDRB     r0,[r0,r1]
000018  f0000001          AND      r0,r0,#1
00001c  b900              CBNZ     r0,|L6.32|
;;;217    			break;
00001e  e004              B        |L6.42|
                  |L6.32|
000020  1c64              ADDS     r4,r4,#1              ;215
000022  1c7f              ADDS     r7,r7,#1              ;215
                  |L6.36|
000024  7820              LDRB     r0,[r4,#0]            ;215
000026  2800              CMP      r0,#0                 ;215
000028  d1f1              BNE      |L6.14|
                  |L6.42|
00002a  bf00              NOP      
;;;218    		}
;;;219    	}
;;;220    
;;;221    	for(; (0 != nOffset) && ('\0' != (*szDest = *szSrc)); szSrc++, szDest++) {
00002c  e001              B        |L6.50|
                  |L6.46|
00002e  1c64              ADDS     r4,r4,#1
000030  1c76              ADDS     r6,r6,#1
                  |L6.50|
000032  b11f              CBZ      r7,|L6.60|
000034  7820              LDRB     r0,[r4,#0]
000036  7030              STRB     r0,[r6,#0]
000038  2800              CMP      r0,#0
00003a  d1f8              BNE      |L6.46|
                  |L6.60|
;;;222    		;
;;;223    	}
;;;224    }
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;225    
                          ENDP


                          AREA ||i.CU_trim_right||, CODE, READONLY, ALIGN=1

                  CU_trim_right PROC
;;;226    /*------------------------------------------------------------------------*/
;;;227    void CU_trim_right(char* szString)
000000  b570              PUSH     {r4-r6,lr}
;;;228    {
000002  4605              MOV      r5,r0
;;;229    	size_t nLength;
;;;230    	char* szSrc = szString;
000004  462e              MOV      r6,r5
;;;231    
;;;232    	assert(NULL != szString);
;;;233    	nLength = strlen(szString);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       strlen
00000c  4604              MOV      r4,r0
;;;234    	/*
;;;235    	 * Scan for specs in the end of string.
;;;236    	 */
;;;237    	for (; (0 != nLength) && isspace(*(szSrc + nLength - 1)); nLength--) {
00000e  e000              B        |L7.18|
                  |L7.16|
000010  1e64              SUBS     r4,r4,#1
                  |L7.18|
000012  b154              CBZ      r4,|L7.42|
000014  f7fffffe          BL       __rt_ctype_table
000018  6800              LDR      r0,[r0,#0]
00001a  1931              ADDS     r1,r6,r4
00001c  f8111c01          LDRB     r1,[r1,#-1]
000020  5c40              LDRB     r0,[r0,r1]
000022  f0000001          AND      r0,r0,#1
000026  2800              CMP      r0,#0
000028  d1f2              BNE      |L7.16|
                  |L7.42|
;;;238    		;
;;;239    	}
;;;240    
;;;241    	*(szSrc + nLength) = '\0';
00002a  2000              MOVS     r0,#0
00002c  5530              STRB     r0,[r6,r4]
;;;242    }
00002e  bd70              POP      {r4-r6,pc}
;;;243    
                          ENDP


                          AREA ||i.get_index||, CODE, READONLY, ALIGN=2

                  get_index PROC
;;;82      */
;;;83     static int get_index(const char ch)
000000  4602              MOV      r2,r0
;;;84     {
;;;85     	int length = sizeof(CU_bindings)/sizeof(CU_bindings[0]);
000002  2303              MOVS     r3,#3
;;;86     	int counter;
;;;87     
;;;88     	for (counter = 0; counter < length && CU_bindings[counter].special_char != ch; ++counter) {
000004  2100              MOVS     r1,#0
000006  e000              B        |L8.10|
                  |L8.8|
000008  1c49              ADDS     r1,r1,#1
                  |L8.10|
00000a  4299              CMP      r1,r3
00000c  da04              BGE      |L8.24|
00000e  4806              LDR      r0,|L8.40|
000010  f8100031          LDRB     r0,[r0,r1,LSL #3]
000014  4290              CMP      r0,r2
000016  d1f7              BNE      |L8.8|
                  |L8.24|
;;;89     		;
;;;90     	}
;;;91     
;;;92     	return (counter < length ? counter : -1);
000018  4299              CMP      r1,r3
00001a  da01              BGE      |L8.32|
00001c  4608              MOV      r0,r1
                  |L8.30|
;;;93     }
00001e  4770              BX       lr
                  |L8.32|
000020  f04f30ff          MOV      r0,#0xffffffff        ;92
000024  e7fb              B        |L8.30|
;;;94     
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
                          DCD      CU_bindings

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  CU_bindings
000000  26000000          DCB      0x26,0x00,0x00,0x00
                          DCD      ||.conststring||
000008  3e000000          DCB      0x3e,0x00,0x00,0x00
                          DCD      ||.conststring||+0x8
000010  3c000000          DCB      0x3c,0x00,0x00,0x00
                          DCD      ||.conststring||+0x10

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  26616d70          DCB      "&amp;",0
000004  3b00    
000006  00                DCB      0
000007  00                DCB      0
000008  2667743b          DCB      "&gt;",0
00000c  00      
00000d  00                DCB      0
00000e  00                DCB      0
00000f  00                DCB      0
000010  266c743b          DCB      "&lt;",0
000014  00      
