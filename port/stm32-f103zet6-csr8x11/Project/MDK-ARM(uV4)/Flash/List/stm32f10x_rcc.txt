; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\stm32f10x_rcc.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\stm32f10x_rcc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\Middleware\blue_angel\inc -I..\..\Middleware\bt_callback_manager -I..\..\Middleware\blue_angel\btif -I..\..\Middleware\blue_angel\common -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\blue_angel\src\common -I..\..\Middleware\blue_angel\src\inc -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\blue_angel\platform\rtos -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\ut_manager\Cunit\Headers -I..\..\Middleware\ut_manager\Cunit\interface -I..\..\Middleware\blue_angel\platform\test -I..\..\Middleware\blue_angel\driver -I..\..\Middleware\blue_angel\src\core\hci -I..\..\User\bt\inc -I..\..\Middleware\bt_callback_manager -I..\..\Middleware\at_command -I..\..\Middleware\blue_angel\src\core\gap -I..\..\Middleware\blue_angel\src\core\l2cap -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=522 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DNDEBUG --omf_browse=.\flash\obj\stm32f10x_rcc.crf ..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c]
                          THUMB

                          AREA ||i.RCC_ADCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_ADCCLKConfig PROC
;;;771      */
;;;772    void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
000000  b570              PUSH     {r4-r6,lr}
;;;773    {
000002  4604              MOV      r4,r0
;;;774      uint32_t tmpreg = 0;
000004  2500              MOVS     r5,#0
;;;775      /* Check the parameters */
;;;776      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
000006  b144              CBZ      r4,|L1.26|
000008  f5b44f80          CMP      r4,#0x4000
00000c  d005              BEQ      |L1.26|
00000e  f5b44f00          CMP      r4,#0x8000
000012  d002              BEQ      |L1.26|
000014  f5b44f40          CMP      r4,#0xc000
000018  d100              BNE      |L1.28|
                  |L1.26|
00001a  e004              B        |L1.38|
                  |L1.28|
00001c  f44f7142          MOV      r1,#0x308
000020  a004              ADR      r0,|L1.52|
000022  f7fffffe          BL       assert_failed
                  |L1.38|
;;;777      tmpreg = RCC->CFGR;
000026  4813              LDR      r0,|L1.116|
000028  6845              LDR      r5,[r0,#4]
;;;778      /* Clear ADCPRE[1:0] bits */
;;;779      tmpreg &= CFGR_ADCPRE_Reset_Mask;
00002a  f4254540          BIC      r5,r5,#0xc000
;;;780      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;781      tmpreg |= RCC_PCLK2;
00002e  4325              ORRS     r5,r5,r4
;;;782      /* Store the new value */
;;;783      RCC->CFGR = tmpreg;
000030  6045              STR      r5,[r0,#4]
;;;784    }
000032  bd70              POP      {r4-r6,pc}
;;;785    
                          ENDP

                  |L1.52|
000034  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000038  2e5c4c69
00003c  62726172
000040  6965735c
000044  53544d33
000048  32463130
00004c  785f5374
000050  64506572
000054  6970685f
000058  44726976
00005c  65725c73
000060  72635c73
000064  746d    
000066  33326631          DCB      "32f10x_rcc.c",0
00006a  30785f72
00006e  63632e63
000072  00      
000073  00                DCB      0
                  |L1.116|
                          DCD      0x40021000

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;1069     */
;;;1070   void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1071   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1072     /* Check the parameters */
;;;1073     assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
000006  f2405057          MOV      r0,#0x557
00000a  ea240000          BIC      r0,r4,r0
00000e  b908              CBNZ     r0,|L2.20|
000010  b104              CBZ      r4,|L2.20|
000012  e004              B        |L2.30|
                  |L2.20|
000014  f2404131          MOV      r1,#0x431
000018  a00c              ADR      r0,|L2.76|
00001a  f7fffffe          BL       assert_failed
                  |L2.30|
;;;1074     assert_param(IS_FUNCTIONAL_STATE(NewState));
00001e  b10d              CBZ      r5,|L2.36|
000020  2d01              CMP      r5,#1
000022  d100              BNE      |L2.38|
                  |L2.36|
000024  e004              B        |L2.48|
                  |L2.38|
000026  f2404132          MOV      r1,#0x432
00002a  a008              ADR      r0,|L2.76|
00002c  f7fffffe          BL       assert_failed
                  |L2.48|
;;;1075   
;;;1076     if (NewState != DISABLE)
000030  b12d              CBZ      r5,|L2.62|
;;;1077     {
;;;1078       RCC->AHBENR |= RCC_AHBPeriph;
000032  4816              LDR      r0,|L2.140|
000034  6940              LDR      r0,[r0,#0x14]
000036  4320              ORRS     r0,r0,r4
000038  4914              LDR      r1,|L2.140|
00003a  6148              STR      r0,[r1,#0x14]
00003c  e004              B        |L2.72|
                  |L2.62|
;;;1079     }
;;;1080     else
;;;1081     {
;;;1082       RCC->AHBENR &= ~RCC_AHBPeriph;
00003e  4813              LDR      r0,|L2.140|
000040  6940              LDR      r0,[r0,#0x14]
000042  43a0              BICS     r0,r0,r4
000044  4911              LDR      r1,|L2.140|
000046  6148              STR      r0,[r1,#0x14]
                  |L2.72|
;;;1083     }
;;;1084   }
000048  bd70              POP      {r4-r6,pc}
;;;1085   
                          ENDP

00004a  0000              DCW      0x0000
                  |L2.76|
00004c  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000050  2e5c4c69
000054  62726172
000058  6965735c
00005c  53544d33
000060  32463130
000064  785f5374
000068  64506572
00006c  6970685f
000070  44726976
000074  65725c73
000078  72635c73
00007c  746d    
00007e  33326631          DCB      "32f10x_rcc.c",0
000082  30785f72
000086  63632e63
00008a  00      
00008b  00                DCB      0
                  |L2.140|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1131     */
;;;1132   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1133   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1134     /* Check the parameters */
;;;1135     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
000006  4810              LDR      r0,|L3.72|
000008  4020              ANDS     r0,r0,r4
00000a  b908              CBNZ     r0,|L3.16|
00000c  b104              CBZ      r4,|L3.16|
00000e  e004              B        |L3.26|
                  |L3.16|
000010  f240416f          MOV      r1,#0x46f
000014  a00d              ADR      r0,|L3.76|
000016  f7fffffe          BL       assert_failed
                  |L3.26|
;;;1136     assert_param(IS_FUNCTIONAL_STATE(NewState));
00001a  b10d              CBZ      r5,|L3.32|
00001c  2d01              CMP      r5,#1
00001e  d100              BNE      |L3.34|
                  |L3.32|
000020  e004              B        |L3.44|
                  |L3.34|
000022  f44f618e          MOV      r1,#0x470
000026  a009              ADR      r0,|L3.76|
000028  f7fffffe          BL       assert_failed
                  |L3.44|
;;;1137     if (NewState != DISABLE)
00002c  b12d              CBZ      r5,|L3.58|
;;;1138     {
;;;1139       RCC->APB1ENR |= RCC_APB1Periph;
00002e  4817              LDR      r0,|L3.140|
000030  69c0              LDR      r0,[r0,#0x1c]
000032  4320              ORRS     r0,r0,r4
000034  4915              LDR      r1,|L3.140|
000036  61c8              STR      r0,[r1,#0x1c]
000038  e004              B        |L3.68|
                  |L3.58|
;;;1140     }
;;;1141     else
;;;1142     {
;;;1143       RCC->APB1ENR &= ~RCC_APB1Periph;
00003a  4814              LDR      r0,|L3.140|
00003c  69c0              LDR      r0,[r0,#0x1c]
00003e  43a0              BICS     r0,r0,r4
000040  4912              LDR      r1,|L3.140|
000042  61c8              STR      r0,[r1,#0x1c]
                  |L3.68|
;;;1144     }
;;;1145   }
000044  bd70              POP      {r4-r6,pc}
;;;1146   
                          ENDP

000046  0000              DCW      0x0000
                  |L3.72|
                          DCD      0x81013600
                  |L3.76|
00004c  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000050  2e5c4c69
000054  62726172
000058  6965735c
00005c  53544d33
000060  32463130
000064  785f5374
000068  64506572
00006c  6970685f
000070  44726976
000074  65725c73
000078  72635c73
00007c  746d    
00007e  33326631          DCB      "32f10x_rcc.c",0
000082  30785f72
000086  63632e63
00008a  00      
00008b  00                DCB      0
                  |L3.140|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1221     */
;;;1222   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1223   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1224     /* Check the parameters */
;;;1225     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
000006  4810              LDR      r0,|L4.72|
000008  4020              ANDS     r0,r0,r4
00000a  b908              CBNZ     r0,|L4.16|
00000c  b104              CBZ      r4,|L4.16|
00000e  e004              B        |L4.26|
                  |L4.16|
000010  f24041c9          MOV      r1,#0x4c9
000014  a00d              ADR      r0,|L4.76|
000016  f7fffffe          BL       assert_failed
                  |L4.26|
;;;1226     assert_param(IS_FUNCTIONAL_STATE(NewState));
00001a  b10d              CBZ      r5,|L4.32|
00001c  2d01              CMP      r5,#1
00001e  d100              BNE      |L4.34|
                  |L4.32|
000020  e004              B        |L4.44|
                  |L4.34|
000022  f24041ca          MOV      r1,#0x4ca
000026  a009              ADR      r0,|L4.76|
000028  f7fffffe          BL       assert_failed
                  |L4.44|
;;;1227     if (NewState != DISABLE)
00002c  b12d              CBZ      r5,|L4.58|
;;;1228     {
;;;1229       RCC->APB1RSTR |= RCC_APB1Periph;
00002e  4817              LDR      r0,|L4.140|
000030  6900              LDR      r0,[r0,#0x10]
000032  4320              ORRS     r0,r0,r4
000034  4915              LDR      r1,|L4.140|
000036  6108              STR      r0,[r1,#0x10]
000038  e004              B        |L4.68|
                  |L4.58|
;;;1230     }
;;;1231     else
;;;1232     {
;;;1233       RCC->APB1RSTR &= ~RCC_APB1Periph;
00003a  4814              LDR      r0,|L4.140|
00003c  6900              LDR      r0,[r0,#0x10]
00003e  43a0              BICS     r0,r0,r4
000040  4912              LDR      r1,|L4.140|
000042  6108              STR      r0,[r1,#0x10]
                  |L4.68|
;;;1234     }
;;;1235   }
000044  bd70              POP      {r4-r6,pc}
;;;1236   
                          ENDP

000046  0000              DCW      0x0000
                  |L4.72|
                          DCD      0x81013600
                  |L4.76|
00004c  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000050  2e5c4c69
000054  62726172
000058  6965735c
00005c  53544d33
000060  32463130
000064  785f5374
000068  64506572
00006c  6970685f
000070  44726976
000074  65725c73
000078  72635c73
00007c  746d    
00007e  33326631          DCB      "32f10x_rcc.c",0
000082  30785f72
000086  63632e63
00008a  00      
00008b  00                DCB      0
                  |L4.140|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1100     */
;;;1101   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1102   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1103     /* Check the parameters */
;;;1104     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
000006  4810              LDR      r0,|L5.72|
000008  4020              ANDS     r0,r0,r4
00000a  b908              CBNZ     r0,|L5.16|
00000c  b104              CBZ      r4,|L5.16|
00000e  e004              B        |L5.26|
                  |L5.16|
000010  f44f618a          MOV      r1,#0x450
000014  a00d              ADR      r0,|L5.76|
000016  f7fffffe          BL       assert_failed
                  |L5.26|
;;;1105     assert_param(IS_FUNCTIONAL_STATE(NewState));
00001a  b10d              CBZ      r5,|L5.32|
00001c  2d01              CMP      r5,#1
00001e  d100              BNE      |L5.34|
                  |L5.32|
000020  e004              B        |L5.44|
                  |L5.34|
000022  f2404151          MOV      r1,#0x451
000026  a009              ADR      r0,|L5.76|
000028  f7fffffe          BL       assert_failed
                  |L5.44|
;;;1106     if (NewState != DISABLE)
00002c  b12d              CBZ      r5,|L5.58|
;;;1107     {
;;;1108       RCC->APB2ENR |= RCC_APB2Periph;
00002e  4817              LDR      r0,|L5.140|
000030  6980              LDR      r0,[r0,#0x18]
000032  4320              ORRS     r0,r0,r4
000034  4915              LDR      r1,|L5.140|
000036  6188              STR      r0,[r1,#0x18]
000038  e004              B        |L5.68|
                  |L5.58|
;;;1109     }
;;;1110     else
;;;1111     {
;;;1112       RCC->APB2ENR &= ~RCC_APB2Periph;
00003a  4814              LDR      r0,|L5.140|
00003c  6980              LDR      r0,[r0,#0x18]
00003e  43a0              BICS     r0,r0,r4
000040  4912              LDR      r1,|L5.140|
000042  6188              STR      r0,[r1,#0x18]
                  |L5.68|
;;;1113     }
;;;1114   }
000044  bd70              POP      {r4-r6,pc}
;;;1115   
                          ENDP

000046  0000              DCW      0x0000
                  |L5.72|
                          DCD      0xffc00002
                  |L5.76|
00004c  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000050  2e5c4c69
000054  62726172
000058  6965735c
00005c  53544d33
000060  32463130
000064  785f5374
000068  64506572
00006c  6970685f
000070  44726976
000074  65725c73
000078  72635c73
00007c  746d    
00007e  33326631          DCB      "32f10x_rcc.c",0
000082  30785f72
000086  63632e63
00008a  00      
00008b  00                DCB      0
                  |L5.140|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1190     */
;;;1191   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1192   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1193     /* Check the parameters */
;;;1194     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
000006  4810              LDR      r0,|L6.72|
000008  4020              ANDS     r0,r0,r4
00000a  b908              CBNZ     r0,|L6.16|
00000c  b104              CBZ      r4,|L6.16|
00000e  e004              B        |L6.26|
                  |L6.16|
000010  f24041aa          MOV      r1,#0x4aa
000014  a00d              ADR      r0,|L6.76|
000016  f7fffffe          BL       assert_failed
                  |L6.26|
;;;1195     assert_param(IS_FUNCTIONAL_STATE(NewState));
00001a  b10d              CBZ      r5,|L6.32|
00001c  2d01              CMP      r5,#1
00001e  d100              BNE      |L6.34|
                  |L6.32|
000020  e004              B        |L6.44|
                  |L6.34|
000022  f24041ab          MOV      r1,#0x4ab
000026  a009              ADR      r0,|L6.76|
000028  f7fffffe          BL       assert_failed
                  |L6.44|
;;;1196     if (NewState != DISABLE)
00002c  b12d              CBZ      r5,|L6.58|
;;;1197     {
;;;1198       RCC->APB2RSTR |= RCC_APB2Periph;
00002e  4817              LDR      r0,|L6.140|
000030  68c0              LDR      r0,[r0,#0xc]
000032  4320              ORRS     r0,r0,r4
000034  4915              LDR      r1,|L6.140|
000036  60c8              STR      r0,[r1,#0xc]
000038  e004              B        |L6.68|
                  |L6.58|
;;;1199     }
;;;1200     else
;;;1201     {
;;;1202       RCC->APB2RSTR &= ~RCC_APB2Periph;
00003a  4814              LDR      r0,|L6.140|
00003c  68c0              LDR      r0,[r0,#0xc]
00003e  43a0              BICS     r0,r0,r4
000040  4912              LDR      r1,|L6.140|
000042  60c8              STR      r0,[r1,#0xc]
                  |L6.68|
;;;1203     }
;;;1204   }
000044  bd70              POP      {r4-r6,pc}
;;;1205   
                          ENDP

000046  0000              DCW      0x0000
                  |L6.72|
                          DCD      0xffc00002
                  |L6.76|
00004c  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000050  2e5c4c69
000054  62726172
000058  6965735c
00005c  53544d33
000060  32463130
000064  785f5374
000068  64506572
00006c  6970685f
000070  44726976
000074  65725c73
000078  72635c73
00007c  746d    
00007e  33326631          DCB      "32f10x_rcc.c",0
000082  30785f72
000086  63632e63
00008a  00      
00008b  00                DCB      0
                  |L6.140|
                          DCD      0x40021000

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;339      */
;;;340    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  b570              PUSH     {r4-r6,lr}
;;;341    {
000002  4604              MOV      r4,r0
;;;342      uint32_t tmpreg = 0;
000004  2500              MOVS     r5,#0
;;;343      /* Check the parameters */
;;;344      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
000006  2c1f              CMP      r4,#0x1f
000008  dc00              BGT      |L7.12|
00000a  e004              B        |L7.22|
                  |L7.12|
00000c  f44f71ac          MOV      r1,#0x158
000010  a005              ADR      r0,|L7.40|
000012  f7fffffe          BL       assert_failed
                  |L7.22|
;;;345      tmpreg = RCC->CR;
000016  4814              LDR      r0,|L7.104|
000018  6805              LDR      r5,[r0,#0]
;;;346      /* Clear HSITRIM[4:0] bits */
;;;347      tmpreg &= CR_HSITRIM_Mask;
00001a  f02505f8          BIC      r5,r5,#0xf8
;;;348      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;349      tmpreg |= (uint32_t)HSICalibrationValue << 3;
00001e  ea4505c4          ORR      r5,r5,r4,LSL #3
;;;350      /* Store the new value */
;;;351      RCC->CR = tmpreg;
000022  6005              STR      r5,[r0,#0]
;;;352    }
000024  bd70              POP      {r4-r6,pc}
;;;353    
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
000028  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
00002c  2e5c4c69
000030  62726172
000034  6965735c
000038  53544d33
00003c  32463130
000040  785f5374
000044  64506572
000048  6970685f
00004c  44726976
000050  65725c73
000054  72635c73
000058  746d    
00005a  33326631          DCB      "32f10x_rcc.c",0
00005e  30785f72
000062  63632e63
000066  00      
000067  00                DCB      0
                  |L7.104|
                          DCD      0x40021000

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1242     */
;;;1243   void RCC_BackupResetCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1244   {
000002  4604              MOV      r4,r0
;;;1245     /* Check the parameters */
;;;1246     assert_param(IS_FUNCTIONAL_STATE(NewState));
000004  b10c              CBZ      r4,|L8.10|
000006  2c01              CMP      r4,#1
000008  d100              BNE      |L8.12|
                  |L8.10|
00000a  e004              B        |L8.22|
                  |L8.12|
00000c  f24041de          MOV      r1,#0x4de
000010  a002              ADR      r0,|L8.28|
000012  f7fffffe          BL       assert_failed
                  |L8.22|
;;;1247     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000016  4811              LDR      r0,|L8.92|
000018  6004              STR      r4,[r0,#0]
;;;1248   }
00001a  bd10              POP      {r4,pc}
;;;1249   
                          ENDP

                  |L8.28|
00001c  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000020  2e5c4c69
000024  62726172
000028  6965735c
00002c  53544d33
000030  32463130
000034  785f5374
000038  64506572
00003c  6970685f
000040  44726976
000044  65725c73
000048  72635c73
00004c  746d    
00004e  33326631          DCB      "32f10x_rcc.c",0
000052  30785f72
000056  63632e63
00005a  00      
00005b  00                DCB      0
                  |L8.92|
                          DCD      0x42420440

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1376     */
;;;1377   void RCC_ClearFlag(void)
000000  4803              LDR      r0,|L9.16|
;;;1378   {
;;;1379     /* Set RMVF bit to clear the reset flags */
;;;1380     RCC->CSR |= CSR_RMVF_Set;
000002  6a40              LDR      r0,[r0,#0x24]
000004  f0407080          ORR      r0,r0,#0x1000000
000008  4901              LDR      r1,|L9.16|
00000a  6248              STR      r0,[r1,#0x24]
;;;1381   }
00000c  4770              BX       lr
;;;1382   
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      0x40021000

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1453     */
;;;1454   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  b510              PUSH     {r4,lr}
;;;1455   {
000002  4604              MOV      r4,r0
;;;1456     /* Check the parameters */
;;;1457     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
000004  f0040060          AND      r0,r4,#0x60
000008  b908              CBNZ     r0,|L10.14|
00000a  b104              CBZ      r4,|L10.14|
00000c  e004              B        |L10.24|
                  |L10.14|
00000e  f24051b1          MOV      r1,#0x5b1
000012  a003              ADR      r0,|L10.32|
000014  f7fffffe          BL       assert_failed
                  |L10.24|
;;;1458   
;;;1459     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1460        pending bits */
;;;1461     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000018  4811              LDR      r0,|L10.96|
00001a  7284              STRB     r4,[r0,#0xa]
;;;1462   }
00001c  bd10              POP      {r4,pc}
;;;1463   
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
000020  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000024  2e5c4c69
000028  62726172
00002c  6965735c
000030  53544d33
000034  32463130
000038  785f5374
00003c  64506572
000040  6970685f
000044  44726976
000048  65725c73
00004c  72635c73
000050  746d    
000052  33326631          DCB      "32f10x_rcc.c",0
000056  30785f72
00005a  63632e63
00005e  00      
00005f  00                DCB      0
                  |L10.96|
                          DCD      0x40021000

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;1255     */
;;;1256   void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1257   {
000002  4604              MOV      r4,r0
;;;1258     /* Check the parameters */
;;;1259     assert_param(IS_FUNCTIONAL_STATE(NewState));
000004  b10c              CBZ      r4,|L11.10|
000006  2c01              CMP      r4,#1
000008  d100              BNE      |L11.12|
                  |L11.10|
00000a  e004              B        |L11.22|
                  |L11.12|
00000c  f24041eb          MOV      r1,#0x4eb
000010  a002              ADR      r0,|L11.28|
000012  f7fffffe          BL       assert_failed
                  |L11.22|
;;;1260     *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000016  4811              LDR      r0,|L11.92|
000018  64c4              STR      r4,[r0,#0x4c]
;;;1261   }
00001a  bd10              POP      {r4,pc}
;;;1262   
                          ENDP

                  |L11.28|
00001c  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000020  2e5c4c69
000024  62726172
000028  6965735c
00002c  53544d33
000030  32463130
000034  785f5374
000038  64506572
00003c  6970685f
000040  44726976
000044  65725c73
000048  72635c73
00004c  746d    
00004e  33326631          DCB      "32f10x_rcc.c",0
000052  30785f72
000056  63632e63
00005a  00      
00005b  00                DCB      0
                  |L11.92|
                          DCD      0x42420000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;222      */
;;;223    void RCC_DeInit(void)
000000  480f              LDR      r0,|L12.64|
;;;224    {
;;;225      /* Set HSION bit */
;;;226      RCC->CR |= (uint32_t)0x00000001;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  490d              LDR      r1,|L12.64|
00000a  6008              STR      r0,[r1,#0]
;;;227    
;;;228      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;229    #ifndef STM32F10X_CL
;;;230      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000c  4608              MOV      r0,r1
00000e  6840              LDR      r0,[r0,#4]
000010  490c              LDR      r1,|L12.68|
000012  4008              ANDS     r0,r0,r1
000014  490a              LDR      r1,|L12.64|
000016  6048              STR      r0,[r1,#4]
;;;231    #else
;;;232      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;233    #endif /* STM32F10X_CL */   
;;;234      
;;;235      /* Reset HSEON, CSSON and PLLON bits */
;;;236      RCC->CR &= (uint32_t)0xFEF6FFFF;
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  490a              LDR      r1,|L12.72|
00001e  4008              ANDS     r0,r0,r1
000020  4907              LDR      r1,|L12.64|
000022  6008              STR      r0,[r1,#0]
;;;237    
;;;238      /* Reset HSEBYP bit */
;;;239      RCC->CR &= (uint32_t)0xFFFBFFFF;
000024  4608              MOV      r0,r1
000026  6800              LDR      r0,[r0,#0]
000028  f4202080          BIC      r0,r0,#0x40000
00002c  6008              STR      r0,[r1,#0]
;;;240    
;;;241      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;242      RCC->CFGR &= (uint32_t)0xFF80FFFF;
00002e  4608              MOV      r0,r1
000030  6840              LDR      r0,[r0,#4]
000032  f42000fe          BIC      r0,r0,#0x7f0000
000036  6048              STR      r0,[r1,#4]
;;;243    
;;;244    #ifdef STM32F10X_CL
;;;245      /* Reset PLL2ON and PLL3ON bits */
;;;246      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;247    
;;;248      /* Disable all interrupts and clear pending bits  */
;;;249      RCC->CIR = 0x00FF0000;
;;;250    
;;;251      /* Reset CFGR2 register */
;;;252      RCC->CFGR2 = 0x00000000;
;;;253    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;254      /* Disable all interrupts and clear pending bits  */
;;;255      RCC->CIR = 0x009F0000;
;;;256    
;;;257      /* Reset CFGR2 register */
;;;258      RCC->CFGR2 = 0x00000000;      
;;;259    #else
;;;260      /* Disable all interrupts and clear pending bits  */
;;;261      RCC->CIR = 0x009F0000;
000038  f44f001f          MOV      r0,#0x9f0000
00003c  6088              STR      r0,[r1,#8]
;;;262    #endif /* STM32F10X_CL */
;;;263    
;;;264    }
00003e  4770              BX       lr
;;;265    
                          ENDP

                  |L12.64|
                          DCD      0x40021000
                  |L12.68|
                          DCD      0xf8ff0000
                  |L12.72|
                          DCD      0xfef6ffff

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;913      */
;;;914    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  b530              PUSH     {r4,r5,lr}
;;;915    {
;;;916      uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
000002  2100              MOVS     r1,#0
000004  2200              MOVS     r2,#0
000006  2400              MOVS     r4,#0
000008  2300              MOVS     r3,#0
;;;917    
;;;918    #ifdef  STM32F10X_CL
;;;919      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;920    #endif /* STM32F10X_CL */
;;;921    
;;;922    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;923      uint32_t prediv1factor = 0;
;;;924    #endif
;;;925        
;;;926      /* Get SYSCLK source -------------------------------------------------------*/
;;;927      tmp = RCC->CFGR & CFGR_SWS_Mask;
00000a  4d2d              LDR      r5,|L13.192|
00000c  686d              LDR      r5,[r5,#4]
00000e  f005010c          AND      r1,r5,#0xc
;;;928      
;;;929      switch (tmp)
000012  b121              CBZ      r1,|L13.30|
000014  2904              CMP      r1,#4
000016  d005              BEQ      |L13.36|
000018  2908              CMP      r1,#8
00001a  d123              BNE      |L13.100|
00001c  e005              B        |L13.42|
                  |L13.30|
;;;930      {
;;;931        case 0x00:  /* HSI used as system clock */
;;;932          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
00001e  4d29              LDR      r5,|L13.196|
000020  6005              STR      r5,[r0,#0]
;;;933          break;
000022  e022              B        |L13.106|
                  |L13.36|
;;;934        case 0x04:  /* HSE used as system clock */
;;;935          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
000024  4d27              LDR      r5,|L13.196|
000026  6005              STR      r5,[r0,#0]
;;;936          break;
000028  e01f              B        |L13.106|
                  |L13.42|
;;;937        case 0x08:  /* PLL used as system clock */
;;;938    
;;;939          /* Get PLL clock source and multiplication factor ----------------------*/
;;;940          pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
00002a  4d25              LDR      r5,|L13.192|
00002c  686d              LDR      r5,[r5,#4]
00002e  f4051270          AND      r2,r5,#0x3c0000
;;;941          pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
000032  4d23              LDR      r5,|L13.192|
000034  686d              LDR      r5,[r5,#4]
000036  f4053480          AND      r4,r5,#0x10000
;;;942          
;;;943    #ifndef STM32F10X_CL      
;;;944          pllmull = ( pllmull >> 18) + 2;
00003a  2502              MOVS     r5,#2
00003c  eb054292          ADD      r2,r5,r2,LSR #18
;;;945          
;;;946          if (pllsource == 0x00)
000040  b91c              CBNZ     r4,|L13.74|
;;;947          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;948            RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
000042  4d21              LDR      r5,|L13.200|
000044  4355              MULS     r5,r2,r5
000046  6005              STR      r5,[r0,#0]
000048  e00b              B        |L13.98|
                  |L13.74|
;;;949          }
;;;950          else
;;;951          {
;;;952     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;953           prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
;;;954           /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;955           RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
;;;956     #else
;;;957            /* HSE selected as PLL clock entry */
;;;958            if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
00004a  4d1d              LDR      r5,|L13.192|
00004c  686d              LDR      r5,[r5,#4]
00004e  f4053500          AND      r5,r5,#0x20000
000052  b11d              CBZ      r5,|L13.92|
;;;959            {/* HSE oscillator clock divided by 2 */
;;;960              RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
000054  4d1c              LDR      r5,|L13.200|
000056  4355              MULS     r5,r2,r5
000058  6005              STR      r5,[r0,#0]
00005a  e002              B        |L13.98|
                  |L13.92|
;;;961            }
;;;962            else
;;;963            {
;;;964              RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
00005c  4d19              LDR      r5,|L13.196|
00005e  4355              MULS     r5,r2,r5
000060  6005              STR      r5,[r0,#0]
                  |L13.98|
;;;965            }
;;;966     #endif
;;;967          }
;;;968    #else
;;;969          pllmull = pllmull >> 18;
;;;970          
;;;971          if (pllmull != 0x0D)
;;;972          {
;;;973             pllmull += 2;
;;;974          }
;;;975          else
;;;976          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;977            pllmull = 13 / 2; 
;;;978          }
;;;979                
;;;980          if (pllsource == 0x00)
;;;981          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;982            RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
;;;983          }
;;;984          else
;;;985          {/* PREDIV1 selected as PLL clock entry */
;;;986            
;;;987            /* Get PREDIV1 clock source and division factor */
;;;988            prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;
;;;989            prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
;;;990            
;;;991            if (prediv1source == 0)
;;;992            { /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;993              RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull;          
;;;994            }
;;;995            else
;;;996            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;997              
;;;998              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;999              prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
;;;1000             pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;1001             RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;1002           }
;;;1003         }
;;;1004   #endif /* STM32F10X_CL */ 
;;;1005         break;
000062  e002              B        |L13.106|
                  |L13.100|
;;;1006   
;;;1007       default:
;;;1008         RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000064  4d17              LDR      r5,|L13.196|
000066  6005              STR      r5,[r0,#0]
;;;1009         break;
000068  bf00              NOP      
                  |L13.106|
00006a  bf00              NOP                            ;933
;;;1010     }
;;;1011   
;;;1012     /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;1013     /* Get HCLK prescaler */
;;;1014     tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
00006c  4d14              LDR      r5,|L13.192|
00006e  686d              LDR      r5,[r5,#4]
000070  f00501f0          AND      r1,r5,#0xf0
;;;1015     tmp = tmp >> 4;
000074  0909              LSRS     r1,r1,#4
;;;1016     presc = APBAHBPrescTable[tmp];
000076  4d15              LDR      r5,|L13.204|
000078  5c6b              LDRB     r3,[r5,r1]
;;;1017     /* HCLK clock frequency */
;;;1018     RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
00007a  6805              LDR      r5,[r0,#0]
00007c  40dd              LSRS     r5,r5,r3
00007e  6045              STR      r5,[r0,#4]
;;;1019     /* Get PCLK1 prescaler */
;;;1020     tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
000080  4d0f              LDR      r5,|L13.192|
000082  686d              LDR      r5,[r5,#4]
000084  f40561e0          AND      r1,r5,#0x700
;;;1021     tmp = tmp >> 8;
000088  0a09              LSRS     r1,r1,#8
;;;1022     presc = APBAHBPrescTable[tmp];
00008a  4d10              LDR      r5,|L13.204|
00008c  5c6b              LDRB     r3,[r5,r1]
;;;1023     /* PCLK1 clock frequency */
;;;1024     RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
00008e  6845              LDR      r5,[r0,#4]
000090  40dd              LSRS     r5,r5,r3
000092  6085              STR      r5,[r0,#8]
;;;1025     /* Get PCLK2 prescaler */
;;;1026     tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
000094  4d0a              LDR      r5,|L13.192|
000096  686d              LDR      r5,[r5,#4]
000098  f4055160          AND      r1,r5,#0x3800
;;;1027     tmp = tmp >> 11;
00009c  0ac9              LSRS     r1,r1,#11
;;;1028     presc = APBAHBPrescTable[tmp];
00009e  4d0b              LDR      r5,|L13.204|
0000a0  5c6b              LDRB     r3,[r5,r1]
;;;1029     /* PCLK2 clock frequency */
;;;1030     RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0000a2  6845              LDR      r5,[r0,#4]
0000a4  40dd              LSRS     r5,r5,r3
0000a6  60c5              STR      r5,[r0,#0xc]
;;;1031     /* Get ADCCLK prescaler */
;;;1032     tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
0000a8  4d05              LDR      r5,|L13.192|
0000aa  686d              LDR      r5,[r5,#4]
0000ac  f4054140          AND      r1,r5,#0xc000
;;;1033     tmp = tmp >> 14;
0000b0  0b89              LSRS     r1,r1,#14
;;;1034     presc = ADCPrescTable[tmp];
0000b2  4d07              LDR      r5,|L13.208|
0000b4  5c6b              LDRB     r3,[r5,r1]
;;;1035     /* ADCCLK clock frequency */
;;;1036     RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
0000b6  68c5              LDR      r5,[r0,#0xc]
0000b8  fbb5f5f3          UDIV     r5,r5,r3
0000bc  6105              STR      r5,[r0,#0x10]
;;;1037   }
0000be  bd30              POP      {r4,r5,pc}
;;;1038   
                          ENDP

                  |L13.192|
                          DCD      0x40021000
                  |L13.196|
                          DCD      0x007a1200
                  |L13.200|
                          DCD      0x003d0900
                  |L13.204|
                          DCD      APBAHBPrescTable
                  |L13.208|
                          DCD      ADCPrescTable

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1331     */
;;;1332   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1333   {
000004  4604              MOV      r4,r0
;;;1334     uint32_t tmp = 0;
000006  2500              MOVS     r5,#0
;;;1335     uint32_t statusreg = 0;
000008  2600              MOVS     r6,#0
;;;1336     FlagStatus bitstatus = RESET;
00000a  2700              MOVS     r7,#0
;;;1337     /* Check the parameters */
;;;1338     assert_param(IS_RCC_FLAG(RCC_FLAG));
00000c  2c21              CMP      r4,#0x21
00000e  d013              BEQ      |L14.56|
000010  2c31              CMP      r4,#0x31
000012  d011              BEQ      |L14.56|
000014  2c39              CMP      r4,#0x39
000016  d00f              BEQ      |L14.56|
000018  2c41              CMP      r4,#0x41
00001a  d00d              BEQ      |L14.56|
00001c  2c61              CMP      r4,#0x61
00001e  d00b              BEQ      |L14.56|
000020  2c7a              CMP      r4,#0x7a
000022  d009              BEQ      |L14.56|
000024  2c7b              CMP      r4,#0x7b
000026  d007              BEQ      |L14.56|
000028  2c7c              CMP      r4,#0x7c
00002a  d005              BEQ      |L14.56|
00002c  2c7d              CMP      r4,#0x7d
00002e  d003              BEQ      |L14.56|
000030  2c7e              CMP      r4,#0x7e
000032  d001              BEQ      |L14.56|
000034  2c7f              CMP      r4,#0x7f
000036  d100              BNE      |L14.58|
                  |L14.56|
000038  e004              B        |L14.68|
                  |L14.58|
00003a  f240513a          MOV      r1,#0x53a
00003e  a00e              ADR      r0,|L14.120|
000040  f7fffffe          BL       assert_failed
                  |L14.68|
;;;1339   
;;;1340     /* Get the RCC register index */
;;;1341     tmp = RCC_FLAG >> 5;
000044  1165              ASRS     r5,r4,#5
;;;1342     if (tmp == 1)               /* The flag to check is in CR register */
000046  2d01              CMP      r5,#1
000048  d102              BNE      |L14.80|
;;;1343     {
;;;1344       statusreg = RCC->CR;
00004a  481b              LDR      r0,|L14.184|
00004c  6806              LDR      r6,[r0,#0]
00004e  e006              B        |L14.94|
                  |L14.80|
;;;1345     }
;;;1346     else if (tmp == 2)          /* The flag to check is in BDCR register */
000050  2d02              CMP      r5,#2
000052  d102              BNE      |L14.90|
;;;1347     {
;;;1348       statusreg = RCC->BDCR;
000054  4818              LDR      r0,|L14.184|
000056  6a06              LDR      r6,[r0,#0x20]
000058  e001              B        |L14.94|
                  |L14.90|
;;;1349     }
;;;1350     else                       /* The flag to check is in CSR register */
;;;1351     {
;;;1352       statusreg = RCC->CSR;
00005a  4817              LDR      r0,|L14.184|
00005c  6a46              LDR      r6,[r0,#0x24]
                  |L14.94|
;;;1353     }
;;;1354   
;;;1355     /* Get the flag position */
;;;1356     tmp = RCC_FLAG & FLAG_Mask;
00005e  f004051f          AND      r5,r4,#0x1f
;;;1357     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000062  2001              MOVS     r0,#1
000064  40a8              LSLS     r0,r0,r5
000066  4030              ANDS     r0,r0,r6
000068  b108              CBZ      r0,|L14.110|
;;;1358     {
;;;1359       bitstatus = SET;
00006a  2701              MOVS     r7,#1
00006c  e000              B        |L14.112|
                  |L14.110|
;;;1360     }
;;;1361     else
;;;1362     {
;;;1363       bitstatus = RESET;
00006e  2700              MOVS     r7,#0
                  |L14.112|
;;;1364     }
;;;1365   
;;;1366     /* Return the flag status */
;;;1367     return bitstatus;
000070  4638              MOV      r0,r7
;;;1368   }
000072  e8bd81f0          POP      {r4-r8,pc}
;;;1369   
                          ENDP

000076  0000              DCW      0x0000
                  |L14.120|
000078  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
00007c  2e5c4c69
000080  62726172
000084  6965735c
000088  53544d33
00008c  32463130
000090  785f5374
000094  64506572
000098  6970685f
00009c  44726976
0000a0  65725c73
0000a4  72635c73
0000a8  746d    
0000aa  33326631          DCB      "32f10x_rcc.c",0
0000ae  30785f72
0000b2  63632e63
0000b6  00      
0000b7  00                DCB      0
                  |L14.184|
                          DCD      0x40021000

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1407     */
;;;1408   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1409   {
000002  4604              MOV      r4,r0
;;;1410     ITStatus bitstatus = RESET;
000004  2500              MOVS     r5,#0
;;;1411     /* Check the parameters */
;;;1412     assert_param(IS_RCC_GET_IT(RCC_IT));
000006  2c01              CMP      r4,#1
000008  d009              BEQ      |L15.30|
00000a  2c02              CMP      r4,#2
00000c  d007              BEQ      |L15.30|
00000e  2c04              CMP      r4,#4
000010  d005              BEQ      |L15.30|
000012  2c08              CMP      r4,#8
000014  d003              BEQ      |L15.30|
000016  2c10              CMP      r4,#0x10
000018  d001              BEQ      |L15.30|
00001a  2c80              CMP      r4,#0x80
00001c  d100              BNE      |L15.32|
                  |L15.30|
00001e  e004              B        |L15.42|
                  |L15.32|
000020  f2405184          MOV      r1,#0x584
000024  a005              ADR      r0,|L15.60|
000026  f7fffffe          BL       assert_failed
                  |L15.42|
;;;1413   
;;;1414     /* Check the status of the specified RCC interrupt */
;;;1415     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
00002a  4814              LDR      r0,|L15.124|
00002c  6880              LDR      r0,[r0,#8]
00002e  4020              ANDS     r0,r0,r4
000030  b108              CBZ      r0,|L15.54|
;;;1416     {
;;;1417       bitstatus = SET;
000032  2501              MOVS     r5,#1
000034  e000              B        |L15.56|
                  |L15.54|
;;;1418     }
;;;1419     else
;;;1420     {
;;;1421       bitstatus = RESET;
000036  2500              MOVS     r5,#0
                  |L15.56|
;;;1422     }
;;;1423   
;;;1424     /* Return the RCC_IT status */
;;;1425     return  bitstatus;
000038  4628              MOV      r0,r5
;;;1426   }
00003a  bd70              POP      {r4-r6,pc}
;;;1427   
                          ENDP

                  |L15.60|
00003c  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000040  2e5c4c69
000044  62726172
000048  6965735c
00004c  53544d33
000050  32463130
000054  785f5374
000058  64506572
00005c  6970685f
000060  44726976
000064  65725c73
000068  72635c73
00006c  746d    
00006e  33326631          DCB      "32f10x_rcc.c",0
000072  30785f72
000076  63632e63
00007a  00      
00007b  00                DCB      0
                  |L15.124|
                          DCD      0x40021000

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;592      */
;;;593    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L16.12|
;;;594    {
;;;595      return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
000002  6840              LDR      r0,[r0,#4]
000004  f000000c          AND      r0,r0,#0xc
;;;596    }
000008  4770              BX       lr
;;;597    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40021000

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;613      */
;;;614    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  b570              PUSH     {r4-r6,lr}
;;;615    {
000002  4604              MOV      r4,r0
;;;616      uint32_t tmpreg = 0;
000004  2500              MOVS     r5,#0
;;;617      /* Check the parameters */
;;;618      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
000006  b17c              CBZ      r4,|L17.40|
000008  2c80              CMP      r4,#0x80
00000a  d00d              BEQ      |L17.40|
00000c  2c90              CMP      r4,#0x90
00000e  d00b              BEQ      |L17.40|
000010  2ca0              CMP      r4,#0xa0
000012  d009              BEQ      |L17.40|
000014  2cb0              CMP      r4,#0xb0
000016  d007              BEQ      |L17.40|
000018  2cc0              CMP      r4,#0xc0
00001a  d005              BEQ      |L17.40|
00001c  2cd0              CMP      r4,#0xd0
00001e  d003              BEQ      |L17.40|
000020  2ce0              CMP      r4,#0xe0
000022  d001              BEQ      |L17.40|
000024  2cf0              CMP      r4,#0xf0
000026  d100              BNE      |L17.42|
                  |L17.40|
000028  e004              B        |L17.52|
                  |L17.42|
00002a  f240216a          MOV      r1,#0x26a
00002e  a005              ADR      r0,|L17.68|
000030  f7fffffe          BL       assert_failed
                  |L17.52|
;;;619      tmpreg = RCC->CFGR;
000034  4813              LDR      r0,|L17.132|
000036  6845              LDR      r5,[r0,#4]
;;;620      /* Clear HPRE[3:0] bits */
;;;621      tmpreg &= CFGR_HPRE_Reset_Mask;
000038  f02505f0          BIC      r5,r5,#0xf0
;;;622      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;623      tmpreg |= RCC_SYSCLK;
00003c  4325              ORRS     r5,r5,r4
;;;624      /* Store the new value */
;;;625      RCC->CFGR = tmpreg;
00003e  6045              STR      r5,[r0,#4]
;;;626    }
000040  bd70              POP      {r4-r6,pc}
;;;627    
                          ENDP

000042  0000              DCW      0x0000
                  |L17.68|
000044  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000048  2e5c4c69
00004c  62726172
000050  6965735c
000054  53544d33
000058  32463130
00005c  785f5374
000060  64506572
000064  6970685f
000068  44726976
00006c  65725c73
000070  72635c73
000074  746d    
000076  33326631          DCB      "32f10x_rcc.c",0
00007a  30785f72
00007e  63632e63
000082  00      
000083  00                DCB      0
                  |L17.132|
                          DCD      0x40021000

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;275      */
;;;276    void RCC_HSEConfig(uint32_t RCC_HSE)
000000  b510              PUSH     {r4,lr}
;;;277    {
000002  4604              MOV      r4,r0
;;;278      /* Check the parameters */
;;;279      assert_param(IS_RCC_HSE(RCC_HSE));
000004  b12c              CBZ      r4,|L18.18|
000006  f5b43f80          CMP      r4,#0x10000
00000a  d002              BEQ      |L18.18|
00000c  f5b42f80          CMP      r4,#0x40000
000010  d100              BNE      |L18.20|
                  |L18.18|
000012  e004              B        |L18.30|
                  |L18.20|
000014  f2401117          MOV      r1,#0x117
000018  a012              ADR      r0,|L18.100|
00001a  f7fffffe          BL       assert_failed
                  |L18.30|
;;;280      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;281      /* Reset HSEON bit */
;;;282      RCC->CR &= CR_HSEON_Reset;
00001e  4821              LDR      r0,|L18.164|
000020  6800              LDR      r0,[r0,#0]
000022  f4203080          BIC      r0,r0,#0x10000
000026  491f              LDR      r1,|L18.164|
000028  6008              STR      r0,[r1,#0]
;;;283      /* Reset HSEBYP bit */
;;;284      RCC->CR &= CR_HSEBYP_Reset;
00002a  4608              MOV      r0,r1
00002c  6800              LDR      r0,[r0,#0]
00002e  f4202080          BIC      r0,r0,#0x40000
000032  6008              STR      r0,[r1,#0]
;;;285      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;286      switch(RCC_HSE)
000034  f5b43f80          CMP      r4,#0x10000
000038  d003              BEQ      |L18.66|
00003a  f5b42f80          CMP      r4,#0x40000
00003e  d10e              BNE      |L18.94|
000040  e006              B        |L18.80|
                  |L18.66|
;;;287      {
;;;288        case RCC_HSE_ON:
;;;289          /* Set HSEON bit */
;;;290          RCC->CR |= CR_HSEON_Set;
000042  4818              LDR      r0,|L18.164|
000044  6800              LDR      r0,[r0,#0]
000046  f4403080          ORR      r0,r0,#0x10000
00004a  4916              LDR      r1,|L18.164|
00004c  6008              STR      r0,[r1,#0]
;;;291          break;
00004e  e007              B        |L18.96|
                  |L18.80|
;;;292          
;;;293        case RCC_HSE_Bypass:
;;;294          /* Set HSEBYP and HSEON bits */
;;;295          RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
000050  4814              LDR      r0,|L18.164|
000052  6800              LDR      r0,[r0,#0]
000054  f44020a0          ORR      r0,r0,#0x50000
000058  4912              LDR      r1,|L18.164|
00005a  6008              STR      r0,[r1,#0]
;;;296          break;
00005c  e000              B        |L18.96|
                  |L18.94|
;;;297          
;;;298        default:
;;;299          break;
00005e  bf00              NOP      
                  |L18.96|
000060  bf00              NOP                            ;291
;;;300      }
;;;301    }
000062  bd10              POP      {r4,pc}
;;;302    
                          ENDP

                  |L18.100|
000064  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000068  2e5c4c69
00006c  62726172
000070  6965735c
000074  53544d33
000078  32463130
00007c  785f5374
000080  64506572
000084  6970685f
000088  44726976
00008c  65725c73
000090  72635c73
000094  746d    
000096  33326631          DCB      "32f10x_rcc.c",0
00009a  30785f72
00009e  63632e63
0000a2  00      
0000a3  00                DCB      0
                  |L18.164|
                          DCD      0x40021000

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;359      */
;;;360    void RCC_HSICmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;361    {
000002  4604              MOV      r4,r0
;;;362      /* Check the parameters */
;;;363      assert_param(IS_FUNCTIONAL_STATE(NewState));
000004  b10c              CBZ      r4,|L19.10|
000006  2c01              CMP      r4,#1
000008  d100              BNE      |L19.12|
                  |L19.10|
00000a  e004              B        |L19.22|
                  |L19.12|
00000c  f240116b          MOV      r1,#0x16b
000010  a002              ADR      r0,|L19.28|
000012  f7fffffe          BL       assert_failed
                  |L19.22|
;;;364      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000016  4811              LDR      r0,|L19.92|
000018  6004              STR      r4,[r0,#0]
;;;365    }
00001a  bd10              POP      {r4,pc}
;;;366    
                          ENDP

                  |L19.28|
00001c  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000020  2e5c4c69
000024  62726172
000028  6965735c
00002c  53544d33
000030  32463130
000034  785f5374
000038  64506572
00003c  6970685f
000040  44726976
000044  65725c73
000048  72635c73
00004c  746d    
00004e  33326631          DCB      "32f10x_rcc.c",0
000052  30785f72
000056  63632e63
00005a  00      
00005b  00                DCB      0
                  |L19.92|
                          DCD      0x42420000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;705      */
;;;706    void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;707    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;708      /* Check the parameters */
;;;709      assert_param(IS_RCC_IT(RCC_IT));
000006  f00400e0          AND      r0,r4,#0xe0
00000a  b908              CBNZ     r0,|L20.16|
00000c  b104              CBZ      r4,|L20.16|
00000e  e004              B        |L20.26|
                  |L20.16|
000010  f24021c5          MOV      r1,#0x2c5
000014  a00c              ADR      r0,|L20.72|
000016  f7fffffe          BL       assert_failed
                  |L20.26|
;;;710      assert_param(IS_FUNCTIONAL_STATE(NewState));
00001a  b10d              CBZ      r5,|L20.32|
00001c  2d01              CMP      r5,#1
00001e  d100              BNE      |L20.34|
                  |L20.32|
000020  e004              B        |L20.44|
                  |L20.34|
000022  f24021c6          MOV      r1,#0x2c6
000026  a008              ADR      r0,|L20.72|
000028  f7fffffe          BL       assert_failed
                  |L20.44|
;;;711      if (NewState != DISABLE)
00002c  b12d              CBZ      r5,|L20.58|
;;;712      {
;;;713        /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
;;;714        *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
00002e  4816              LDR      r0,|L20.136|
000030  7a40              LDRB     r0,[r0,#9]
000032  4320              ORRS     r0,r0,r4
000034  4914              LDR      r1,|L20.136|
000036  7248              STRB     r0,[r1,#9]
000038  e004              B        |L20.68|
                  |L20.58|
;;;715      }
;;;716      else
;;;717      {
;;;718        /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
;;;719        *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
00003a  4813              LDR      r0,|L20.136|
00003c  7a40              LDRB     r0,[r0,#9]
00003e  43a0              BICS     r0,r0,r4
000040  4911              LDR      r1,|L20.136|
000042  7248              STRB     r0,[r1,#9]
                  |L20.68|
;;;720      }
;;;721    }
000044  bd70              POP      {r4-r6,pc}
;;;722    
                          ENDP

000046  0000              DCW      0x0000
                  |L20.72|
000048  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
00004c  2e5c4c69
000050  62726172
000054  6965735c
000058  53544d33
00005c  32463130
000060  785f5374
000064  64506572
000068  6970685f
00006c  44726976
000070  65725c73
000074  72635c73
000078  746d    
00007a  33326631          DCB      "32f10x_rcc.c",0
00007e  30785f72
000082  63632e63
000086  00      
000087  00                DCB      0
                  |L20.136|
                          DCD      0x40021000

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;834      */
;;;835    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  b510              PUSH     {r4,lr}
;;;836    {
000002  4604              MOV      r4,r0
;;;837      /* Check the parameters */
;;;838      assert_param(IS_RCC_LSE(RCC_LSE));
000004  b11c              CBZ      r4,|L21.14|
000006  2c01              CMP      r4,#1
000008  d001              BEQ      |L21.14|
00000a  2c04              CMP      r4,#4
00000c  d100              BNE      |L21.16|
                  |L21.14|
00000e  e004              B        |L21.26|
                  |L21.16|
000010  f2403146          MOV      r1,#0x346
000014  a00c              ADR      r0,|L21.72|
000016  f7fffffe          BL       assert_failed
                  |L21.26|
;;;839      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;840      /* Reset LSEON bit */
;;;841      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
00001a  2000              MOVS     r0,#0
00001c  491a              LDR      r1,|L21.136|
00001e  7008              STRB     r0,[r1,#0]
;;;842      /* Reset LSEBYP bit */
;;;843      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000020  4919              LDR      r1,|L21.136|
000022  3920              SUBS     r1,r1,#0x20
000024  f8810020          STRB     r0,[r1,#0x20]
;;;844      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;845      switch(RCC_LSE)
000028  2c01              CMP      r4,#1
00002a  d002              BEQ      |L21.50|
00002c  2c04              CMP      r4,#4
00002e  d108              BNE      |L21.66|
000030  e003              B        |L21.58|
                  |L21.50|
;;;846      {
;;;847        case RCC_LSE_ON:
;;;848          /* Set LSEON bit */
;;;849          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
000032  2001              MOVS     r0,#1
000034  4914              LDR      r1,|L21.136|
000036  7008              STRB     r0,[r1,#0]
;;;850          break;
000038  e004              B        |L21.68|
                  |L21.58|
;;;851          
;;;852        case RCC_LSE_Bypass:
;;;853          /* Set LSEBYP and LSEON bits */
;;;854          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
00003a  2005              MOVS     r0,#5
00003c  4912              LDR      r1,|L21.136|
00003e  7008              STRB     r0,[r1,#0]
;;;855          break;            
000040  e000              B        |L21.68|
                  |L21.66|
;;;856          
;;;857        default:
;;;858          break;      
000042  bf00              NOP      
                  |L21.68|
000044  bf00              NOP                            ;850
;;;859      }
;;;860    }
000046  bd10              POP      {r4,pc}
;;;861    
                          ENDP

                  |L21.72|
000048  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
00004c  2e5c4c69
000050  62726172
000054  6965735c
000058  53544d33
00005c  32463130
000060  785f5374
000064  64506572
000068  6970685f
00006c  44726976
000070  65725c73
000074  72635c73
000078  746d    
00007a  33326631          DCB      "32f10x_rcc.c",0
00007e  30785f72
000082  63632e63
000086  00      
000087  00                DCB      0
                  |L21.136|
                          DCD      0x40021020

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;867      */
;;;868    void RCC_LSICmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;869    {
000002  4604              MOV      r4,r0
;;;870      /* Check the parameters */
;;;871      assert_param(IS_FUNCTIONAL_STATE(NewState));
000004  b10c              CBZ      r4,|L22.10|
000006  2c01              CMP      r4,#1
000008  d100              BNE      |L22.12|
                  |L22.10|
00000a  e004              B        |L22.22|
                  |L22.12|
00000c  f2403167          MOV      r1,#0x367
000010  a002              ADR      r0,|L22.28|
000012  f7fffffe          BL       assert_failed
                  |L22.22|
;;;872      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000016  4811              LDR      r0,|L22.92|
000018  6004              STR      r4,[r0,#0]
;;;873    }
00001a  bd10              POP      {r4,pc}
;;;874    
                          ENDP

                  |L22.28|
00001c  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000020  2e5c4c69
000024  62726172
000028  6965735c
00002c  53544d33
000030  32463130
000034  785f5374
000038  64506572
00003c  6970685f
000040  44726976
000044  65725c73
000048  72635c73
00004c  746d    
00004e  33326631          DCB      "32f10x_rcc.c",0
000052  30785f72
000056  63632e63
00005a  00      
00005b  00                DCB      0
                  |L22.92|
                          DCD      0x42420480

                          AREA ||i.RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  RCC_MCOConfig PROC
;;;1287     */
;;;1288   void RCC_MCOConfig(uint8_t RCC_MCO)
000000  b510              PUSH     {r4,lr}
;;;1289   {
000002  4604              MOV      r4,r0
;;;1290     /* Check the parameters */
;;;1291     assert_param(IS_RCC_MCO(RCC_MCO));
000004  b13c              CBZ      r4,|L23.22|
000006  2c05              CMP      r4,#5
000008  d005              BEQ      |L23.22|
00000a  2c04              CMP      r4,#4
00000c  d003              BEQ      |L23.22|
00000e  2c06              CMP      r4,#6
000010  d001              BEQ      |L23.22|
000012  2c07              CMP      r4,#7
000014  d100              BNE      |L23.24|
                  |L23.22|
000016  e004              B        |L23.34|
                  |L23.24|
000018  f240510b          MOV      r1,#0x50b
00001c  a002              ADR      r0,|L23.40|
00001e  f7fffffe          BL       assert_failed
                  |L23.34|
;;;1292   
;;;1293     /* Perform Byte access to MCO bits to select the MCO source */
;;;1294     *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
000022  4811              LDR      r0,|L23.104|
000024  71c4              STRB     r4,[r0,#7]
;;;1295   }
000026  bd10              POP      {r4,pc}
;;;1296   
                          ENDP

                  |L23.40|
000028  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
00002c  2e5c4c69
000030  62726172
000034  6965735c
000038  53544d33
00003c  32463130
000040  785f5374
000044  64506572
000048  6970685f
00004c  44726976
000050  65725c73
000054  72635c73
000058  746d    
00005a  33326631          DCB      "32f10x_rcc.c",0
00005e  30785f72
000062  63632e63
000066  00      
000067  00                DCB      0
                  |L23.104|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;639      */
;;;640    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  b570              PUSH     {r4-r6,lr}
;;;641    {
000002  4604              MOV      r4,r0
;;;642      uint32_t tmpreg = 0;
000004  2500              MOVS     r5,#0
;;;643      /* Check the parameters */
;;;644      assert_param(IS_RCC_PCLK(RCC_HCLK));
000006  b15c              CBZ      r4,|L24.32|
000008  f5b46f80          CMP      r4,#0x400
00000c  d008              BEQ      |L24.32|
00000e  f5b46fa0          CMP      r4,#0x500
000012  d005              BEQ      |L24.32|
000014  f5b46fc0          CMP      r4,#0x600
000018  d002              BEQ      |L24.32|
00001a  f5b46fe0          CMP      r4,#0x700
00001e  d100              BNE      |L24.34|
                  |L24.32|
000020  e004              B        |L24.44|
                  |L24.34|
000022  f44f7121          MOV      r1,#0x284
000026  a005              ADR      r0,|L24.60|
000028  f7fffffe          BL       assert_failed
                  |L24.44|
;;;645      tmpreg = RCC->CFGR;
00002c  4813              LDR      r0,|L24.124|
00002e  6845              LDR      r5,[r0,#4]
;;;646      /* Clear PPRE1[2:0] bits */
;;;647      tmpreg &= CFGR_PPRE1_Reset_Mask;
000030  f42565e0          BIC      r5,r5,#0x700
;;;648      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;649      tmpreg |= RCC_HCLK;
000034  4325              ORRS     r5,r5,r4
;;;650      /* Store the new value */
;;;651      RCC->CFGR = tmpreg;
000036  6045              STR      r5,[r0,#4]
;;;652    }
000038  bd70              POP      {r4-r6,pc}
;;;653    
                          ENDP

00003a  0000              DCW      0x0000
                  |L24.60|
00003c  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000040  2e5c4c69
000044  62726172
000048  6965735c
00004c  53544d33
000050  32463130
000054  785f5374
000058  64506572
00005c  6970685f
000060  44726976
000064  65725c73
000068  72635c73
00006c  746d    
00006e  33326631          DCB      "32f10x_rcc.c",0
000072  30785f72
000076  63632e63
00007a  00      
00007b  00                DCB      0
                  |L24.124|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;665      */
;;;666    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  b570              PUSH     {r4-r6,lr}
;;;667    {
000002  4604              MOV      r4,r0
;;;668      uint32_t tmpreg = 0;
000004  2500              MOVS     r5,#0
;;;669      /* Check the parameters */
;;;670      assert_param(IS_RCC_PCLK(RCC_HCLK));
000006  b15c              CBZ      r4,|L25.32|
000008  f5b46f80          CMP      r4,#0x400
00000c  d008              BEQ      |L25.32|
00000e  f5b46fa0          CMP      r4,#0x500
000012  d005              BEQ      |L25.32|
000014  f5b46fc0          CMP      r4,#0x600
000018  d002              BEQ      |L25.32|
00001a  f5b46fe0          CMP      r4,#0x700
00001e  d100              BNE      |L25.34|
                  |L25.32|
000020  e004              B        |L25.44|
                  |L25.34|
000022  f240219e          MOV      r1,#0x29e
000026  a005              ADR      r0,|L25.60|
000028  f7fffffe          BL       assert_failed
                  |L25.44|
;;;671      tmpreg = RCC->CFGR;
00002c  4813              LDR      r0,|L25.124|
00002e  6845              LDR      r5,[r0,#4]
;;;672      /* Clear PPRE2[2:0] bits */
;;;673      tmpreg &= CFGR_PPRE2_Reset_Mask;
000030  f4255560          BIC      r5,r5,#0x3800
;;;674      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;675      tmpreg |= RCC_HCLK << 3;
000034  ea4505c4          ORR      r5,r5,r4,LSL #3
;;;676      /* Store the new value */
;;;677      RCC->CFGR = tmpreg;
000038  6045              STR      r5,[r0,#4]
;;;678    }
00003a  bd70              POP      {r4-r6,pc}
;;;679    
                          ENDP

                  |L25.60|
00003c  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000040  2e5c4c69
000044  62726172
000048  6965735c
00004c  53544d33
000050  32463130
000054  785f5374
000058  64506572
00005c  6970685f
000060  44726976
000064  65725c73
000068  72635c73
00006c  746d    
00006e  33326631          DCB      "32f10x_rcc.c",0
000072  30785f72
000076  63632e63
00007a  00      
00007b  00                DCB      0
                  |L25.124|
                          DCD      0x40021000

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;406      */
;;;407    void RCC_PLLCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;408    {
000002  4604              MOV      r4,r0
;;;409      /* Check the parameters */
;;;410      assert_param(IS_FUNCTIONAL_STATE(NewState));
000004  b10c              CBZ      r4,|L26.10|
000006  2c01              CMP      r4,#1
000008  d100              BNE      |L26.12|
                  |L26.10|
00000a  e004              B        |L26.22|
                  |L26.12|
00000c  f44f71cd          MOV      r1,#0x19a
000010  a002              ADR      r0,|L26.28|
000012  f7fffffe          BL       assert_failed
                  |L26.22|
;;;411    
;;;412      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000016  4811              LDR      r0,|L26.92|
000018  6604              STR      r4,[r0,#0x60]
;;;413    }
00001a  bd10              POP      {r4,pc}
;;;414    
                          ENDP

                  |L26.28|
00001c  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000020  2e5c4c69
000024  62726172
000028  6965735c
00002c  53544d33
000030  32463130
000034  785f5374
000038  64506572
00003c  6970685f
000040  44726976
000044  65725c73
000048  72635c73
00004c  746d    
00004e  33326631          DCB      "32f10x_rcc.c",0
000052  30785f72
000056  63632e63
00005a  00      
00005b  00                DCB      0
                  |L26.92|
                          DCD      0x42420000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;383      */
;;;384    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
000000  b570              PUSH     {r4-r6,lr}
;;;385    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;386      uint32_t tmpreg = 0;
000006  2600              MOVS     r6,#0
;;;387    
;;;388      /* Check the parameters */
;;;389      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
000008  b12d              CBZ      r5,|L27.22|
00000a  f5b53f80          CMP      r5,#0x10000
00000e  d002              BEQ      |L27.22|
000010  f5b53f40          CMP      r5,#0x30000
000014  d100              BNE      |L27.24|
                  |L27.22|
000016  e004              B        |L27.34|
                  |L27.24|
000018  f2401185          MOV      r1,#0x185
00001c  a01e              ADR      r0,|L27.152|
00001e  f7fffffe          BL       assert_failed
                  |L27.34|
;;;390      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
000022  b34c              CBZ      r4,|L27.120|
000024  f5b42f80          CMP      r4,#0x40000
000028  d026              BEQ      |L27.120|
00002a  f5b42f00          CMP      r4,#0x80000
00002e  d023              BEQ      |L27.120|
000030  f5b42f40          CMP      r4,#0xc0000
000034  d020              BEQ      |L27.120|
000036  f5b41f80          CMP      r4,#0x100000
00003a  d01d              BEQ      |L27.120|
00003c  f5b41fa0          CMP      r4,#0x140000
000040  d01a              BEQ      |L27.120|
000042  f5b41fc0          CMP      r4,#0x180000
000046  d017              BEQ      |L27.120|
000048  f5b41fe0          CMP      r4,#0x1c0000
00004c  d014              BEQ      |L27.120|
00004e  f5b41f00          CMP      r4,#0x200000
000052  d011              BEQ      |L27.120|
000054  f5b41f10          CMP      r4,#0x240000
000058  d00e              BEQ      |L27.120|
00005a  f5b41f20          CMP      r4,#0x280000
00005e  d00b              BEQ      |L27.120|
000060  f5b41f30          CMP      r4,#0x2c0000
000064  d008              BEQ      |L27.120|
000066  f5b41f40          CMP      r4,#0x300000
00006a  d005              BEQ      |L27.120|
00006c  f5b41f50          CMP      r4,#0x340000
000070  d002              BEQ      |L27.120|
000072  f5b41f60          CMP      r4,#0x380000
000076  d100              BNE      |L27.122|
                  |L27.120|
000078  e004              B        |L27.132|
                  |L27.122|
00007a  f44f71c3          MOV      r1,#0x186
00007e  a006              ADR      r0,|L27.152|
000080  f7fffffe          BL       assert_failed
                  |L27.132|
;;;391    
;;;392      tmpreg = RCC->CFGR;
000084  4814              LDR      r0,|L27.216|
000086  6846              LDR      r6,[r0,#4]
;;;393      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;394      tmpreg &= CFGR_PLL_Mask;
000088  f426167c          BIC      r6,r6,#0x3f0000
;;;395      /* Set the PLL configuration bits */
;;;396      tmpreg |= RCC_PLLSource | RCC_PLLMul;
00008c  ea450004          ORR      r0,r5,r4
000090  4306              ORRS     r6,r6,r0
;;;397      /* Store the new value */
;;;398      RCC->CFGR = tmpreg;
000092  4811              LDR      r0,|L27.216|
000094  6046              STR      r6,[r0,#4]
;;;399    }
000096  bd70              POP      {r4-r6,pc}
;;;400    
                          ENDP

                  |L27.152|
000098  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
00009c  2e5c4c69
0000a0  62726172
0000a4  6965735c
0000a8  53544d33
0000ac  32463130
0000b0  785f5374
0000b4  64506572
0000b8  6970685f
0000bc  44726976
0000c0  65725c73
0000c4  72635c73
0000c8  746d    
0000ca  33326631          DCB      "32f10x_rcc.c",0
0000ce  30785f72
0000d2  63632e63
0000d6  00      
0000d7  00                DCB      0
                  |L27.216|
                          DCD      0x40021000

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;898      */
;;;899    void RCC_RTCCLKCmd(FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;900    {
000002  4604              MOV      r4,r0
;;;901      /* Check the parameters */
;;;902      assert_param(IS_FUNCTIONAL_STATE(NewState));
000004  b10c              CBZ      r4,|L28.10|
000006  2c01              CMP      r4,#1
000008  d100              BNE      |L28.12|
                  |L28.10|
00000a  e004              B        |L28.22|
                  |L28.12|
00000c  f2403186          MOV      r1,#0x386
000010  a002              ADR      r0,|L28.28|
000012  f7fffffe          BL       assert_failed
                  |L28.22|
;;;903      *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000016  4811              LDR      r0,|L28.92|
000018  6004              STR      r4,[r0,#0]
;;;904    }
00001a  bd10              POP      {r4,pc}
;;;905    
                          ENDP

                  |L28.28|
00001c  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000020  2e5c4c69
000024  62726172
000028  6965735c
00002c  53544d33
000030  32463130
000034  785f5374
000038  64506572
00003c  6970685f
000040  44726976
000044  65725c73
000048  72635c73
00004c  746d    
00004e  33326631          DCB      "32f10x_rcc.c",0
000052  30785f72
000056  63632e63
00005a  00      
00005b  00                DCB      0
                  |L28.92|
                          DCD      0x4242043c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;884      */
;;;885    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  b510              PUSH     {r4,lr}
;;;886    {
000002  4604              MOV      r4,r0
;;;887      /* Check the parameters */
;;;888      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
000004  f5b47f80          CMP      r4,#0x100
000008  d005              BEQ      |L29.22|
00000a  f5b47f00          CMP      r4,#0x200
00000e  d002              BEQ      |L29.22|
000010  f5b47f40          CMP      r4,#0x300
000014  d100              BNE      |L29.24|
                  |L29.22|
000016  e004              B        |L29.34|
                  |L29.24|
000018  f44f715e          MOV      r1,#0x378
00001c  a004              ADR      r0,|L29.48|
00001e  f7fffffe          BL       assert_failed
                  |L29.34|
;;;889      /* Select the RTC clock source */
;;;890      RCC->BDCR |= RCC_RTCCLKSource;
000022  4813              LDR      r0,|L29.112|
000024  6a00              LDR      r0,[r0,#0x20]
000026  4320              ORRS     r0,r0,r4
000028  4911              LDR      r1,|L29.112|
00002a  6208              STR      r0,[r1,#0x20]
;;;891    }
00002c  bd10              POP      {r4,pc}
;;;892    
                          ENDP

00002e  0000              DCW      0x0000
                  |L29.48|
000030  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000034  2e5c4c69
000038  62726172
00003c  6965735c
000040  53544d33
000044  32463130
000048  785f5374
00004c  64506572
000050  6970685f
000054  44726976
000058  65725c73
00005c  72635c73
000060  746d    
000062  33326631          DCB      "32f10x_rcc.c",0
000066  30785f72
00006a  63632e63
00006e  00      
00006f  00                DCB      0
                  |L29.112|
                          DCD      0x40021000

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;569      */
;;;570    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  b570              PUSH     {r4-r6,lr}
;;;571    {
000002  4604              MOV      r4,r0
;;;572      uint32_t tmpreg = 0;
000004  2500              MOVS     r5,#0
;;;573      /* Check the parameters */
;;;574      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
000006  b11c              CBZ      r4,|L30.16|
000008  2c01              CMP      r4,#1
00000a  d001              BEQ      |L30.16|
00000c  2c02              CMP      r4,#2
00000e  d100              BNE      |L30.18|
                  |L30.16|
000010  e004              B        |L30.28|
                  |L30.18|
000012  f240213e          MOV      r1,#0x23e
000016  a005              ADR      r0,|L30.44|
000018  f7fffffe          BL       assert_failed
                  |L30.28|
;;;575      tmpreg = RCC->CFGR;
00001c  4813              LDR      r0,|L30.108|
00001e  6845              LDR      r5,[r0,#4]
;;;576      /* Clear SW[1:0] bits */
;;;577      tmpreg &= CFGR_SW_Mask;
000020  f0250503          BIC      r5,r5,#3
;;;578      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;579      tmpreg |= RCC_SYSCLKSource;
000024  4325              ORRS     r5,r5,r4
;;;580      /* Store the new value */
;;;581      RCC->CFGR = tmpreg;
000026  6045              STR      r5,[r0,#4]
;;;582    }
000028  bd70              POP      {r4-r6,pc}
;;;583    
                          ENDP

00002a  0000              DCW      0x0000
                  |L30.44|
00002c  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000030  2e5c4c69
000034  62726172
000038  6965735c
00003c  53544d33
000040  32463130
000044  785f5374
000048  64506572
00004c  6970685f
000050  44726976
000054  65725c73
000058  72635c73
00005c  746d    
00005e  33326631          DCB      "32f10x_rcc.c",0
000062  30785f72
000066  63632e63
00006a  00      
00006b  00                DCB      0
                  |L30.108|
                          DCD      0x40021000

                          AREA ||i.RCC_USBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USBCLKConfig PROC
;;;733      */
;;;734    void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
000000  b510              PUSH     {r4,lr}
;;;735    {
000002  4604              MOV      r4,r0
;;;736      /* Check the parameters */
;;;737      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
000004  b10c              CBZ      r4,|L31.10|
000006  2c01              CMP      r4,#1
000008  d100              BNE      |L31.12|
                  |L31.10|
00000a  e004              B        |L31.22|
                  |L31.12|
00000c  f24021e1          MOV      r1,#0x2e1
000010  a002              ADR      r0,|L31.28|
000012  f7fffffe          BL       assert_failed
                  |L31.22|
;;;738    
;;;739      *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
000016  4811              LDR      r0,|L31.92|
000018  6004              STR      r4,[r0,#0]
;;;740    }
00001a  bd10              POP      {r4,pc}
;;;741    #else
                          ENDP

                  |L31.28|
00001c  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000020  2e5c4c69
000024  62726172
000028  6965735c
00002c  53544d33
000030  32463130
000034  785f5374
000038  64506572
00003c  6970685f
000040  44726976
000044  65725c73
000048  72635c73
00004c  746d    
00004e  33326631          DCB      "32f10x_rcc.c",0
000052  30785f72
000056  63632e63
00005a  00      
00005b  00                DCB      0
                  |L31.92|
                          DCD      0x424200d8

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;309      */
;;;310    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b538              PUSH     {r3-r5,lr}
;;;311    {
;;;312      __IO uint32_t StartUpCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;313      ErrorStatus status = ERROR;
000006  2400              MOVS     r4,#0
;;;314      FlagStatus HSEStatus = RESET;
000008  2500              MOVS     r5,#0
;;;315      
;;;316      /* Wait till HSE is ready and if Time out is reached exit */
;;;317      do
00000a  bf00              NOP      
                  |L32.12|
;;;318      {
;;;319        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
00000c  2031              MOVS     r0,#0x31
00000e  f7fffffe          BL       RCC_GetFlagStatus
000012  4605              MOV      r5,r0
;;;320        StartUpCounter++;  
000014  9800              LDR      r0,[sp,#0]
000016  1c40              ADDS     r0,r0,#1
000018  9000              STR      r0,[sp,#0]
;;;321      } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
00001a  9800              LDR      r0,[sp,#0]
00001c  f5b06fa0          CMP      r0,#0x500
000020  d001              BEQ      |L32.38|
000022  2d00              CMP      r5,#0
000024  d0f2              BEQ      |L32.12|
                  |L32.38|
;;;322      
;;;323      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
000026  2031              MOVS     r0,#0x31
000028  f7fffffe          BL       RCC_GetFlagStatus
00002c  b108              CBZ      r0,|L32.50|
;;;324      {
;;;325        status = SUCCESS;
00002e  2401              MOVS     r4,#1
000030  e000              B        |L32.52|
                  |L32.50|
;;;326      }
;;;327      else
;;;328      {
;;;329        status = ERROR;
000032  2400              MOVS     r4,#0
                  |L32.52|
;;;330      }  
;;;331      return (status);
000034  4620              MOV      r0,r4
;;;332    }
000036  bd38              POP      {r3-r5,pc}
;;;333    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09
                  ADCPrescTable
000010  02040608          DCB      0x02,0x04,0x06,0x08

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_rcc_c_49e27980____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f10x_rcc_c_49e27980____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_rcc_c_49e27980____REVSH|
#line 128
|__asm___15_stm32f10x_rcc_c_49e27980____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
