; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\stm32f10x_flash.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\stm32f10x_flash.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\Middleware\blue_angel\inc -I..\..\Middleware\bt_callback_manager -I..\..\Middleware\blue_angel\btif -I..\..\Middleware\blue_angel\common -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\blue_angel\src\common -I..\..\Middleware\blue_angel\src\inc -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\blue_angel\platform\rtos -I..\..\Middleware\blue_angel\platform -I..\..\Middleware\ut_manager\Cunit\Headers -I..\..\Middleware\ut_manager\Cunit\interface -I..\..\Middleware\blue_angel\platform\test -I..\..\Middleware\blue_angel\driver -I..\..\Middleware\blue_angel\src\core\hci -I..\..\User\bt\inc -I..\..\Middleware\bt_callback_manager -I..\..\Middleware\at_command -I..\..\Middleware\blue_angel\src\core\gap -I..\..\Middleware\blue_angel\src\core\l2cap -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=522 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DNDEBUG --omf_browse=.\flash\obj\stm32f10x_flash.crf ..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;1443     */
;;;1444   void FLASH_ClearFlag(uint32_t FLASH_FLAG)
000000  b510              PUSH     {r4,lr}
;;;1445   {
000002  4604              MOV      r4,r0
;;;1446   #ifdef STM32F10X_XL
;;;1447     /* Check the parameters */
;;;1448     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;1449   
;;;1450     if((FLASH_FLAG & 0x80000000) != 0x0)
;;;1451     {
;;;1452       /* Clear the flags */
;;;1453       FLASH->SR2 = FLASH_FLAG;
;;;1454     }
;;;1455     else
;;;1456     {
;;;1457       /* Clear the flags */
;;;1458       FLASH->SR = FLASH_FLAG;
;;;1459     }  
;;;1460   
;;;1461   #else
;;;1462     /* Check the parameters */
;;;1463     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
000004  f0240035          BIC      r0,r4,#0x35
000008  b908              CBNZ     r0,|L1.14|
00000a  b104              CBZ      r4,|L1.14|
00000c  e004              B        |L1.24|
                  |L1.14|
00000e  f24051b7          MOV      r1,#0x5b7
000012  4803              LDR      r0,|L1.32|
000014  f7fffffe          BL       assert_failed
                  |L1.24|
;;;1464     
;;;1465     /* Clear the flags */
;;;1466     FLASH->SR = FLASH_FLAG;
000018  4802              LDR      r0,|L1.36|
00001a  60c4              STR      r4,[r0,#0xc]
;;;1467   #endif /* STM32F10X_XL */
;;;1468   }
00001c  bd10              POP      {r4,pc}
;;;1469   
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      ||.conststring||
                  |L1.36|
                          DCD      0x40022000

                          AREA ||i.FLASH_EnableWriteProtection||, CODE, READONLY, ALIGN=2

                  FLASH_EnableWriteProtection PROC
;;;975      */
;;;976    FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;977    {
000004  4604              MOV      r4,r0
;;;978      uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
000006  f64f76ff          MOV      r6,#0xffff
00000a  4637              MOV      r7,r6
00000c  46b0              MOV      r8,r6
00000e  46b1              MOV      r9,r6
;;;979      
;;;980      FLASH_Status status = FLASH_COMPLETE;
000010  2504              MOVS     r5,#4
;;;981      
;;;982      /* Check the parameters */
;;;983      assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
000012  b104              CBZ      r4,|L2.22|
000014  e004              B        |L2.32|
                  |L2.22|
000016  f24031d7          MOV      r1,#0x3d7
00001a  482a              LDR      r0,|L2.196|
00001c  f7fffffe          BL       assert_failed
                  |L2.32|
;;;984      
;;;985      FLASH_Pages = (uint32_t)(~FLASH_Pages);
000020  43e4              MVNS     r4,r4
;;;986      WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
000022  b2e6              UXTB     r6,r4
;;;987      WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
000024  f3c42707          UBFX     r7,r4,#8,#8
;;;988      WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
000028  f3c44807          UBFX     r8,r4,#16,#8
;;;989      WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
00002c  ea4f6914          LSR      r9,r4,#24
;;;990      
;;;991      /* Wait for last operation to be completed */
;;;992      status = FLASH_WaitForLastOperation(ProgramTimeout);
000030  f44f5000          MOV      r0,#0x2000
000034  f7fffffe          BL       FLASH_WaitForLastOperation
000038  4605              MOV      r5,r0
;;;993      
;;;994      if(status == FLASH_COMPLETE)
00003a  2d04              CMP      r5,#4
00003c  d13f              BNE      |L2.190|
;;;995      {
;;;996        /* Authorizes the small information block programming */
;;;997        FLASH->OPTKEYR = FLASH_KEY1;
00003e  4822              LDR      r0,|L2.200|
000040  4922              LDR      r1,|L2.204|
000042  6088              STR      r0,[r1,#8]
;;;998        FLASH->OPTKEYR = FLASH_KEY2;
000044  4822              LDR      r0,|L2.208|
000046  6088              STR      r0,[r1,#8]
;;;999        FLASH->CR |= CR_OPTPG_Set;
000048  4608              MOV      r0,r1
00004a  6900              LDR      r0,[r0,#0x10]
00004c  f0400010          ORR      r0,r0,#0x10
000050  6108              STR      r0,[r1,#0x10]
;;;1000       if(WRP0_Data != 0xFF)
000052  2eff              CMP      r6,#0xff
000054  d005              BEQ      |L2.98|
;;;1001       {
;;;1002         OB->WRP0 = WRP0_Data;
000056  481f              LDR      r0,|L2.212|
000058  8006              STRH     r6,[r0,#0]
;;;1003         
;;;1004         /* Wait for last operation to be completed */
;;;1005         status = FLASH_WaitForLastOperation(ProgramTimeout);
00005a  02e8              LSLS     r0,r5,#11
00005c  f7fffffe          BL       FLASH_WaitForLastOperation
000060  4605              MOV      r5,r0
                  |L2.98|
;;;1006       }
;;;1007       if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
000062  2d04              CMP      r5,#4
000064  d108              BNE      |L2.120|
000066  2fff              CMP      r7,#0xff
000068  d006              BEQ      |L2.120|
;;;1008       {
;;;1009         OB->WRP1 = WRP1_Data;
00006a  481a              LDR      r0,|L2.212|
00006c  1c80              ADDS     r0,r0,#2
00006e  8007              STRH     r7,[r0,#0]
;;;1010         
;;;1011         /* Wait for last operation to be completed */
;;;1012         status = FLASH_WaitForLastOperation(ProgramTimeout);
000070  02e8              LSLS     r0,r5,#11
000072  f7fffffe          BL       FLASH_WaitForLastOperation
000076  4605              MOV      r5,r0
                  |L2.120|
;;;1013       }
;;;1014       if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
000078  2d04              CMP      r5,#4
00007a  d10a              BNE      |L2.146|
00007c  f1b80fff          CMP      r8,#0xff
000080  d007              BEQ      |L2.146|
;;;1015       {
;;;1016         OB->WRP2 = WRP2_Data;
000082  4814              LDR      r0,|L2.212|
000084  1d00              ADDS     r0,r0,#4
000086  f8a08000          STRH     r8,[r0,#0]
;;;1017         
;;;1018         /* Wait for last operation to be completed */
;;;1019         status = FLASH_WaitForLastOperation(ProgramTimeout);
00008a  02e8              LSLS     r0,r5,#11
00008c  f7fffffe          BL       FLASH_WaitForLastOperation
000090  4605              MOV      r5,r0
                  |L2.146|
;;;1020       }
;;;1021       
;;;1022       if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
000092  2d04              CMP      r5,#4
000094  d10a              BNE      |L2.172|
000096  f1b90fff          CMP      r9,#0xff
00009a  d007              BEQ      |L2.172|
;;;1023       {
;;;1024         OB->WRP3 = WRP3_Data;
00009c  480d              LDR      r0,|L2.212|
00009e  1d80              ADDS     r0,r0,#6
0000a0  f8a09000          STRH     r9,[r0,#0]
;;;1025        
;;;1026         /* Wait for last operation to be completed */
;;;1027         status = FLASH_WaitForLastOperation(ProgramTimeout);
0000a4  02e8              LSLS     r0,r5,#11
0000a6  f7fffffe          BL       FLASH_WaitForLastOperation
0000aa  4605              MOV      r5,r0
                  |L2.172|
;;;1028       }
;;;1029             
;;;1030       if(status != FLASH_TIMEOUT)
0000ac  2d05              CMP      r5,#5
0000ae  d006              BEQ      |L2.190|
;;;1031       {
;;;1032         /* if the program operation is completed, disable the OPTPG Bit */
;;;1033         FLASH->CR &= CR_OPTPG_Reset;
0000b0  4806              LDR      r0,|L2.204|
0000b2  6900              LDR      r0,[r0,#0x10]
0000b4  f64171ef          MOV      r1,#0x1fef
0000b8  4008              ANDS     r0,r0,r1
0000ba  4904              LDR      r1,|L2.204|
0000bc  6108              STR      r0,[r1,#0x10]
                  |L2.190|
;;;1034       }
;;;1035     } 
;;;1036     /* Return the write protection operation Status */
;;;1037     return status;       
0000be  4628              MOV      r0,r5
;;;1038   }
0000c0  e8bd87f0          POP      {r4-r10,pc}
;;;1039   
                          ENDP

                  |L2.196|
                          DCD      ||.conststring||
                  |L2.200|
                          DCD      0x45670123
                  |L2.204|
                          DCD      0x40022000
                  |L2.208|
                          DCD      0xcdef89ab
                  |L2.212|
                          DCD      0x1ffff808

                          AREA ||i.FLASH_EraseAllBank1Pages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllBank1Pages PROC
;;;555      */
;;;556    FLASH_Status FLASH_EraseAllBank1Pages(void)
000000  b510              PUSH     {r4,lr}
;;;557    {
;;;558      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;559      /* Wait for last operation to be completed */
;;;560      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000004  f44f2030          MOV      r0,#0xb0000
000008  f7fffffe          BL       FLASH_WaitForLastBank1Operation
00000c  4604              MOV      r4,r0
;;;561      
;;;562      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d116              BNE      |L3.64|
;;;563      {
;;;564        /* if the previous operation is completed, proceed to erase all pages */
;;;565         FLASH->CR |= CR_MER_Set;
000012  480c              LDR      r0,|L3.68|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400004          ORR      r0,r0,#4
00001a  490a              LDR      r1,|L3.68|
00001c  6108              STR      r0,[r1,#0x10]
;;;566         FLASH->CR |= CR_STRT_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6108              STR      r0,[r1,#0x10]
;;;567        
;;;568        /* Wait for last operation to be completed */
;;;569        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000028  f44f2030          MOV      r0,#0xb0000
00002c  f7fffffe          BL       FLASH_WaitForLastBank1Operation
000030  4604              MOV      r4,r0
;;;570        
;;;571        /* Disable the MER Bit */
;;;572        FLASH->CR &= CR_MER_Reset;
000032  4804              LDR      r0,|L3.68|
000034  6900              LDR      r0,[r0,#0x10]
000036  f64171fb          MOV      r1,#0x1ffb
00003a  4008              ANDS     r0,r0,r1
00003c  4901              LDR      r1,|L3.68|
00003e  6108              STR      r0,[r1,#0x10]
                  |L3.64|
;;;573      }    
;;;574      /* Return the Erase Status */
;;;575      return status;
000040  4620              MOV      r0,r4
;;;576    }
000042  bd10              POP      {r4,pc}
;;;577    
                          ENDP

                  |L3.68|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseAllPages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllPages PROC
;;;492      */
;;;493    FLASH_Status FLASH_EraseAllPages(void)
000000  b510              PUSH     {r4,lr}
;;;494    {
;;;495      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;496    
;;;497    #ifdef STM32F10X_XL
;;;498      /* Wait for last operation to be completed */
;;;499      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;500      
;;;501      if(status == FLASH_COMPLETE)
;;;502      {
;;;503        /* if the previous operation is completed, proceed to erase all pages */
;;;504         FLASH->CR |= CR_MER_Set;
;;;505         FLASH->CR |= CR_STRT_Set;
;;;506        
;;;507        /* Wait for last operation to be completed */
;;;508        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;509        
;;;510        /* Disable the MER Bit */
;;;511        FLASH->CR &= CR_MER_Reset;
;;;512      }    
;;;513      if(status == FLASH_COMPLETE)
;;;514      {
;;;515        /* if the previous operation is completed, proceed to erase all pages */
;;;516         FLASH->CR2 |= CR_MER_Set;
;;;517         FLASH->CR2 |= CR_STRT_Set;
;;;518        
;;;519        /* Wait for last operation to be completed */
;;;520        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;521        
;;;522        /* Disable the MER Bit */
;;;523        FLASH->CR2 &= CR_MER_Reset;
;;;524      }
;;;525    #else
;;;526      /* Wait for last operation to be completed */
;;;527      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f44f2030          MOV      r0,#0xb0000
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;528      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d116              BNE      |L4.64|
;;;529      {
;;;530        /* if the previous operation is completed, proceed to erase all pages */
;;;531         FLASH->CR |= CR_MER_Set;
000012  480c              LDR      r0,|L4.68|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400004          ORR      r0,r0,#4
00001a  490a              LDR      r1,|L4.68|
00001c  6108              STR      r0,[r1,#0x10]
;;;532         FLASH->CR |= CR_STRT_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6108              STR      r0,[r1,#0x10]
;;;533        
;;;534        /* Wait for last operation to be completed */
;;;535        status = FLASH_WaitForLastOperation(EraseTimeout);
000028  f44f2030          MOV      r0,#0xb0000
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;536    
;;;537        /* Disable the MER Bit */
;;;538        FLASH->CR &= CR_MER_Reset;
000032  4804              LDR      r0,|L4.68|
000034  6900              LDR      r0,[r0,#0x10]
000036  f64171fb          MOV      r1,#0x1ffb
00003a  4008              ANDS     r0,r0,r1
00003c  4901              LDR      r1,|L4.68|
00003e  6108              STR      r0,[r1,#0x10]
                  |L4.64|
;;;539      }
;;;540    #endif /* STM32F10X_XL */
;;;541    
;;;542      /* Return the Erase Status */
;;;543      return status;
000040  4620              MOV      r0,r4
;;;544    }
000042  bd10              POP      {r4,pc}
;;;545    
                          ENDP

                  |L4.68|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseOptionBytes||, CODE, READONLY, ALIGN=2

                  FLASH_EraseOptionBytes PROC
;;;616      */
;;;617    FLASH_Status FLASH_EraseOptionBytes(void)
000000  b530              PUSH     {r4,r5,lr}
;;;618    {
;;;619      uint16_t rdptmp = RDP_Key;
000002  25a5              MOVS     r5,#0xa5
;;;620    
;;;621      FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;622    
;;;623      /* Get the actual read protection Option Byte value */ 
;;;624      if(FLASH_GetReadOutProtectionStatus() != RESET)
000006  f7fffffe          BL       FLASH_GetReadOutProtectionStatus
00000a  b100              CBZ      r0,|L5.14|
;;;625      {
;;;626        rdptmp = 0x00;  
00000c  2500              MOVS     r5,#0
                  |L5.14|
;;;627      }
;;;628    
;;;629      /* Wait for last operation to be completed */
;;;630      status = FLASH_WaitForLastOperation(EraseTimeout);
00000e  f44f2030          MOV      r0,#0xb0000
000012  f7fffffe          BL       FLASH_WaitForLastOperation
000016  4604              MOV      r4,r0
;;;631      if(status == FLASH_COMPLETE)
000018  2c04              CMP      r4,#4
00001a  d13a              BNE      |L5.146|
;;;632      {
;;;633        /* Authorize the small information block programming */
;;;634        FLASH->OPTKEYR = FLASH_KEY1;
00001c  481e              LDR      r0,|L5.152|
00001e  491f              LDR      r1,|L5.156|
000020  6088              STR      r0,[r1,#8]
;;;635        FLASH->OPTKEYR = FLASH_KEY2;
000022  481f              LDR      r0,|L5.160|
000024  6088              STR      r0,[r1,#8]
;;;636        
;;;637        /* if the previous operation is completed, proceed to erase the option bytes */
;;;638        FLASH->CR |= CR_OPTER_Set;
000026  4608              MOV      r0,r1
000028  6900              LDR      r0,[r0,#0x10]
00002a  f0400020          ORR      r0,r0,#0x20
00002e  6108              STR      r0,[r1,#0x10]
;;;639        FLASH->CR |= CR_STRT_Set;
000030  4608              MOV      r0,r1
000032  6900              LDR      r0,[r0,#0x10]
000034  f0400040          ORR      r0,r0,#0x40
000038  6108              STR      r0,[r1,#0x10]
;;;640        /* Wait for last operation to be completed */
;;;641        status = FLASH_WaitForLastOperation(EraseTimeout);
00003a  f44f2030          MOV      r0,#0xb0000
00003e  f7fffffe          BL       FLASH_WaitForLastOperation
000042  4604              MOV      r4,r0
;;;642        
;;;643        if(status == FLASH_COMPLETE)
000044  2c04              CMP      r4,#4
000046  d11b              BNE      |L5.128|
;;;644        {
;;;645          /* if the erase operation is completed, disable the OPTER Bit */
;;;646          FLASH->CR &= CR_OPTER_Reset;
000048  4814              LDR      r0,|L5.156|
00004a  6900              LDR      r0,[r0,#0x10]
00004c  f64171df          MOV      r1,#0x1fdf
000050  4008              ANDS     r0,r0,r1
000052  4912              LDR      r1,|L5.156|
000054  6108              STR      r0,[r1,#0x10]
;;;647           
;;;648          /* Enable the Option Bytes Programming operation */
;;;649          FLASH->CR |= CR_OPTPG_Set;
000056  4608              MOV      r0,r1
000058  6900              LDR      r0,[r0,#0x10]
00005a  f0400010          ORR      r0,r0,#0x10
00005e  6108              STR      r0,[r1,#0x10]
;;;650          /* Restore the last read protection Option Byte value */
;;;651          OB->RDP = (uint16_t)rdptmp; 
000060  4810              LDR      r0,|L5.164|
000062  8005              STRH     r5,[r0,#0]
;;;652          /* Wait for last operation to be completed */
;;;653          status = FLASH_WaitForLastOperation(ProgramTimeout);
000064  02e0              LSLS     r0,r4,#11
000066  f7fffffe          BL       FLASH_WaitForLastOperation
00006a  4604              MOV      r4,r0
;;;654     
;;;655          if(status != FLASH_TIMEOUT)
00006c  2c05              CMP      r4,#5
00006e  d010              BEQ      |L5.146|
;;;656          {
;;;657            /* if the program operation is completed, disable the OPTPG Bit */
;;;658            FLASH->CR &= CR_OPTPG_Reset;
000070  480a              LDR      r0,|L5.156|
000072  6900              LDR      r0,[r0,#0x10]
000074  f64171ef          MOV      r1,#0x1fef
000078  4008              ANDS     r0,r0,r1
00007a  4908              LDR      r1,|L5.156|
00007c  6108              STR      r0,[r1,#0x10]
00007e  e008              B        |L5.146|
                  |L5.128|
;;;659          }
;;;660        }
;;;661        else
;;;662        {
;;;663          if (status != FLASH_TIMEOUT)
000080  2c05              CMP      r4,#5
000082  d006              BEQ      |L5.146|
;;;664          {
;;;665            /* Disable the OPTPG Bit */
;;;666            FLASH->CR &= CR_OPTPG_Reset;
000084  4805              LDR      r0,|L5.156|
000086  6900              LDR      r0,[r0,#0x10]
000088  f64171ef          MOV      r1,#0x1fef
00008c  4008              ANDS     r0,r0,r1
00008e  4903              LDR      r1,|L5.156|
000090  6108              STR      r0,[r1,#0x10]
                  |L5.146|
;;;667          }
;;;668        }  
;;;669      }
;;;670      /* Return the erase status */
;;;671      return status;
000092  4620              MOV      r0,r4
;;;672    }
000094  bd30              POP      {r4,r5,pc}
;;;673    
                          ENDP

000096  0000              DCW      0x0000
                  |L5.152|
                          DCD      0x45670123
                  |L5.156|
                          DCD      0x40022000
                  |L5.160|
                          DCD      0xcdef89ab
                  |L5.164|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_ErasePage||, CODE, READONLY, ALIGN=2

                  FLASH_ErasePage PROC
;;;419      */
;;;420    FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
000000  b570              PUSH     {r4-r6,lr}
;;;421    {
000002  4604              MOV      r4,r0
;;;422      FLASH_Status status = FLASH_COMPLETE;
000004  2504              MOVS     r5,#4
;;;423      /* Check the parameters */
;;;424      assert_param(IS_FLASH_ADDRESS(Page_Address));
000006  f1b46f00          CMP      r4,#0x8000000
00000a  d303              BCC      |L6.20|
00000c  4814              LDR      r0,|L6.96|
00000e  4284              CMP      r4,r0
000010  d200              BCS      |L6.20|
000012  e004              B        |L6.30|
                  |L6.20|
000014  f44f71d4          MOV      r1,#0x1a8
000018  4812              LDR      r0,|L6.100|
00001a  f7fffffe          BL       assert_failed
                  |L6.30|
;;;425    
;;;426    #ifdef STM32F10X_XL
;;;427      if(Page_Address < FLASH_BANK1_END_ADDRESS)  
;;;428      {
;;;429        /* Wait for last operation to be completed */
;;;430        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;431        if(status == FLASH_COMPLETE)
;;;432        { 
;;;433          /* if the previous operation is completed, proceed to erase the page */
;;;434          FLASH->CR|= CR_PER_Set;
;;;435          FLASH->AR = Page_Address; 
;;;436          FLASH->CR|= CR_STRT_Set;
;;;437        
;;;438          /* Wait for last operation to be completed */
;;;439          status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;440    
;;;441          /* Disable the PER Bit */
;;;442          FLASH->CR &= CR_PER_Reset;
;;;443        }
;;;444      }
;;;445      else
;;;446      {
;;;447        /* Wait for last operation to be completed */
;;;448        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;449        if(status == FLASH_COMPLETE)
;;;450        { 
;;;451          /* if the previous operation is completed, proceed to erase the page */
;;;452          FLASH->CR2|= CR_PER_Set;
;;;453          FLASH->AR2 = Page_Address; 
;;;454          FLASH->CR2|= CR_STRT_Set;
;;;455        
;;;456          /* Wait for last operation to be completed */
;;;457          status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;458          
;;;459          /* Disable the PER Bit */
;;;460          FLASH->CR2 &= CR_PER_Reset;
;;;461        }
;;;462      }
;;;463    #else
;;;464      /* Wait for last operation to be completed */
;;;465      status = FLASH_WaitForLastOperation(EraseTimeout);
00001e  f44f2030          MOV      r0,#0xb0000
000022  f7fffffe          BL       FLASH_WaitForLastOperation
000026  4605              MOV      r5,r0
;;;466      
;;;467      if(status == FLASH_COMPLETE)
000028  2d04              CMP      r5,#4
00002a  d117              BNE      |L6.92|
;;;468      { 
;;;469        /* if the previous operation is completed, proceed to erase the page */
;;;470        FLASH->CR|= CR_PER_Set;
00002c  480e              LDR      r0,|L6.104|
00002e  6900              LDR      r0,[r0,#0x10]
000030  f0400002          ORR      r0,r0,#2
000034  490c              LDR      r1,|L6.104|
000036  6108              STR      r0,[r1,#0x10]
;;;471        FLASH->AR = Page_Address; 
000038  4608              MOV      r0,r1
00003a  6144              STR      r4,[r0,#0x14]
;;;472        FLASH->CR|= CR_STRT_Set;
00003c  6900              LDR      r0,[r0,#0x10]
00003e  f0400040          ORR      r0,r0,#0x40
000042  6108              STR      r0,[r1,#0x10]
;;;473        
;;;474        /* Wait for last operation to be completed */
;;;475        status = FLASH_WaitForLastOperation(EraseTimeout);
000044  f44f2030          MOV      r0,#0xb0000
000048  f7fffffe          BL       FLASH_WaitForLastOperation
00004c  4605              MOV      r5,r0
;;;476        
;;;477        /* Disable the PER Bit */
;;;478        FLASH->CR &= CR_PER_Reset;
00004e  4806              LDR      r0,|L6.104|
000050  6900              LDR      r0,[r0,#0x10]
000052  f64171fd          MOV      r1,#0x1ffd
000056  4008              ANDS     r0,r0,r1
000058  4903              LDR      r1,|L6.104|
00005a  6108              STR      r0,[r1,#0x10]
                  |L6.92|
;;;479      }
;;;480    #endif /* STM32F10X_XL */
;;;481    
;;;482      /* Return the Erase Status */
;;;483      return status;
00005c  4628              MOV      r0,r5
;;;484    }
00005e  bd70              POP      {r4-r6,pc}
;;;485    
                          ENDP

                  |L6.96|
                          DCD      0x080fffff
                  |L6.100|
                          DCD      ||.conststring||
                  |L6.104|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetBank1Status||, CODE, READONLY, ALIGN=2

                  FLASH_GetBank1Status PROC
;;;1515     */
;;;1516   FLASH_Status FLASH_GetBank1Status(void)
000000  2004              MOVS     r0,#4
;;;1517   {
;;;1518     FLASH_Status flashstatus = FLASH_COMPLETE;
;;;1519     
;;;1520     if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
000002  490b              LDR      r1,|L7.48|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0010101          AND      r1,r1,#1
00000a  b109              CBZ      r1,|L7.16|
;;;1521     {
;;;1522       flashstatus = FLASH_BUSY;
00000c  2001              MOVS     r0,#1
00000e  e00e              B        |L7.46|
                  |L7.16|
;;;1523     }
;;;1524     else 
;;;1525     {  
;;;1526       if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
000010  4907              LDR      r1,|L7.48|
000012  68c9              LDR      r1,[r1,#0xc]
000014  f0010104          AND      r1,r1,#4
000018  b109              CBZ      r1,|L7.30|
;;;1527       { 
;;;1528         flashstatus = FLASH_ERROR_PG;
00001a  2002              MOVS     r0,#2
00001c  e007              B        |L7.46|
                  |L7.30|
;;;1529       }
;;;1530       else 
;;;1531       {
;;;1532         if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
00001e  4904              LDR      r1,|L7.48|
000020  68c9              LDR      r1,[r1,#0xc]
000022  f0010110          AND      r1,r1,#0x10
000026  b109              CBZ      r1,|L7.44|
;;;1533         {
;;;1534           flashstatus = FLASH_ERROR_WRP;
000028  2003              MOVS     r0,#3
00002a  e000              B        |L7.46|
                  |L7.44|
;;;1535         }
;;;1536         else
;;;1537         {
;;;1538           flashstatus = FLASH_COMPLETE;
00002c  2004              MOVS     r0,#4
                  |L7.46|
;;;1539         }
;;;1540       }
;;;1541     }
;;;1542     /* Return the Flash Status */
;;;1543     return flashstatus;
;;;1544   }
00002e  4770              BX       lr
;;;1545   
                          ENDP

                  |L7.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;1357     */
;;;1358   FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1359   {
000002  4604              MOV      r4,r0
;;;1360     FlagStatus bitstatus = RESET;
000004  2500              MOVS     r5,#0
;;;1361   
;;;1362   #ifdef STM32F10X_XL
;;;1363     /* Check the parameters */
;;;1364     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;1365     if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
;;;1366     {
;;;1367       if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
;;;1368       {
;;;1369         bitstatus = SET;
;;;1370       }
;;;1371       else
;;;1372       {
;;;1373         bitstatus = RESET;
;;;1374       }
;;;1375     }
;;;1376     else
;;;1377     {
;;;1378       if((FLASH_FLAG & 0x80000000) != 0x0)
;;;1379       {
;;;1380         if((FLASH->SR2 & FLASH_FLAG) != (uint32_t)RESET)
;;;1381         {
;;;1382           bitstatus = SET;
;;;1383         }
;;;1384         else
;;;1385         {
;;;1386           bitstatus = RESET;
;;;1387         }
;;;1388       }
;;;1389       else
;;;1390       {
;;;1391         if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
;;;1392         {
;;;1393           bitstatus = SET;
;;;1394         }
;;;1395         else
;;;1396         {
;;;1397           bitstatus = RESET;
;;;1398         }
;;;1399       }
;;;1400     }
;;;1401   #else
;;;1402     /* Check the parameters */
;;;1403     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
000006  2c01              CMP      r4,#1
000008  d00f              BEQ      |L8.42|
00000a  2c20              CMP      r4,#0x20
00000c  d00d              BEQ      |L8.42|
00000e  2c04              CMP      r4,#4
000010  d00b              BEQ      |L8.42|
000012  2c10              CMP      r4,#0x10
000014  d009              BEQ      |L8.42|
000016  2c01              CMP      r4,#1
000018  d007              BEQ      |L8.42|
00001a  2c20              CMP      r4,#0x20
00001c  d005              BEQ      |L8.42|
00001e  2c04              CMP      r4,#4
000020  d003              BEQ      |L8.42|
000022  2c10              CMP      r4,#0x10
000024  d001              BEQ      |L8.42|
000026  2c01              CMP      r4,#1
000028  d100              BNE      |L8.44|
                  |L8.42|
00002a  e004              B        |L8.54|
                  |L8.44|
00002c  f240517b          MOV      r1,#0x57b
000030  480b              LDR      r0,|L8.96|
000032  f7fffffe          BL       assert_failed
                  |L8.54|
;;;1404     if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
000036  2c01              CMP      r4,#1
000038  d108              BNE      |L8.76|
;;;1405     {
;;;1406       if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
00003a  480a              LDR      r0,|L8.100|
00003c  69c0              LDR      r0,[r0,#0x1c]
00003e  f0000001          AND      r0,r0,#1
000042  b108              CBZ      r0,|L8.72|
;;;1407       {
;;;1408         bitstatus = SET;
000044  2501              MOVS     r5,#1
000046  e008              B        |L8.90|
                  |L8.72|
;;;1409       }
;;;1410       else
;;;1411       {
;;;1412         bitstatus = RESET;
000048  2500              MOVS     r5,#0
00004a  e006              B        |L8.90|
                  |L8.76|
;;;1413       }
;;;1414     }
;;;1415     else
;;;1416     {
;;;1417      if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
00004c  4805              LDR      r0,|L8.100|
00004e  68c0              LDR      r0,[r0,#0xc]
000050  4020              ANDS     r0,r0,r4
000052  b108              CBZ      r0,|L8.88|
;;;1418       {
;;;1419         bitstatus = SET;
000054  2501              MOVS     r5,#1
000056  e000              B        |L8.90|
                  |L8.88|
;;;1420       }
;;;1421       else
;;;1422       {
;;;1423         bitstatus = RESET;
000058  2500              MOVS     r5,#0
                  |L8.90|
;;;1424       }
;;;1425     }
;;;1426   #endif /* STM32F10X_XL */
;;;1427   
;;;1428     /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;1429     return bitstatus;
00005a  4628              MOV      r0,r5
;;;1430   }
00005c  bd70              POP      {r4-r6,pc}
;;;1431   
                          ENDP

00005e  0000              DCW      0x0000
                  |L8.96|
                          DCD      ||.conststring||
                  |L8.100|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetPrefetchBufferStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetPrefetchBufferStatus PROC
;;;1260     */
;;;1261   FlagStatus FLASH_GetPrefetchBufferStatus(void)
000000  2000              MOVS     r0,#0
;;;1262   {
;;;1263     FlagStatus bitstatus = RESET;
;;;1264     
;;;1265     if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
000002  4904              LDR      r1,|L9.20|
000004  6809              LDR      r1,[r1,#0]
000006  f0010120          AND      r1,r1,#0x20
00000a  b109              CBZ      r1,|L9.16|
;;;1266     {
;;;1267       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L9.18|
                  |L9.16|
;;;1268     }
;;;1269     else
;;;1270     {
;;;1271       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L9.18|
;;;1272     }
;;;1273     /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;1274     return bitstatus; 
;;;1275   }
000012  4770              BX       lr
;;;1276   
                          ENDP

                  |L9.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetReadOutProtectionStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetReadOutProtectionStatus PROC
;;;1240     */
;;;1241   FlagStatus FLASH_GetReadOutProtectionStatus(void)
000000  2000              MOVS     r0,#0
;;;1242   {
;;;1243     FlagStatus readoutstatus = RESET;
;;;1244     if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
000002  4904              LDR      r1,|L10.20|
000004  69c9              LDR      r1,[r1,#0x1c]
000006  f0010102          AND      r1,r1,#2
00000a  b109              CBZ      r1,|L10.16|
;;;1245     {
;;;1246       readoutstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L10.18|
                  |L10.16|
;;;1247     }
;;;1248     else
;;;1249     {
;;;1250       readoutstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L10.18|
;;;1251     }
;;;1252     return readoutstatus;
;;;1253   }
000012  4770              BX       lr
;;;1254   
                          ENDP

                  |L10.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;1477     */
;;;1478   FLASH_Status FLASH_GetStatus(void)
000000  2004              MOVS     r0,#4
;;;1479   {
;;;1480     FLASH_Status flashstatus = FLASH_COMPLETE;
;;;1481     
;;;1482     if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000002  490b              LDR      r1,|L11.48|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0010101          AND      r1,r1,#1
00000a  b109              CBZ      r1,|L11.16|
;;;1483     {
;;;1484       flashstatus = FLASH_BUSY;
00000c  2001              MOVS     r0,#1
00000e  e00e              B        |L11.46|
                  |L11.16|
;;;1485     }
;;;1486     else 
;;;1487     {  
;;;1488       if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
000010  4907              LDR      r1,|L11.48|
000012  68c9              LDR      r1,[r1,#0xc]
000014  f0010104          AND      r1,r1,#4
000018  b109              CBZ      r1,|L11.30|
;;;1489       { 
;;;1490         flashstatus = FLASH_ERROR_PG;
00001a  2002              MOVS     r0,#2
00001c  e007              B        |L11.46|
                  |L11.30|
;;;1491       }
;;;1492       else 
;;;1493       {
;;;1494         if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
00001e  4904              LDR      r1,|L11.48|
000020  68c9              LDR      r1,[r1,#0xc]
000022  f0010110          AND      r1,r1,#0x10
000026  b109              CBZ      r1,|L11.44|
;;;1495         {
;;;1496           flashstatus = FLASH_ERROR_WRP;
000028  2003              MOVS     r0,#3
00002a  e000              B        |L11.46|
                  |L11.44|
;;;1497         }
;;;1498         else
;;;1499         {
;;;1500           flashstatus = FLASH_COMPLETE;
00002c  2004              MOVS     r0,#4
                  |L11.46|
;;;1501         }
;;;1502       }
;;;1503     }
;;;1504     /* Return the Flash Status */
;;;1505     return flashstatus;
;;;1506   }
00002e  4770              BX       lr
;;;1507   
                          ENDP

                  |L11.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetUserOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetUserOptionByte PROC
;;;1216     */
;;;1217   uint32_t FLASH_GetUserOptionByte(void)
000000  4801              LDR      r0,|L12.8|
;;;1218   {
;;;1219     /* Return the User Option Byte */
;;;1220     return (uint32_t)(FLASH->OBR >> 2);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  0880              LSRS     r0,r0,#2
;;;1221   }
000006  4770              BX       lr
;;;1222   
                          ENDP

                  |L12.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetWriteProtectionOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetWriteProtectionOptionByte PROC
;;;1228     */
;;;1229   uint32_t FLASH_GetWriteProtectionOptionByte(void)
000000  4801              LDR      r0,|L13.8|
;;;1230   {
;;;1231     /* Return the Flash write protection Register value */
;;;1232     return (uint32_t)(FLASH->WRPR);
000002  6a00              LDR      r0,[r0,#0x20]
;;;1233   }
000004  4770              BX       lr
;;;1234   
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_HalfCycleAccessCmd||, CODE, READONLY, ALIGN=2

                  FLASH_HalfCycleAccessCmd PROC
;;;281      */
;;;282    void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
000000  b510              PUSH     {r4,lr}
;;;283    {
000002  4604              MOV      r4,r0
;;;284      /* Check the parameters */
;;;285      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
000004  2c08              CMP      r4,#8
000006  d000              BEQ      |L14.10|
000008  b904              CBNZ     r4,|L14.12|
                  |L14.10|
00000a  e004              B        |L14.22|
                  |L14.12|
00000c  f240111d          MOV      r1,#0x11d
000010  4806              LDR      r0,|L14.44|
000012  f7fffffe          BL       assert_failed
                  |L14.22|
;;;286      
;;;287      /* Enable or disable the Half cycle access */
;;;288      FLASH->ACR &= ACR_HLFCYA_Mask;
000016  4806              LDR      r0,|L14.48|
000018  6800              LDR      r0,[r0,#0]
00001a  f0200008          BIC      r0,r0,#8
00001e  4904              LDR      r1,|L14.48|
000020  6008              STR      r0,[r1,#0]
;;;289      FLASH->ACR |= FLASH_HalfCycleAccess;
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]
000026  4320              ORRS     r0,r0,r4
000028  6008              STR      r0,[r1,#0]
;;;290    }
00002a  bd10              POP      {r4,pc}
;;;291    
                          ENDP

                  |L14.44|
                          DCD      ||.conststring||
                  |L14.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;1290     */
;;;1291   void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1292   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1293   #ifdef STM32F10X_XL
;;;1294     /* Check the parameters */
;;;1295     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1296     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1297   
;;;1298     if((FLASH_IT & 0x80000000) != 0x0)
;;;1299     {
;;;1300       if(NewState != DISABLE)
;;;1301       {
;;;1302         /* Enable the interrupt sources */
;;;1303         FLASH->CR2 |= (FLASH_IT & 0x7FFFFFFF);
;;;1304       }
;;;1305       else
;;;1306       {
;;;1307         /* Disable the interrupt sources */
;;;1308         FLASH->CR2 &= ~(uint32_t)(FLASH_IT & 0x7FFFFFFF);
;;;1309       }
;;;1310     }
;;;1311     else
;;;1312     {
;;;1313       if(NewState != DISABLE)
;;;1314       {
;;;1315         /* Enable the interrupt sources */
;;;1316         FLASH->CR |= FLASH_IT;
;;;1317       }
;;;1318       else
;;;1319       {
;;;1320         /* Disable the interrupt sources */
;;;1321         FLASH->CR &= ~(uint32_t)FLASH_IT;
;;;1322       }
;;;1323     }
;;;1324   #else
;;;1325     /* Check the parameters */
;;;1326     assert_param(IS_FLASH_IT(FLASH_IT)); 
000006  f42450a0          BIC      r0,r4,#0x1400
00000a  b908              CBNZ     r0,|L15.16|
00000c  b104              CBZ      r4,|L15.16|
00000e  e004              B        |L15.26|
                  |L15.16|
000010  f240512e          MOV      r1,#0x52e
000014  480c              LDR      r0,|L15.72|
000016  f7fffffe          BL       assert_failed
                  |L15.26|
;;;1327     assert_param(IS_FUNCTIONAL_STATE(NewState));
00001a  b10d              CBZ      r5,|L15.32|
00001c  2d01              CMP      r5,#1
00001e  d100              BNE      |L15.34|
                  |L15.32|
000020  e004              B        |L15.44|
                  |L15.34|
000022  f240512f          MOV      r1,#0x52f
000026  4808              LDR      r0,|L15.72|
000028  f7fffffe          BL       assert_failed
                  |L15.44|
;;;1328   
;;;1329     if(NewState != DISABLE)
00002c  b12d              CBZ      r5,|L15.58|
;;;1330     {
;;;1331       /* Enable the interrupt sources */
;;;1332       FLASH->CR |= FLASH_IT;
00002e  4807              LDR      r0,|L15.76|
000030  6900              LDR      r0,[r0,#0x10]
000032  4320              ORRS     r0,r0,r4
000034  4905              LDR      r1,|L15.76|
000036  6108              STR      r0,[r1,#0x10]
000038  e004              B        |L15.68|
                  |L15.58|
;;;1333     }
;;;1334     else
;;;1335     {
;;;1336       /* Disable the interrupt sources */
;;;1337       FLASH->CR &= ~(uint32_t)FLASH_IT;
00003a  4804              LDR      r0,|L15.76|
00003c  6900              LDR      r0,[r0,#0x10]
00003e  43a0              BICS     r0,r0,r4
000040  4902              LDR      r1,|L15.76|
000042  6108              STR      r0,[r1,#0x10]
                  |L15.68|
;;;1338     }
;;;1339   #endif /* STM32F10X_XL */
;;;1340   }
000044  bd70              POP      {r4-r6,pc}
;;;1341   
                          ENDP

000046  0000              DCW      0x0000
                  |L15.72|
                          DCD      ||.conststring||
                  |L15.76|
                          DCD      0x40022000

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;372      */
;;;373    void FLASH_Lock(void)
000000  4803              LDR      r0,|L16.16|
;;;374    {
;;;375      /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
;;;376      FLASH->CR |= CR_LOCK_Set;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L16.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;377    
;;;378    #ifdef STM32F10X_XL
;;;379      /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
;;;380      FLASH->CR2 |= CR_LOCK_Set;
;;;381    #endif /* STM32F10X_XL */
;;;382    }
00000c  4770              BX       lr
;;;383    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_LockBank1||, CODE, READONLY, ALIGN=2

                  FLASH_LockBank1 PROC
;;;392      */
;;;393    void FLASH_LockBank1(void)
000000  4803              LDR      r0,|L17.16|
;;;394    {
;;;395      /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
;;;396      FLASH->CR |= CR_LOCK_Set;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L17.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;397    }
00000c  4770              BX       lr
;;;398    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;300      */
;;;301    void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
000000  b510              PUSH     {r4,lr}
;;;302    {
000002  4604              MOV      r4,r0
;;;303      /* Check the parameters */
;;;304      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
000004  2c10              CMP      r4,#0x10
000006  d000              BEQ      |L18.10|
000008  b904              CBNZ     r4,|L18.12|
                  |L18.10|
00000a  e004              B        |L18.22|
                  |L18.12|
00000c  f44f7198          MOV      r1,#0x130
000010  4806              LDR      r0,|L18.44|
000012  f7fffffe          BL       assert_failed
                  |L18.22|
;;;305      
;;;306      /* Enable or disable the Prefetch Buffer */
;;;307      FLASH->ACR &= ACR_PRFTBE_Mask;
000016  4806              LDR      r0,|L18.48|
000018  6800              LDR      r0,[r0,#0]
00001a  f0200010          BIC      r0,r0,#0x10
00001e  4904              LDR      r1,|L18.48|
000020  6008              STR      r0,[r1,#0]
;;;308      FLASH->ACR |= FLASH_PrefetchBuffer;
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]
000026  4320              ORRS     r0,r0,r4
000028  6008              STR      r0,[r1,#0]
;;;309    }
00002a  bd10              POP      {r4,pc}
;;;310    
                          ENDP

                  |L18.44|
                          DCD      ||.conststring||
                  |L18.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;858      */
;;;859    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;860    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;861      FLASH_Status status = FLASH_COMPLETE;
000006  2604              MOVS     r6,#4
;;;862      /* Check the parameters */
;;;863      assert_param(IS_FLASH_ADDRESS(Address));
000008  f1b46f00          CMP      r4,#0x8000000
00000c  d303              BCC      |L19.22|
00000e  4812              LDR      r0,|L19.88|
000010  4284              CMP      r4,r0
000012  d200              BCS      |L19.22|
000014  e004              B        |L19.32|
                  |L19.22|
000016  f240315f          MOV      r1,#0x35f
00001a  4810              LDR      r0,|L19.92|
00001c  f7fffffe          BL       assert_failed
                  |L19.32|
;;;864    
;;;865    #ifdef STM32F10X_XL
;;;866      /* Wait for last operation to be completed */
;;;867      status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;868      
;;;869      if(Address < FLASH_BANK1_END_ADDRESS)
;;;870      {
;;;871        if(status == FLASH_COMPLETE)
;;;872        {
;;;873          /* if the previous operation is completed, proceed to program the new data */
;;;874          FLASH->CR |= CR_PG_Set;
;;;875      
;;;876          *(__IO uint16_t*)Address = Data;
;;;877          /* Wait for last operation to be completed */
;;;878          status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;879    
;;;880          /* Disable the PG Bit */
;;;881          FLASH->CR &= CR_PG_Reset;
;;;882        }
;;;883      }
;;;884      else
;;;885      {
;;;886        if(status == FLASH_COMPLETE)
;;;887        {
;;;888          /* if the previous operation is completed, proceed to program the new data */
;;;889          FLASH->CR2 |= CR_PG_Set;
;;;890      
;;;891          *(__IO uint16_t*)Address = Data;
;;;892          /* Wait for last operation to be completed */
;;;893          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;894    
;;;895          /* Disable the PG Bit */
;;;896          FLASH->CR2 &= CR_PG_Reset;
;;;897        }
;;;898      }
;;;899    #else
;;;900      /* Wait for last operation to be completed */
;;;901      status = FLASH_WaitForLastOperation(ProgramTimeout);
000020  f44f5000          MOV      r0,#0x2000
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4606              MOV      r6,r0
;;;902      
;;;903      if(status == FLASH_COMPLETE)
00002a  2e04              CMP      r6,#4
00002c  d111              BNE      |L19.82|
;;;904      {
;;;905        /* if the previous operation is completed, proceed to program the new data */
;;;906        FLASH->CR |= CR_PG_Set;
00002e  480c              LDR      r0,|L19.96|
000030  6900              LDR      r0,[r0,#0x10]
000032  f0400001          ORR      r0,r0,#1
000036  490a              LDR      r1,|L19.96|
000038  6108              STR      r0,[r1,#0x10]
;;;907      
;;;908        *(__IO uint16_t*)Address = Data;
00003a  8025              STRH     r5,[r4,#0]
;;;909        /* Wait for last operation to be completed */
;;;910        status = FLASH_WaitForLastOperation(ProgramTimeout);
00003c  02f0              LSLS     r0,r6,#11
00003e  f7fffffe          BL       FLASH_WaitForLastOperation
000042  4606              MOV      r6,r0
;;;911        
;;;912        /* Disable the PG Bit */
;;;913        FLASH->CR &= CR_PG_Reset;
000044  4806              LDR      r0,|L19.96|
000046  6900              LDR      r0,[r0,#0x10]
000048  f64171fe          MOV      r1,#0x1ffe
00004c  4008              ANDS     r0,r0,r1
00004e  4904              LDR      r1,|L19.96|
000050  6108              STR      r0,[r1,#0x10]
                  |L19.82|
;;;914      } 
;;;915    #endif  /* STM32F10X_XL */
;;;916      
;;;917      /* Return the Program Status */
;;;918      return status;
000052  4630              MOV      r0,r6
;;;919    }
000054  bd70              POP      {r4-r6,pc}
;;;920    
                          ENDP

000056  0000              DCW      0x0000
                  |L19.88|
                          DCD      0x080fffff
                  |L19.92|
                          DCD      ||.conststring||
                  |L19.96|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramOptionByteData||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramOptionByteData PROC
;;;929      */
;;;930    FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;931    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;932      FLASH_Status status = FLASH_COMPLETE;
000006  2504              MOVS     r5,#4
;;;933      /* Check the parameters */
;;;934      assert_param(IS_OB_DATA_ADDRESS(Address));
000008  4816              LDR      r0,|L20.100|
00000a  4284              CMP      r4,r0
00000c  d002              BEQ      |L20.20|
00000e  1c80              ADDS     r0,r0,#2
000010  4284              CMP      r4,r0
000012  d100              BNE      |L20.22|
                  |L20.20|
000014  e004              B        |L20.32|
                  |L20.22|
000016  f24031a6          MOV      r1,#0x3a6
00001a  4813              LDR      r0,|L20.104|
00001c  f7fffffe          BL       assert_failed
                  |L20.32|
;;;935      status = FLASH_WaitForLastOperation(ProgramTimeout);
000020  f44f5000          MOV      r0,#0x2000
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4605              MOV      r5,r0
;;;936    
;;;937      if(status == FLASH_COMPLETE)
00002a  2d04              CMP      r5,#4
00002c  d117              BNE      |L20.94|
;;;938      {
;;;939        /* Authorize the small information block programming */
;;;940        FLASH->OPTKEYR = FLASH_KEY1;
00002e  480f              LDR      r0,|L20.108|
000030  490f              LDR      r1,|L20.112|
000032  6088              STR      r0,[r1,#8]
;;;941        FLASH->OPTKEYR = FLASH_KEY2;
000034  480f              LDR      r0,|L20.116|
000036  6088              STR      r0,[r1,#8]
;;;942        /* Enables the Option Bytes Programming operation */
;;;943        FLASH->CR |= CR_OPTPG_Set; 
000038  4608              MOV      r0,r1
00003a  6900              LDR      r0,[r0,#0x10]
00003c  f0400010          ORR      r0,r0,#0x10
000040  6108              STR      r0,[r1,#0x10]
;;;944        *(__IO uint16_t*)Address = Data;
000042  8026              STRH     r6,[r4,#0]
;;;945        
;;;946        /* Wait for last operation to be completed */
;;;947        status = FLASH_WaitForLastOperation(ProgramTimeout);
000044  02e8              LSLS     r0,r5,#11
000046  f7fffffe          BL       FLASH_WaitForLastOperation
00004a  4605              MOV      r5,r0
;;;948        if(status != FLASH_TIMEOUT)
00004c  2d05              CMP      r5,#5
00004e  d006              BEQ      |L20.94|
;;;949        {
;;;950          /* if the program operation is completed, disable the OPTPG Bit */
;;;951          FLASH->CR &= CR_OPTPG_Reset;
000050  4807              LDR      r0,|L20.112|
000052  6900              LDR      r0,[r0,#0x10]
000054  f64171ef          MOV      r1,#0x1fef
000058  4008              ANDS     r0,r0,r1
00005a  4905              LDR      r1,|L20.112|
00005c  6108              STR      r0,[r1,#0x10]
                  |L20.94|
;;;952        }
;;;953      }
;;;954      /* Return the Option Byte Data Program Status */
;;;955      return status;
00005e  4628              MOV      r0,r5
;;;956    }
000060  bd70              POP      {r4-r6,pc}
;;;957    
                          ENDP

000062  0000              DCW      0x0000
                  |L20.100|
                          DCD      0x1ffff804
                  |L20.104|
                          DCD      ||.conststring||
                  |L20.108|
                          DCD      0x45670123
                  |L20.112|
                          DCD      0x40022000
                  |L20.116|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;681      */
;;;682    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
000000  b5f8              PUSH     {r3-r7,lr}
;;;683    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;684      FLASH_Status status = FLASH_COMPLETE;
000006  2604              MOVS     r6,#4
;;;685      __IO uint32_t tmp = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;686    
;;;687      /* Check the parameters */
;;;688      assert_param(IS_FLASH_ADDRESS(Address));
00000c  f1b46f00          CMP      r4,#0x8000000
000010  d303              BCC      |L21.26|
000012  481b              LDR      r0,|L21.128|
000014  4284              CMP      r4,r0
000016  d200              BCS      |L21.26|
000018  e004              B        |L21.36|
                  |L21.26|
00001a  f44f712c          MOV      r1,#0x2b0
00001e  4819              LDR      r0,|L21.132|
000020  f7fffffe          BL       assert_failed
                  |L21.36|
;;;689    
;;;690    #ifdef STM32F10X_XL
;;;691      if(Address < FLASH_BANK1_END_ADDRESS - 2)
;;;692      { 
;;;693        /* Wait for last operation to be completed */
;;;694        status = FLASH_WaitForLastBank1Operation(ProgramTimeout); 
;;;695        if(status == FLASH_COMPLETE)
;;;696        {
;;;697          /* if the previous operation is completed, proceed to program the new first 
;;;698            half word */
;;;699          FLASH->CR |= CR_PG_Set;
;;;700      
;;;701          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;702          /* Wait for last operation to be completed */
;;;703          status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;704     
;;;705          if(status == FLASH_COMPLETE)
;;;706          {
;;;707            /* if the previous operation is completed, proceed to program the new second 
;;;708            half word */
;;;709            tmp = Address + 2;
;;;710    
;;;711            *(__IO uint16_t*) tmp = Data >> 16;
;;;712        
;;;713            /* Wait for last operation to be completed */
;;;714            status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;715            
;;;716            /* Disable the PG Bit */
;;;717            FLASH->CR &= CR_PG_Reset;
;;;718          }
;;;719          else
;;;720          {
;;;721            /* Disable the PG Bit */
;;;722            FLASH->CR &= CR_PG_Reset;
;;;723           }
;;;724        }
;;;725      }
;;;726      else if(Address == (FLASH_BANK1_END_ADDRESS - 1))
;;;727      {
;;;728        /* Wait for last operation to be completed */
;;;729        status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;730    
;;;731        if(status == FLASH_COMPLETE)
;;;732        {
;;;733          /* if the previous operation is completed, proceed to program the new first 
;;;734            half word */
;;;735          FLASH->CR |= CR_PG_Set;
;;;736      
;;;737          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;738    
;;;739          /* Wait for last operation to be completed */
;;;740          status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;741          
;;;742    	  /* Disable the PG Bit */
;;;743          FLASH->CR &= CR_PG_Reset;
;;;744        }
;;;745        else
;;;746        {
;;;747          /* Disable the PG Bit */
;;;748          FLASH->CR &= CR_PG_Reset;
;;;749        }
;;;750    
;;;751        /* Wait for last operation to be completed */
;;;752        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;753    
;;;754        if(status == FLASH_COMPLETE)
;;;755        {
;;;756          /* if the previous operation is completed, proceed to program the new second 
;;;757          half word */
;;;758          FLASH->CR2 |= CR_PG_Set;
;;;759          tmp = Address + 2;
;;;760    
;;;761          *(__IO uint16_t*) tmp = Data >> 16;
;;;762        
;;;763          /* Wait for last operation to be completed */
;;;764          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;765            
;;;766          /* Disable the PG Bit */
;;;767          FLASH->CR2 &= CR_PG_Reset;
;;;768        }
;;;769        else
;;;770        {
;;;771          /* Disable the PG Bit */
;;;772          FLASH->CR2 &= CR_PG_Reset;
;;;773        }
;;;774      }
;;;775      else
;;;776      {
;;;777        /* Wait for last operation to be completed */
;;;778        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;779    
;;;780        if(status == FLASH_COMPLETE)
;;;781        {
;;;782          /* if the previous operation is completed, proceed to program the new first 
;;;783            half word */
;;;784          FLASH->CR2 |= CR_PG_Set;
;;;785      
;;;786          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;787          /* Wait for last operation to be completed */
;;;788          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;789     
;;;790          if(status == FLASH_COMPLETE)
;;;791          {
;;;792            /* if the previous operation is completed, proceed to program the new second 
;;;793            half word */
;;;794            tmp = Address + 2;
;;;795    
;;;796            *(__IO uint16_t*) tmp = Data >> 16;
;;;797        
;;;798            /* Wait for last operation to be completed */
;;;799            status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;800            
;;;801            /* Disable the PG Bit */
;;;802            FLASH->CR2 &= CR_PG_Reset;
;;;803          }
;;;804          else
;;;805          {
;;;806            /* Disable the PG Bit */
;;;807            FLASH->CR2 &= CR_PG_Reset;
;;;808          }
;;;809        }
;;;810      }
;;;811    #else
;;;812      /* Wait for last operation to be completed */
;;;813      status = FLASH_WaitForLastOperation(ProgramTimeout);
000024  f44f5000          MOV      r0,#0x2000
000028  f7fffffe          BL       FLASH_WaitForLastOperation
00002c  4606              MOV      r6,r0
;;;814      
;;;815      if(status == FLASH_COMPLETE)
00002e  2e04              CMP      r6,#4
000030  d124              BNE      |L21.124|
;;;816      {
;;;817        /* if the previous operation is completed, proceed to program the new first 
;;;818        half word */
;;;819        FLASH->CR |= CR_PG_Set;
000032  4815              LDR      r0,|L21.136|
000034  6900              LDR      r0,[r0,#0x10]
000036  f0400001          ORR      r0,r0,#1
00003a  4913              LDR      r1,|L21.136|
00003c  6108              STR      r0,[r1,#0x10]
;;;820      
;;;821        *(__IO uint16_t*)Address = (uint16_t)Data;
00003e  8025              STRH     r5,[r4,#0]
;;;822        /* Wait for last operation to be completed */
;;;823        status = FLASH_WaitForLastOperation(ProgramTimeout);
000040  02f0              LSLS     r0,r6,#11
000042  f7fffffe          BL       FLASH_WaitForLastOperation
000046  4606              MOV      r6,r0
;;;824     
;;;825        if(status == FLASH_COMPLETE)
000048  2e04              CMP      r6,#4
00004a  d110              BNE      |L21.110|
;;;826        {
;;;827          /* if the previous operation is completed, proceed to program the new second 
;;;828          half word */
;;;829          tmp = Address + 2;
00004c  1ca0              ADDS     r0,r4,#2
00004e  9000              STR      r0,[sp,#0]
;;;830    
;;;831          *(__IO uint16_t*) tmp = Data >> 16;
000050  0c28              LSRS     r0,r5,#16
000052  9900              LDR      r1,[sp,#0]
000054  8008              STRH     r0,[r1,#0]
;;;832        
;;;833          /* Wait for last operation to be completed */
;;;834          status = FLASH_WaitForLastOperation(ProgramTimeout);
000056  02f0              LSLS     r0,r6,#11
000058  f7fffffe          BL       FLASH_WaitForLastOperation
00005c  4606              MOV      r6,r0
;;;835            
;;;836          /* Disable the PG Bit */
;;;837          FLASH->CR &= CR_PG_Reset;
00005e  480a              LDR      r0,|L21.136|
000060  6900              LDR      r0,[r0,#0x10]
000062  f64171fe          MOV      r1,#0x1ffe
000066  4008              ANDS     r0,r0,r1
000068  4907              LDR      r1,|L21.136|
00006a  6108              STR      r0,[r1,#0x10]
00006c  e006              B        |L21.124|
                  |L21.110|
;;;838        }
;;;839        else
;;;840        {
;;;841          /* Disable the PG Bit */
;;;842          FLASH->CR &= CR_PG_Reset;
00006e  4806              LDR      r0,|L21.136|
000070  6900              LDR      r0,[r0,#0x10]
000072  f64171fe          MOV      r1,#0x1ffe
000076  4008              ANDS     r0,r0,r1
000078  4903              LDR      r1,|L21.136|
00007a  6108              STR      r0,[r1,#0x10]
                  |L21.124|
;;;843        }
;;;844      }         
;;;845    #endif /* STM32F10X_XL */
;;;846       
;;;847      /* Return the Program Status */
;;;848      return status;
00007c  4630              MOV      r0,r6
;;;849    }
00007e  bdf8              POP      {r3-r7,pc}
;;;850    
                          ENDP

                  |L21.128|
                          DCD      0x080fffff
                  |L21.132|
                          DCD      ||.conststring||
                  |L21.136|
                          DCD      0x40022000

                          AREA ||i.FLASH_ReadOutProtection||, CODE, READONLY, ALIGN=2

                  FLASH_ReadOutProtection PROC
;;;1049     */
;;;1050   FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1051   {
000002  4605              MOV      r5,r0
;;;1052     FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;1053     /* Check the parameters */
;;;1054     assert_param(IS_FUNCTIONAL_STATE(NewState));
000006  b10d              CBZ      r5,|L22.12|
000008  2d01              CMP      r5,#1
00000a  d100              BNE      |L22.14|
                  |L22.12|
00000c  e004              B        |L22.24|
                  |L22.14|
00000e  f240411e          MOV      r1,#0x41e
000012  4827              LDR      r0,|L22.176|
000014  f7fffffe          BL       assert_failed
                  |L22.24|
;;;1055     status = FLASH_WaitForLastOperation(EraseTimeout);
000018  f44f2030          MOV      r0,#0xb0000
00001c  f7fffffe          BL       FLASH_WaitForLastOperation
000020  4604              MOV      r4,r0
;;;1056     if(status == FLASH_COMPLETE)
000022  2c04              CMP      r4,#4
000024  d141              BNE      |L22.170|
;;;1057     {
;;;1058       /* Authorizes the small information block programming */
;;;1059       FLASH->OPTKEYR = FLASH_KEY1;
000026  4823              LDR      r0,|L22.180|
000028  4923              LDR      r1,|L22.184|
00002a  6088              STR      r0,[r1,#8]
;;;1060       FLASH->OPTKEYR = FLASH_KEY2;
00002c  4823              LDR      r0,|L22.188|
00002e  6088              STR      r0,[r1,#8]
;;;1061       FLASH->CR |= CR_OPTER_Set;
000030  4608              MOV      r0,r1
000032  6900              LDR      r0,[r0,#0x10]
000034  f0400020          ORR      r0,r0,#0x20
000038  6108              STR      r0,[r1,#0x10]
;;;1062       FLASH->CR |= CR_STRT_Set;
00003a  4608              MOV      r0,r1
00003c  6900              LDR      r0,[r0,#0x10]
00003e  f0400040          ORR      r0,r0,#0x40
000042  6108              STR      r0,[r1,#0x10]
;;;1063       /* Wait for last operation to be completed */
;;;1064       status = FLASH_WaitForLastOperation(EraseTimeout);
000044  f44f2030          MOV      r0,#0xb0000
000048  f7fffffe          BL       FLASH_WaitForLastOperation
00004c  4604              MOV      r4,r0
;;;1065       if(status == FLASH_COMPLETE)
00004e  2c04              CMP      r4,#4
000050  d122              BNE      |L22.152|
;;;1066       {
;;;1067         /* if the erase operation is completed, disable the OPTER Bit */
;;;1068         FLASH->CR &= CR_OPTER_Reset;
000052  4819              LDR      r0,|L22.184|
000054  6900              LDR      r0,[r0,#0x10]
000056  f64171df          MOV      r1,#0x1fdf
00005a  4008              ANDS     r0,r0,r1
00005c  4916              LDR      r1,|L22.184|
00005e  6108              STR      r0,[r1,#0x10]
;;;1069         /* Enable the Option Bytes Programming operation */
;;;1070         FLASH->CR |= CR_OPTPG_Set; 
000060  4608              MOV      r0,r1
000062  6900              LDR      r0,[r0,#0x10]
000064  f0400010          ORR      r0,r0,#0x10
000068  6108              STR      r0,[r1,#0x10]
;;;1071         if(NewState != DISABLE)
00006a  b11d              CBZ      r5,|L22.116|
;;;1072         {
;;;1073           OB->RDP = 0x00;
00006c  2000              MOVS     r0,#0
00006e  4914              LDR      r1,|L22.192|
000070  8008              STRH     r0,[r1,#0]
000072  e002              B        |L22.122|
                  |L22.116|
;;;1074         }
;;;1075         else
;;;1076         {
;;;1077           OB->RDP = RDP_Key;  
000074  20a5              MOVS     r0,#0xa5
000076  4912              LDR      r1,|L22.192|
000078  8008              STRH     r0,[r1,#0]
                  |L22.122|
;;;1078         }
;;;1079         /* Wait for last operation to be completed */
;;;1080         status = FLASH_WaitForLastOperation(EraseTimeout); 
00007a  f44f2030          MOV      r0,#0xb0000
00007e  f7fffffe          BL       FLASH_WaitForLastOperation
000082  4604              MOV      r4,r0
;;;1081       
;;;1082         if(status != FLASH_TIMEOUT)
000084  2c05              CMP      r4,#5
000086  d010              BEQ      |L22.170|
;;;1083         {
;;;1084           /* if the program operation is completed, disable the OPTPG Bit */
;;;1085           FLASH->CR &= CR_OPTPG_Reset;
000088  480b              LDR      r0,|L22.184|
00008a  6900              LDR      r0,[r0,#0x10]
00008c  f64171ef          MOV      r1,#0x1fef
000090  4008              ANDS     r0,r0,r1
000092  4909              LDR      r1,|L22.184|
000094  6108              STR      r0,[r1,#0x10]
000096  e008              B        |L22.170|
                  |L22.152|
;;;1086         }
;;;1087       }
;;;1088       else 
;;;1089       {
;;;1090         if(status != FLASH_TIMEOUT)
000098  2c05              CMP      r4,#5
00009a  d006              BEQ      |L22.170|
;;;1091         {
;;;1092           /* Disable the OPTER Bit */
;;;1093           FLASH->CR &= CR_OPTER_Reset;
00009c  4806              LDR      r0,|L22.184|
00009e  6900              LDR      r0,[r0,#0x10]
0000a0  f64171df          MOV      r1,#0x1fdf
0000a4  4008              ANDS     r0,r0,r1
0000a6  4904              LDR      r1,|L22.184|
0000a8  6108              STR      r0,[r1,#0x10]
                  |L22.170|
;;;1094         }
;;;1095       }
;;;1096     }
;;;1097     /* Return the protection operation Status */
;;;1098     return status;       
0000aa  4620              MOV      r0,r4
;;;1099   }
0000ac  bd70              POP      {r4-r6,pc}
;;;1100   
                          ENDP

0000ae  0000              DCW      0x0000
                  |L22.176|
                          DCD      ||.conststring||
                  |L22.180|
                          DCD      0x45670123
                  |L22.184|
                          DCD      0x40022000
                  |L22.188|
                          DCD      0xcdef89ab
                  |L22.192|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;254      */
;;;255    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  b570              PUSH     {r4-r6,lr}
;;;256    {
000002  4604              MOV      r4,r0
;;;257      uint32_t tmpreg = 0;
000004  2500              MOVS     r5,#0
;;;258      
;;;259      /* Check the parameters */
;;;260      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
000006  b11c              CBZ      r4,|L23.16|
000008  2c01              CMP      r4,#1
00000a  d001              BEQ      |L23.16|
00000c  2c02              CMP      r4,#2
00000e  d100              BNE      |L23.18|
                  |L23.16|
000010  e004              B        |L23.28|
                  |L23.18|
000012  f44f7182          MOV      r1,#0x104
000016  4805              LDR      r0,|L23.44|
000018  f7fffffe          BL       assert_failed
                  |L23.28|
;;;261      
;;;262      /* Read the ACR register */
;;;263      tmpreg = FLASH->ACR;  
00001c  4804              LDR      r0,|L23.48|
00001e  6805              LDR      r5,[r0,#0]
;;;264      
;;;265      /* Sets the Latency value */
;;;266      tmpreg &= ACR_LATENCY_Mask;
000020  f0050538          AND      r5,r5,#0x38
;;;267      tmpreg |= FLASH_Latency;
000024  4325              ORRS     r5,r5,r4
;;;268      
;;;269      /* Write the ACR register */
;;;270      FLASH->ACR = tmpreg;
000026  6005              STR      r5,[r0,#0]
;;;271    }
000028  bd70              POP      {r4-r6,pc}
;;;272    
                          ENDP

00002a  0000              DCW      0x0000
                  |L23.44|
                          DCD      ||.conststring||
                  |L23.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;319      */
;;;320    void FLASH_Unlock(void)
000000  4802              LDR      r0,|L24.12|
;;;321    {
;;;322      /* Authorize the FPEC of Bank1 Access */
;;;323      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L24.16|
000004  6048              STR      r0,[r1,#4]
;;;324      FLASH->KEYR = FLASH_KEY2;
000006  4803              LDR      r0,|L24.20|
000008  6048              STR      r0,[r1,#4]
;;;325    
;;;326    #ifdef STM32F10X_XL
;;;327      /* Authorize the FPEC of Bank2 Access */
;;;328      FLASH->KEYR2 = FLASH_KEY1;
;;;329      FLASH->KEYR2 = FLASH_KEY2;
;;;330    #endif /* STM32F10X_XL */
;;;331    }
00000a  4770              BX       lr
;;;332    /**
                          ENDP

                  |L24.12|
                          DCD      0x45670123
                  |L24.16|
                          DCD      0x40022000
                  |L24.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UnlockBank1||, CODE, READONLY, ALIGN=2

                  FLASH_UnlockBank1 PROC
;;;340      */
;;;341    void FLASH_UnlockBank1(void)
000000  4802              LDR      r0,|L25.12|
;;;342    {
;;;343      /* Authorize the FPEC of Bank1 Access */
;;;344      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L25.16|
000004  6048              STR      r0,[r1,#4]
;;;345      FLASH->KEYR = FLASH_KEY2;
000006  4803              LDR      r0,|L25.20|
000008  6048              STR      r0,[r1,#4]
;;;346    }
00000a  4770              BX       lr
;;;347    
                          ENDP

                  |L25.12|
                          DCD      0x45670123
                  |L25.16|
                          DCD      0x40022000
                  |L25.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UserOptionByteConfig||, CODE, READONLY, ALIGN=2

                  FLASH_UserOptionByteConfig PROC
;;;1118     */
;;;1119   FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1120   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1121     FLASH_Status status = FLASH_COMPLETE; 
00000a  2704              MOVS     r7,#4
;;;1122   
;;;1123     /* Check the parameters */
;;;1124     assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
00000c  2c01              CMP      r4,#1
00000e  d000              BEQ      |L26.18|
000010  b904              CBNZ     r4,|L26.20|
                  |L26.18|
000012  e004              B        |L26.30|
                  |L26.20|
000014  f2404164          MOV      r1,#0x464
000018  481e              LDR      r0,|L26.148|
00001a  f7fffffe          BL       assert_failed
                  |L26.30|
;;;1125     assert_param(IS_OB_STOP_SOURCE(OB_STOP));
00001e  2d02              CMP      r5,#2
000020  d000              BEQ      |L26.36|
000022  b905              CBNZ     r5,|L26.38|
                  |L26.36|
000024  e004              B        |L26.48|
                  |L26.38|
000026  f2404165          MOV      r1,#0x465
00002a  481a              LDR      r0,|L26.148|
00002c  f7fffffe          BL       assert_failed
                  |L26.48|
;;;1126     assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
000030  2e04              CMP      r6,#4
000032  d000              BEQ      |L26.54|
000034  b906              CBNZ     r6,|L26.56|
                  |L26.54|
000036  e004              B        |L26.66|
                  |L26.56|
000038  f2404166          MOV      r1,#0x466
00003c  4815              LDR      r0,|L26.148|
00003e  f7fffffe          BL       assert_failed
                  |L26.66|
;;;1127   
;;;1128     /* Authorize the small information block programming */
;;;1129     FLASH->OPTKEYR = FLASH_KEY1;
000042  4815              LDR      r0,|L26.152|
000044  4915              LDR      r1,|L26.156|
000046  6088              STR      r0,[r1,#8]
;;;1130     FLASH->OPTKEYR = FLASH_KEY2;
000048  4815              LDR      r0,|L26.160|
00004a  6088              STR      r0,[r1,#8]
;;;1131     
;;;1132     /* Wait for last operation to be completed */
;;;1133     status = FLASH_WaitForLastOperation(ProgramTimeout);
00004c  f44f5000          MOV      r0,#0x2000
000050  f7fffffe          BL       FLASH_WaitForLastOperation
000054  4607              MOV      r7,r0
;;;1134     
;;;1135     if(status == FLASH_COMPLETE)
000056  2f04              CMP      r7,#4
000058  d118              BNE      |L26.140|
;;;1136     {  
;;;1137       /* Enable the Option Bytes Programming operation */
;;;1138       FLASH->CR |= CR_OPTPG_Set; 
00005a  4810              LDR      r0,|L26.156|
00005c  6900              LDR      r0,[r0,#0x10]
00005e  f0400010          ORR      r0,r0,#0x10
000062  490e              LDR      r1,|L26.156|
000064  6108              STR      r0,[r1,#0x10]
;;;1139              
;;;1140       OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
000066  f04600f8          ORR      r0,r6,#0xf8
00006a  4328              ORRS     r0,r0,r5
00006c  4320              ORRS     r0,r0,r4
00006e  490d              LDR      r1,|L26.164|
000070  8008              STRH     r0,[r1,#0]
;;;1141     
;;;1142       /* Wait for last operation to be completed */
;;;1143       status = FLASH_WaitForLastOperation(ProgramTimeout);
000072  02f8              LSLS     r0,r7,#11
000074  f7fffffe          BL       FLASH_WaitForLastOperation
000078  4607              MOV      r7,r0
;;;1144       if(status != FLASH_TIMEOUT)
00007a  2f05              CMP      r7,#5
00007c  d006              BEQ      |L26.140|
;;;1145       {
;;;1146         /* if the program operation is completed, disable the OPTPG Bit */
;;;1147         FLASH->CR &= CR_OPTPG_Reset;
00007e  4807              LDR      r0,|L26.156|
000080  6900              LDR      r0,[r0,#0x10]
000082  f64171ef          MOV      r1,#0x1fef
000086  4008              ANDS     r0,r0,r1
000088  4904              LDR      r1,|L26.156|
00008a  6108              STR      r0,[r1,#0x10]
                  |L26.140|
;;;1148       }
;;;1149     }    
;;;1150     /* Return the Option Byte program Status */
;;;1151     return status;
00008c  4638              MOV      r0,r7
;;;1152   }
00008e  e8bd81f0          POP      {r4-r8,pc}
;;;1153   
                          ENDP

000092  0000              DCW      0x0000
                  |L26.148|
                          DCD      ||.conststring||
                  |L26.152|
                          DCD      0x45670123
                  |L26.156|
                          DCD      0x40022000
                  |L26.160|
                          DCD      0xcdef89ab
                  |L26.164|
                          DCD      0x1ffff802

                          AREA ||i.FLASH_WaitForLastBank1Operation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastBank1Operation PROC
;;;1623     */
;;;1624   FLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1625   { 
000002  4602              MOV      r2,r0
;;;1626     FLASH_Status status = FLASH_COMPLETE;
000004  2304              MOVS     r3,#4
;;;1627      
;;;1628     /* Check for the Flash Status */
;;;1629     status = FLASH_GetBank1Status();
000006  f7fffffe          BL       FLASH_GetBank1Status
00000a  4603              MOV      r3,r0
;;;1630     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1631     while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
00000c  e003              B        |L27.22|
                  |L27.14|
;;;1632     {
;;;1633       status = FLASH_GetBank1Status();
00000e  f7fffffe          BL       FLASH_GetBank1Status
000012  4603              MOV      r3,r0
;;;1634       Timeout--;
000014  1e52              SUBS     r2,r2,#1
                  |L27.22|
000016  2b01              CMP      r3,#1                 ;1631
000018  d101              BNE      |L27.30|
00001a  2a00              CMP      r2,#0                 ;1631
00001c  d1f7              BNE      |L27.14|
                  |L27.30|
;;;1635     }
;;;1636     if(Timeout == 0x00 )
00001e  b902              CBNZ     r2,|L27.34|
;;;1637     {
;;;1638       status = FLASH_TIMEOUT;
000020  2305              MOVS     r3,#5
                  |L27.34|
;;;1639     }
;;;1640     /* Return the operation status */
;;;1641     return status;
000022  4618              MOV      r0,r3
;;;1642   }
000024  bd00              POP      {pc}
;;;1643   
                          ENDP


                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastOperation PROC
;;;1595     */
;;;1596   FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1597   { 
000002  4602              MOV      r2,r0
;;;1598     FLASH_Status status = FLASH_COMPLETE;
000004  2304              MOVS     r3,#4
;;;1599      
;;;1600     /* Check for the Flash Status */
;;;1601     status = FLASH_GetBank1Status();
000006  f7fffffe          BL       FLASH_GetBank1Status
00000a  4603              MOV      r3,r0
;;;1602     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1603     while((status == FLASH_BUSY) && (Timeout != 0x00))
00000c  e003              B        |L28.22|
                  |L28.14|
;;;1604     {
;;;1605       status = FLASH_GetBank1Status();
00000e  f7fffffe          BL       FLASH_GetBank1Status
000012  4603              MOV      r3,r0
;;;1606       Timeout--;
000014  1e52              SUBS     r2,r2,#1
                  |L28.22|
000016  2b01              CMP      r3,#1                 ;1603
000018  d101              BNE      |L28.30|
00001a  2a00              CMP      r2,#0                 ;1603
00001c  d1f7              BNE      |L28.14|
                  |L28.30|
;;;1607     }
;;;1608     if(Timeout == 0x00 )
00001e  b902              CBNZ     r2,|L28.34|
;;;1609     {
;;;1610       status = FLASH_TIMEOUT;
000020  2305              MOVS     r3,#5
                  |L28.34|
;;;1611     }
;;;1612     /* Return the operation status */
;;;1613     return status;
000022  4618              MOV      r0,r3
;;;1614   }
000024  bd00              POP      {pc}
;;;1615   
                          ENDP


                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2e2e5c2e          DCB      "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm"
000004  2e5c4c69
000008  62726172
00000c  6965735c
000010  53544d33
000014  32463130
000018  785f5374
00001c  64506572
000020  6970685f
000024  44726976
000028  65725c73
00002c  72635c73
000030  746d    
000032  33326631          DCB      "32f10x_flash.c",0
000036  30785f66
00003a  6c617368
00003e  2e6300  

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f10x_flash_c_a2a150d6____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32f10x_flash_c_a2a150d6____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f10x_flash_c_a2a150d6____REVSH|
#line 128
|__asm___17_stm32f10x_flash_c_a2a150d6____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
