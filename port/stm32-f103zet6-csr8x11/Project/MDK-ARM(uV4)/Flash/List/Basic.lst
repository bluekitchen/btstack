L 1 "..\..\Middleware\ut_manager\Cunit\Sources\Basic\Basic.c"
N/*
N *  CUnit - A Unit testing framework library for C.
N *  Copyright (C) 2004-2006  Jerry St.Clair, Anil Kumar
N *
N *  This library is free software; you can redistribute it and/or
N *  modify it under the terms of the GNU Library General Public
N *  License as published by the Free Software Foundation; either
N *  version 2 of the License, or (at your option) any later version.
N *
N *  This library is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
N *  Library General Public License for more details.
N *
N *  You should have received a copy of the GNU Library General Public
N *  License along with this library; if not, write to the Free Software
N *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
N */
N
N/*
N *  Implementation for basic test runner interface.
N *
N *  11-Aug-2004   Initial implementation of basic test runner interface.  (JDS)
N *
N *  8-Jan-2005    Fixed reporting bug (bug report cunit-Bugs-1093861).  (JDS)
N *
N *  30-Apr-2005   Added notification of suite cleanup failure.  (JDS)
N *
N *  02-May-2006   Added internationalization hooks.  (JDS)
N */
N
N/** @file
N * Basic interface with output to stdout.
N */
N/** @addtogroup Basic
N * @{
N */
N
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060019
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 40 "..\..\Middleware\ut_manager\Cunit\Sources\Basic\Basic.c" 2
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 41 "..\..\Middleware\ut_manager\Cunit\Sources\Basic\Basic.c" 2
N#include <ctype.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\ctype.h" 1
N/* ctype.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.3 */
N/* Copyright (C) Codemist Ltd. 1988-1993.                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.03 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/*
N * ctype.h declares several functions useful for testing and mapping
N * characters. In all cases the argument is an int, the value of which shall
N * be representable as an unsigned char or shall equal the value of the
N * macro EOF. If the argument has any other value, the behaviour is undefined.
N */
N
N#ifndef __ctype_h
N#define __ctype_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE_DEF inline
S#elif defined(__GNUC__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif 0L || (1L && 199901L <= 199409L)
S#define _ARMABI_INLINE_DEF static inline
S#elif defined(_USE_STATIC_INLINE)
X#elif 0L
S#define _ARMABI_INLINE_DEF static __inline
N#else
N#define _ARMABI_INLINE_DEF __inline
N#endif
N
N  #ifndef __CTYPE_DECLS
N  #define __CTYPE_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/* AEABI portable ctype flag bits */
N#define _ABI_A    1       /* alphabetic        */
N#define _ABI_X    2       /* A-F, a-f and 0-9  */
N#define _ABI_P    4       /* punctuation       */
N#define _ABI_B    8       /* blank             */
N#define _ABI_S   16       /* white space       */
N#define _ABI_L   32       /* lower case letter */
N#define _ABI_U   64       /* upper case letter */
N#define _ABI_C  128       /* control chars     */
N
N/* ARM internal ctype flag bits */
N/* N.B. - keep in step with <ctype.c> */
N
N/*
N * __ARM_CT_A (alphabetic) is required because characters in some locales
N * (e.g. Japanese) can be alphabetic but neither uppercase nor
N * lowercase. Unfortunately there wasn't a bit free for this, so
N * instead we've defined __ARM_CT_A as __ARM_CT_N+__ARM_CT_X (on the grounds that this
N * was a previously unused combination). Hence some of the ctype
N * predicates below are slightly less than obvious in
N * implementation.
N */
N#define __ARM_CT_S 1            /* whitespace           */
N#define __ARM_CT_P 2            /* punctuation          */
N#define __ARM_CT_B 4            /* blank                */
N#define __ARM_CT_L 8            /* lower case letter    */
N#define __ARM_CT_U 16           /* upper case letter    */
N#define __ARM_CT_N 32           /* (decimal) digit      */
N#define __ARM_CT_C 64           /* control chars        */
N#define __ARM_CT_X 128          /* A-F and a-f          */
N#define __ARM_CT_A (__ARM_CT_N+__ARM_CT_X)    /* alphabetic           */
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S
Sextern int (isalnum)(int /*c*/);
Sextern int (isalpha)(int /*c*/);
Sextern int (isblank)(int /*c*/);
Sextern int (iscntrl)(int /*c*/);
Sextern int (isdigit)(int /*c*/);
Sextern int (isgraph)(int /*c*/);
Sextern int (islower)(int /*c*/);
Sextern int (isprint)(int /*c*/);
Sextern int (ispunct)(int /*c*/);
Sextern int (isspace)(int /*c*/);
Sextern int (isupper)(int /*c*/);
Sextern int (isxdigit)(int /*c*/);
S
S/* Mandatory character attribute arrays indexed from 0 to 256 */
Sextern unsigned char const __aeabi_ctype_table_C[257];  /* "C" locale */
Sextern unsigned char const __aeabi_ctype_table_[257];   /* default locale */
S         /* The default locale might be the C locale */
S/* Optional character attribute arrays indexed from 0 to 256.        */
S/* These do not have to be provided by every execution environment   */
S/* but, if provided, shall be provided with these names and meaning. */
Sextern unsigned char const __aeabi_ctype_table_ISO8859_1[257];
Sextern unsigned char const __aeabi_ctype_table_SJIS[257];
Sextern unsigned char const __aeabi_ctype_table_BIG5[257];
Sextern unsigned char const __aeabi_ctype_table_UTF8[257];
S#ifdef _AEABI_LC_CTYPE
S# define _AEABI_CTYPE_TABLE(_X) __aeabi_ctype_table_ ## _X
S# define _AEABI_CTYPE(_X) _AEABI_CTYPE_TABLE(_X)
S# define __aeabi_ctype_table _AEABI_CTYPE(_AEABI_LC_CTYPE)
S#else
S# define __aeabi_ctype_table __aeabi_ctype_table_
S#endif
S
S#define isspace(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_S)
S#define isalpha(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_A)
S#define isalnum(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 30) /* test for _ABI_A and _ABI_X */
S#define isprint(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 28) /* test for _ABI_A, _ABI_X, _ABI_P and _ABI_B */
S#define isupper(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_U)
S#define islower(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_L)
S#define isxdigit(x) ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_X)
S#define isgraph(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 29) /* test for _ABI_A, _ABI_X and _ABI_P */
S#define iscntrl(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_C)
S#define ispunct(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_P)
S#define isdigit(c)  (((unsigned)(c) - '0') < 10)
S
N#else /* __AEABI_PORTABILITY_LEVEL */
N
Nextern _ARMABI_PURE unsigned char **__rt_ctype_table(void);
Xextern __declspec(__nothrow) __attribute__((const)) unsigned char **__rt_ctype_table(void);
N
N#define __arm_ctype (*__CLIBNS __rt_ctype_table())
N
N#ifdef __cplusplus
S    inline int isalnum(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N)); }
N#else
N    #define isalnum(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N))
N    extern int (isalnum)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic or numeric */
N
N#ifdef __cplusplus
S    inline int isalpha(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X)); }
N#else
N    #define isalpha(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X))
N    extern int (isalpha)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic */
N
N#ifdef __cplusplus
S    inline int iscntrl(int __c) { return (__arm_ctype[__c] & __ARM_CT_C); }
N#else
N    #define iscntrl(c) (__arm_ctype[c] & __ARM_CT_C)
N    extern int (iscntrl)(int /*c*/);
N#endif
N    /* non-0 iff c is a control character - in the "C" locale */
N    /*       this means (c < ' ') || (c > '~')                */
N
N/* isdigit must test for the presence of _only_ __ARM_CT_N, not just __ARM_CT_N at all. */
N#ifdef __cplusplus
S    inline int isdigit(int __c) { return (__arm_ctype[__c] == __ARM_CT_N); }
N#else
N    #define isdigit(c) (__arm_ctype[c] == __ARM_CT_N)
N    extern int (isdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a decimal digit */
N
N    extern int (isblank)(int /*c*/);
N    /* non-0 iff c is ' ', '\t' or some other locale-specific, */
N    /* word-separating character (there are no others in "C"   */
N    /* locale) */
N
N#ifdef __cplusplus
S    inline int isgraph(int __c) {return(__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P));}
N#else
N    #define isgraph(c) (__arm_ctype[c]&(__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P))
N    extern int (isgraph)(int /*c*/);
N#endif
N    /* non-0 iff c is any printing character other than ' ' */
N
N#ifdef __cplusplus
S    inline int islower(int __c) { return (__arm_ctype[__c] & __ARM_CT_L); }
N#else
N    #define islower(c) (__arm_ctype[c] & __ARM_CT_L)
N    extern int (islower)(int /*c*/);
N#endif
N    /* non-0 iff c is a lower-case letter */
N
N#ifdef __cplusplus
S    inline int isprint(int __c) { return (__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B)); }
N#else
N    #define isprint(c) (__arm_ctype[c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B))
N    extern int (isprint)(int /*c*/);
N#endif
N    /* non-0 iff c is a printing character - in the "C" locale */
N    /*       this means 0x20 (space) -> 0x7E (tilde)           */
N
N#ifdef __cplusplus
S    inline int ispunct(int __c) { return (__arm_ctype[__c] & __ARM_CT_P); }
N#else
N    #define ispunct(c) (__arm_ctype[c] & __ARM_CT_P)
N    extern int (ispunct)(int /*c*/);
N#endif
N    /* non-0 iff c is a non-space, non-alpha-numeric, printing character */
N
N#ifdef __cplusplus
S    inline int isspace(int __c) { return (__arm_ctype[__c] & __ARM_CT_S); }
N#else
N    #define isspace(c) (__arm_ctype[c] & __ARM_CT_S)
N    extern int (isspace)(int /*c*/);
N#endif
N    /* non-0 iff c is a white-space char: ' ', '\f', '\n', '\r', '\t', '\v'. */
N
N#ifdef __cplusplus
S    inline int isupper(int __c) { return (__arm_ctype[__c] & __ARM_CT_U); }
N#else
N    #define isupper(c) (__arm_ctype[c] & __ARM_CT_U)
N    extern int (isupper)(int /*c*/);
N#endif
N    /* non-0 iff c is an upper-case letter */
N
N/* isxdigit must test for the presence of __ARM_CT_N or __ARM_CT_X but not both. */
N/* This helper function avoids needing to evaluate c twice. */
N
N_ARMABI_INLINE_DEF int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
X__inline int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
N#ifdef __cplusplus
S    inline int isxdigit(int __c){return __isxdigit_helper(__arm_ctype[__c]) & __ARM_CT_X;}
N#else
N    #define isxdigit(c) (__isxdigit_helper(__arm_ctype[c]) & __ARM_CT_X)
N    extern int (isxdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a digit, in 'a'..'f', or in 'A'..'F' */
N
N#endif /* __AEABI_PORTABILITY_LEVEL */
N
Nextern int tolower(int /*c*/);
N    /* if c is an upper-case letter then return the corresponding */
N    /* lower-case letter, otherwise return c.                     */
N
Nextern int toupper(int /*c*/);
N    /* if c is an lower-case letter then return the corresponding */
N    /* upper-case letter, otherwise return c.                     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __CTYPE_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __CTYPE_NO_EXPORTS
S      using ::std::isalnum;
S      using ::std::isalpha;
S      using ::std::iscntrl;
S      using ::std::isdigit;
S      using ::std::isblank;
S      using ::std::isgraph;
S      using ::std::islower;
S      using ::std::isprint;
S      using ::std::ispunct;
S      using ::std::isspace;
S      using ::std::isupper;
S      using ::std::isxdigit;
S      using ::std::tolower;
S      using ::std::toupper;
S    #endif /* __CTYPE_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of ctype.h */
N
L 42 "..\..\Middleware\ut_manager\Cunit\Sources\Basic\Basic.c" 2
N#include <assert.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\assert.h" 1
N/* assert.h: ANSI 'C' (X3J11 Oct 88) library header section 4.2 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N/*
N * The assert macro puts diagnostics into programs. When it is executed,
N * if its argument expression is false, it writes information about the
N * call that failed (including the text of the argument, the name of the
N * source file, and the source line number - the latter are respectively
N * the values of the preprocessing macros __FILE__ and __LINE__) on the
N * standard error stream. It then calls the abort function.
N * If its argument expression is true, the assert macro returns no value.
N */
N
N/*
N * Note that <assert.h> may be included more that once in a program with
N * different setting of NDEBUG. Hence the slightly unusual first-time
N * only flag.
N */
N
N#ifndef __assert_h
N#   define __assert_h
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define __ARMCLIB_VERSION 5060019
N#   ifndef __ARM_PROMISE
N#      define __ARM_PROMISE __promise
N#   endif
N#   undef __CLIBNS
N#   ifdef __cplusplus
S        namespace std {
S#           define __CLIBNS ::std::
S            extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N    extern _ARMABI_NORETURN void abort(void);
X    extern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N    extern _ARMABI_NORETURN void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
X    extern __declspec(__nothrow) __declspec(__noreturn) void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
N#   ifdef __cplusplus
S            }  /* extern "C" */
S        }  /* namespace std */
N#   endif
N#else
S#   undef assert
S#   undef __promise
N#endif
N
N#ifdef NDEBUG
N#   define assert(ignore) ((void)0)
N#   define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#else
S#   if defined __DO_NOT_LINK_PROMISE_WITH_ASSERT
S#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort())
S#      elif defined __STDC__
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__))
S#      else
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert("e", __FILE__, __LINE__))
S#      endif
S#      define __promise(e) ((__ARM_PROMISE)((e)?1:0))
S#   else
S#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#undef __promise
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort(), (__ARM_PROMISE)((e)?1:0))
S#      else
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__), (__ARM_PROMISE)((e)?1:0))
S#      endif
S#      define __promise(e) assert(e)
S#   endif
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N/* end of assert.h */
N
L 43 "..\..\Middleware\ut_manager\Cunit\Sources\Basic\Basic.c" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 44 "..\..\Middleware\ut_manager\Cunit\Sources\Basic\Basic.c" 2
N
N#include "CUnit.h"
L 1 "..\..\Middleware\ut_manager\Cunit\Headers\CUnit.h" 1
N/*
N *  CUnit - A Unit testing framework library for C.
N *  Copyright (C) 2001       Anil Kumar
N *  Copyright (C) 2004-2006  Anil Kumar, Jerry St.Clair
N *
N *  This library is free software; you can redistribute it and/or
N *  modify it under the terms of the GNU Library General Public
N *  License as published by the Free Software Foundation; either
N *  version 2 of the License, or (at your option) any later version.
N *
N *  This library is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
N *  Library General Public License for more details.
N *
N *  You should have received a copy of the GNU Library General Public
N *  License along with this library; if not, write to the Free Software
N *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
N */
N
N/*
N *  ASSERT Macro definitions and general CUnit configuration definitions.
N *
N *  09/Aug/2001   ASSERT definitions. (AK)
N *
N *  12/Mar/2003   New Assert definitions. (AK)
N *
N *  27/Jul/2003   Modified ASSERT_XXX Macro definitions. (AK)
N *
N *  15-Jul-2004   New interface, changed action on assert failure to not
N *                return, provided _FATAL versions of assertions to return
N *                from test function on failure. (JDS)
N *
N *  01-Sep-2004   Modified assertions for setjmp/longjmp mechanism of 
N *                aborting test runs, added CU_FAIL and CU_PASS macros. (JDS)
N *
N *  07-May-2005   Added CU_ prefix to remaining CUnit defines (BOOL, TRUE, 
N *                FALSE, MAX_...).  Added CU_UNREFERENCED_PARAMETER() define. (JDS)
N */
N
N/** @file
N * Basic CUnit include file for user and system code.
N * Defines macros for assertions for use in user test cases.
N * Basic system macro definitions also appear here.
N */
N/** @addtogroup Framework
N * @{
N */
N
N#ifndef CUNIT_CUNIT_H_SEEN
N#define CUNIT_CUNIT_H_SEEN
N
N#include <string.h>
N#include <math.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision$ Codemist 0.03
N * Checkin $Date$
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X  #if 0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
S    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
S#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199409L)
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF static inline
N#else
N#define _ARMABI_INLINE __inline
N#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    __inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
N    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
X    __inline float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
X__inline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
X__inline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
X__inline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
X#if (0L && !0L) || 0L
S/*
S * Functions new in C99.
S */
Sextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Sextern _ARMABI float exp2f(float /*x*/);
S_ARMDEFLD1(exp2);
Sextern _ARMABI double fdim(double /*x*/, double /*y*/);
Sextern _ARMABI float fdimf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fdim);
S#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
S#endif
S#ifdef __FP_FAST_FMAF
S#define FP_FAST_FMAF
S#endif
S#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
S#endif
Sextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Sextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
S    { return (long double)fma((double)__x, (double)__y, (double)__z); }
X_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
S#endif
Sextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmax);
Sextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmin);
Sextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Sextern _ARMABI float log2f(float /*x*/);
S_ARMDEFLD1(log2);
Sextern _ARMABI long lrint(double /*x*/);
Sextern _ARMABI long lrintf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
S    { return lrint((double)__x); }
X_ARMABI_INLINE _ARMABI long lrintl(long double __x)     { return lrint((double)__x); }
S#endif
Sextern _ARMABI __LONGLONG llrint(double /*x*/);
Sextern _ARMABI __LONGLONG llrintf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
S    { return llrint((double)__x); }
X_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x)     { return llrint((double)__x); }
S#endif
Sextern _ARMABI long lround(double /*x*/);
Sextern _ARMABI long lroundf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
S    { return lround((double)__x); }
X_ARMABI_INLINE _ARMABI long lroundl(long double __x)     { return lround((double)__x); }
S#endif
Sextern _ARMABI __LONGLONG llround(double /*x*/);
Sextern _ARMABI __LONGLONG llroundf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
S    { return llround((double)__x); }
X_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x)     { return llround((double)__x); }
S#endif
Sextern _ARMABI_PURE double nan(const char */*tagp*/);
Sextern _ARMABI_PURE float nanf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
S    { return (long double)nan(__t); }
X_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t)     { return (long double)nan(__t); }
S#endif
S#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
S#endif 
Sextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Sextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
S_ARMDEFLD1(nearbyint);
Sextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Sextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
S    { return (long double)remquo((double)__x, (double)__y, __q); }
X_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
S#endif
Sextern _ARMABI_FPEXCEPT double round(double /*x*/);
Sextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
S_ARMDEFLD1(round);
Sextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Sextern _ARMABI float tgammaf(float /*x*/);
S_ARMDEFLD1(tgamma);
Sextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Sextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
S_ARMDEFLD1(trunc);
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#if defined(__cplusplus) && ((!defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)) || defined(__ARMCOMPILER_LIBCXX))
X#if 0L && ((!0L || 0L) || 0L)
S  extern "C++" {
S    inline int (fpclassify)(double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(double __x) { return isfinite(__x); }
S    inline bool (isgreater)(double __x, double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(double __x, double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(double __x) { return isinf(__x); }
S    inline bool (isless)(double __x, double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(double __x, double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(double __x, double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(double __x) { return isnan(__x); }
S    inline bool (isnormal)(double __x) { return isnormal(__x); }
S    inline bool (isunordered)(double __x, double __y) { return isunordered(__x, __y); }
S
S  }
N#endif
N
N#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
X#if 0L && !0L
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S#endif
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S    inline int (fpclassify)(float __x) { return fpclassify(__x); }
S    inline bool (isfinite)(float __x) { return isfinite(__x); }
S    inline bool (isgreater)(float __x, float __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(float __x, float __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(float __x) { return isinf(__x); }
S    inline bool (isless)(float __x, float __y) { return isless(__x, __y); }
S    inline bool (islessequal)(float __x, float __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(float __x, float __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(float __x) { return isnan(__x); }
S    inline bool (isnormal)(float __x) { return isnormal(__x); }
S    inline bool (isunordered)(float __x, float __y) { return isunordered(__x, __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S    inline int (fpclassify)(long double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(long double __x) { return isfinite(__x); }
S    inline bool (isgreater)(long double __x, long double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(long double __x, long double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(long double __x) { return isinf(__x); }
S    inline bool (isless)(long double __x, long double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(long double __x, long double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(long double __x, long double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(long double __x) { return isnan(__x); }
S    inline bool (isnormal)(long double __x) { return isnormal(__x); }
S    inline bool (isunordered)(long double __x, long double __y) { return isunordered(__x, __y); }
S#endif
S
S#undef fpclassify
S#undef isfinite
S#undef isgreater
S#undef isgreaterequal
S#undef isinf
S#undef isless
S#undef islessequal
S#undef islessgreater
S#undef isnan
S#undef isnormal
S#undef isunordered
S
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    #ifndef __ARMCOMPILER_LIBCXX
S      using ::std::abs;
S    #endif
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S      /* New in C99. */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
S
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      using ::std::fpclassify;
S      using ::std::isfinite;
S      using ::std::isgreater;
S      using ::std::isgreaterequal;
S      using ::std::isinf;
S      using ::std::isless;
S      using ::std::islessequal;
S      using ::std::islessgreater;
S      using ::std::isnan;
S      using ::std::isnormal;
S      using ::std::isunordered;
S    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 55 "..\..\Middleware\ut_manager\Cunit\Headers\CUnit.h" 2
N
N/** CUnit version number. */
N#define CU_VERSION "@VERSION@-@RELEASE@"
N
N/*  Max string lengths for names (includes terminating NULL. */
N/** Maximum length of a test name string. */
N#define CU_MAX_TEST_NAME_LENGTH 256
N/** Maximim length of a suite name string. */
N#define CU_MAX_SUITE_NAME_LENGTH 256
N
N/* Global type Definitions to be used for boolean operators. */
N#ifndef CU_BOOL
N  /** Boolean type for CUnit use. */
N  #define CU_BOOL int
N#endif
N
N#ifndef CU_TRUE
N  /** Boolean TRUE for CUnit use. */
N  #define CU_TRUE 1
N#endif
N
N#ifndef CU_FALSE
N  /** Boolean FALSE for CUnit use. */
N  #define CU_FALSE 0
N#endif
N
N#ifndef CU_UNREFERENCED_PARAMETER
N  /** Consistent approach to referencing unused parameters. */
N  #define CU_UNREFERENCED_PARAMETER(x) (void)x
N#endif
N
N#ifndef CU_MAX
N#  define CU_MAX(a,b) (((a) >= (b)) ? (a) : (b))
N#endif
N
N#ifndef CU_MIN
N#  define CU_MIN(a,b) (((a) >= (b)) ? (b) : (a))
N#endif
N
N#if defined(WIN32) || defined(_WIN32) || defined(__WIN32) || defined(__WIN32__)
X#if 0L || 0L || 0L || 0L
S#  ifdef CU_DLL
S#    ifdef CU_BUILD_DLL
S#      define CU_EXPORT __declspec(dllexport)
S#    else
S#      define CU_EXPORT __declspec(dllimport)
S#    endif
S#  else
S#    define CU_EXPORT
S#  endif
S#  ifdef _MSC_VER
S#    define snprintf _snprintf
S#  endif
N#else
N#  define CU_EXPORT
N#endif  /* WIN32 */
N
N#include "CUError.h"
L 1 "..\..\Middleware\ut_manager\Cunit\Headers\CUError.h" 1
N/*
N *  CUnit - A Unit testing framework library for C.
N *  Copyright (C) 2001       Anil Kumar
N *  Copyright (C) 2004-2006  Anil Kumar, Jerry St.Clair
N *
N *  This library is free software; you can redistribute it and/or
N *  modify it under the terms of the GNU Library General Public
N *  License as published by the Free Software Foundation; either
N *  version 2 of the License, or (at your option) any later version.
N *
N *  This library is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
N *  Library General Public License for more details.
N *
N *  You should have received a copy of the GNU Library General Public
N *  License along with this library; if not, write to the Free Software
N *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
N */
N
N/*
N *  Contains CUnit error codes which can be used externally.
N *
N *  Aug 2001      Initial implementation.  (AK)
N *
N *  02/Oct/2001   Added proper Eror Codes. (AK)
N *
N *  13-Oct-2001   Added Error Codes for Duplicate TestGroup and Test. (AK)
N *
N *  03-Aug-2004   Converted error code macros to an enum, doxygen comments, moved
N *                error handing code here, changed file name from Errno.h, added
N *                error codes for file open errors, added error action selection. (JDS)
N *
N *  05-Sep-2004   Added internal test interface. (JDS)
N */
N
N/** @file
N *  Error handling functions (user interface).
N *  CUnit uses a simple (and conventional) error handling strategy.
N *  Functions that can generate errors set (and usually return) an
N *  error code to indicate the run status.  The error code can be
N *  inspected using the CU_get_error() function.  A descriptive
N *  error message can be retrieved using CU_get_error_msg().
N */
N/** @addtogroup Framework
N * @{
N */
N
N#ifndef CUNIT_CUERROR_H_SEEN
N#define CUNIT_CUERROR_H_SEEN
N
N#include <errno.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\errno.h" 1
N/* errno.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.3 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 1 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __errno_h
N#define __errno_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N
N  #ifndef __ERRNO_DECLS
N  #define __ERRNO_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
Nextern _ARMABI_PURE volatile int *__aeabi_errno_addr(void);
Xextern __declspec(__nothrow) __attribute__((const)) volatile int *__aeabi_errno_addr(void);
N
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __ERRNO_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __ERRNO_NO_EXPORTS
S      using ::std::__aeabi_errno_addr;
S    #endif /* __ERRNO_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#define errno (*__CLIBNS __aeabi_errno_addr())
N/*
N * expands to a modifiable lvalue that has type volatile int, the value of
N * which is set to a positive error code by several library functions. It is
N * initialised to zero at program startup, but is never set to zero by any
N * library function. The value of errno may be set to nonzero by a library
N * function call whether or not there is an error, provided the use of errno
N * is not documented in the description of the function in the Standard.
N */
N
N
N/*
N * Error numbers defined in the C standard need the ABI portability
N * mechanism.
N */
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N/* The ABI-defined signal numbers (EDOM, ERANGE and EILSEQ) are
N * defined differently depending on ABI conformance level. */
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
Sextern const int __aeabi_EDOM;
Sextern const int __aeabi_ERANGE;
Sextern const int __aeabi_EILSEQ;
S#define EDOM (__aeabi_EDOM)
S#define ERANGE (__aeabi_ERANGE)
S#define EILSEQ (__aeabi_EILSEQ)
N#else
N
N#define EDOM    1
N/*
N * If a mathematical function suffers a domain error (an input
N * argument is outside the domain over which the mathematical
N * function is defined, e.g. log of a negative number) the integer
N * expression errno acquires the value of the macro EDOM.
N *
N * EDOM is also returned by ftell, fgetpos and fsetpos when they
N * fail.
N */
N
N#define ERANGE 2
N/*
N * If a mathematical function suffers a range error (the result of
N * the function is too large or too small to be accurately
N * represented in the output floating-point format), the integer
N * expression errno acquires the value of the macro ERANGE.
N *
N * ERANGE is used by functions in math.h and complex.h, and also by
N * the strto* and wcsto* family of decimal-to-binary conversion
N * functions (both floating and integer) and by floating-point
N * conversions in scanf.
N */
N
N#define EILSEQ  4
N/*
N * EILSEQ is generated by the restartable multi-byte character
N * processing routines to indicate an encoding error: that is, it is
N * generated by mbrtowc, wcrtomb, mbsrtowcs and wcsrtombs, but not
N * by mbtowc, wctomb, mbstowcs or wcsrtombs.
N *
N * It is also generated by the wide-character stdio functions:
N * fputwc, putwc, putwchar, fputws, fgetwc, getwc, getwchar, fgetws.
N */
N
N#endif /* end of conditional definition of ABI-defined signals */
N
N#define ESIGNUM 3
N/*
N * ESIGNUM is generated by signal() if the user attempts to change
N * the handling of a nonexistent signal. ESIGNUM is not part of the
N * ANSI C standard.
N */
N
N#define EINVAL  5
N#define ENOMEM  6
N/*
N * EINVAL and ENOMEM can be generated by posix_memalign().
N */
N
N#endif
N
N/* end of errno.h */
N
L 53 "..\..\Middleware\ut_manager\Cunit\Headers\CUError.h" 2
N
N/*------------------------------------------------------------------------*/
N/** CUnit error codes.
N *  If codes are added or removed, be sure to make a change to the
N *  error messages in CUError.c/get_error_desc().
N *  @see CU_set_error()
N *  @see CU_get_error()
N *  @see CU_get_error_msg()
N */
Ntypedef enum {
N  /* basic errors */
N  CUE_SUCCESS           = 0,  /**< No error condition. */
N  CUE_NOMEMORY          = 1,  /**< Memory allocation failed. */
N
N  /* Test Registry Level Errors */
N  CUE_NOREGISTRY        = 10,  /**< Test registry not initialized. */
N  CUE_REGISTRY_EXISTS   = 11,  /**< Attempt to CU_set_registry() without CU_cleanup_registry(). */
N
N  /* Test Suite Level Errors */
N  CUE_NOSUITE           = 20,  /**< A required CU_pSuite pointer was NULL. */
N  CUE_NO_SUITENAME      = 21,  /**< Required CU_Suite name not provided. */
N  CUE_SINIT_FAILED      = 22,  /**< Suite initialization failed. */
N  CUE_SCLEAN_FAILED     = 23,  /**< Suite cleanup failed. */
N  CUE_DUP_SUITE         = 24,  /**< Duplicate suite name not allowed. */
N  CUE_SUITE_INACTIVE    = 25,  /**< Test run initiated for an inactive suite. */
N
N  /* Test Case Level Errors */
N  CUE_NOTEST            = 30,  /**< A required CU_pTest or CU_TestFunc pointer was NULL. */
N  CUE_NO_TESTNAME       = 31,  /**< Required CU_Test name not provided. */
N  CUE_DUP_TEST          = 32,  /**< Duplicate test case name not allowed. */
N  CUE_TEST_NOT_IN_SUITE = 33,  /**< Test not registered in specified suite. */
N  CUE_TEST_INACTIVE     = 34,  /**< Test run initiated for an inactive test. */
N
N  /* File handling errors */
N  CUE_FOPEN_FAILED      = 40,  /**< An error occurred opening a file. */
N  CUE_FCLOSE_FAILED     = 41,  /**< An error occurred closing a file. */
N  CUE_BAD_FILENAME      = 42,  /**< A bad filename was requested (NULL, empty, nonexistent, etc.). */
N  CUE_WRITE_ERROR       = 43   /**< An error occurred during a write to a file. */
N} CU_ErrorCode;
N
N/*------------------------------------------------------------------------*/
N/** CUnit error action codes.
N *  These are used to set the action desired when an error
N *  condition is detected in the CUnit framework.
N *  @see CU_set_error_action()
N *  @see CU_get_error_action()
N */
Ntypedef enum CU_ErrorAction {
N  CUEA_IGNORE,    /**< Runs should be continued when an error condition occurs (if possible). */
N  CUEA_FAIL,      /**< Runs should be stopped when an error condition occurs. */
N  CUEA_ABORT      /**< The application should exit() when an error conditions occurs. */
N} CU_ErrorAction;
N
N/* Error handling & reporting functions. */
N
N#include "CUnit.h"
L 1 "..\..\Middleware\ut_manager\Cunit\Headers\CUnit.h" 1
N/*
N *  CUnit - A Unit testing framework library for C.
N *  Copyright (C) 2001       Anil Kumar
N *  Copyright (C) 2004-2006  Anil Kumar, Jerry St.Clair
N *
N *  This library is free software; you can redistribute it and/or
N *  modify it under the terms of the GNU Library General Public
N *  License as published by the Free Software Foundation; either
N *  version 2 of the License, or (at your option) any later version.
N *
N *  This library is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
N *  Library General Public License for more details.
N *
N *  You should have received a copy of the GNU Library General Public
N *  License along with this library; if not, write to the Free Software
N *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
N */
N
N/*
N *  ASSERT Macro definitions and general CUnit configuration definitions.
N *
N *  09/Aug/2001   ASSERT definitions. (AK)
N *
N *  12/Mar/2003   New Assert definitions. (AK)
N *
N *  27/Jul/2003   Modified ASSERT_XXX Macro definitions. (AK)
N *
N *  15-Jul-2004   New interface, changed action on assert failure to not
N *                return, provided _FATAL versions of assertions to return
N *                from test function on failure. (JDS)
N *
N *  01-Sep-2004   Modified assertions for setjmp/longjmp mechanism of 
N *                aborting test runs, added CU_FAIL and CU_PASS macros. (JDS)
N *
N *  07-May-2005   Added CU_ prefix to remaining CUnit defines (BOOL, TRUE, 
N *                FALSE, MAX_...).  Added CU_UNREFERENCED_PARAMETER() define. (JDS)
N */
N
N/** @file
N * Basic CUnit include file for user and system code.
N * Defines macros for assertions for use in user test cases.
N * Basic system macro definitions also appear here.
N */
N/** @addtogroup Framework
N * @{
N */
N
N#ifndef CUNIT_CUNIT_H_SEEN
S#define CUNIT_CUNIT_H_SEEN
S
S#include <string.h>
S#include <math.h>
S
S/** CUnit version number. */
S#define CU_VERSION "@VERSION@-@RELEASE@"
S
S/*  Max string lengths for names (includes terminating NULL. */
S/** Maximum length of a test name string. */
S#define CU_MAX_TEST_NAME_LENGTH 256
S/** Maximim length of a suite name string. */
S#define CU_MAX_SUITE_NAME_LENGTH 256
S
S/* Global type Definitions to be used for boolean operators. */
S#ifndef CU_BOOL
S  /** Boolean type for CUnit use. */
S  #define CU_BOOL int
S#endif
S
S#ifndef CU_TRUE
S  /** Boolean TRUE for CUnit use. */
S  #define CU_TRUE 1
S#endif
S
S#ifndef CU_FALSE
S  /** Boolean FALSE for CUnit use. */
S  #define CU_FALSE 0
S#endif
S
S#ifndef CU_UNREFERENCED_PARAMETER
S  /** Consistent approach to referencing unused parameters. */
S  #define CU_UNREFERENCED_PARAMETER(x) (void)x
S#endif
S
S#ifndef CU_MAX
S#  define CU_MAX(a,b) (((a) >= (b)) ? (a) : (b))
S#endif
S
S#ifndef CU_MIN
S#  define CU_MIN(a,b) (((a) >= (b)) ? (b) : (a))
S#endif
S
S#if defined(WIN32) || defined(_WIN32) || defined(__WIN32) || defined(__WIN32__)
S#  ifdef CU_DLL
S#    ifdef CU_BUILD_DLL
S#      define CU_EXPORT __declspec(dllexport)
S#    else
S#      define CU_EXPORT __declspec(dllimport)
S#    endif
S#  else
S#    define CU_EXPORT
S#  endif
S#  ifdef _MSC_VER
S#    define snprintf _snprintf
S#  endif
S#else
S#  define CU_EXPORT
S#endif  /* WIN32 */
S
S#include "CUError.h"
S#include "TestDB.h"   /* not needed here - included for user convenience */
S#include "TestRun.h"  /* not needed here - include (after BOOL define) for user convenience */
S
S/** Record a pass condition without performing a logical test. */
S#define CU_PASS(msg) \
S  { CU_assertImplementation(CU_TRUE, __LINE__, ("CU_PASS(" #msg ")"), __FILE__, "", CU_FALSE); }
X#define CU_PASS(msg)   { CU_assertImplementation(CU_TRUE, __LINE__, ("CU_PASS(" #msg ")"), __FILE__, "", CU_FALSE); }
S
S/** Simple assertion.
S *  Reports failure with no other action.
S */
S#define CU_ASSERT(value) \
S  { CU_assertImplementation((value), __LINE__, #value, __FILE__, "", CU_FALSE); }
X#define CU_ASSERT(value)   { CU_assertImplementation((value), __LINE__, #value, __FILE__, "", CU_FALSE); }
S
S/** Simple assertion.
S *  Reports failure and causes test to abort.
S */
S#define CU_ASSERT_FATAL(value) \
S  { CU_assertImplementation((value), __LINE__, #value, __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_FATAL(value)   { CU_assertImplementation((value), __LINE__, #value, __FILE__, "", CU_TRUE); }
S
S/** Simple assertion.
S *  Reports failure with no other action.
S */
S#define CU_TEST(value) \
S  { CU_assertImplementation((value), __LINE__, #value, __FILE__, "", CU_FALSE); }
X#define CU_TEST(value)   { CU_assertImplementation((value), __LINE__, #value, __FILE__, "", CU_FALSE); }
S
S/** Simple assertion.
S *  Reports failure and causes test to abort.
S */
S#define CU_TEST_FATAL(value) \
S  { CU_assertImplementation((value), __LINE__, #value, __FILE__, "", CU_TRUE); }
X#define CU_TEST_FATAL(value)   { CU_assertImplementation((value), __LINE__, #value, __FILE__, "", CU_TRUE); }
S
S/** Record a failure without performing a logical test. */
S#define CU_FAIL(msg) \
S  { CU_assertImplementation(CU_FALSE, __LINE__, ("CU_FAIL(" #msg ")"), __FILE__, "", CU_FALSE); }
X#define CU_FAIL(msg)   { CU_assertImplementation(CU_FALSE, __LINE__, ("CU_FAIL(" #msg ")"), __FILE__, "", CU_FALSE); }
S
S/** Record a failure without performing a logical test, and abort test. */
S#define CU_FAIL_FATAL(msg) \
S  { CU_assertImplementation(CU_FALSE, __LINE__, ("CU_FAIL_FATAL(" #msg ")"), __FILE__, "", CU_TRUE); }
X#define CU_FAIL_FATAL(msg)   { CU_assertImplementation(CU_FALSE, __LINE__, ("CU_FAIL_FATAL(" #msg ")"), __FILE__, "", CU_TRUE); }
S
S/** Asserts that value is CU_TRUE.
S *  Reports failure with no other action.
S */
S#define CU_ASSERT_TRUE(value) \
S  { CU_assertImplementation((value), __LINE__, ("CU_ASSERT_TRUE(" #value ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_TRUE(value)   { CU_assertImplementation((value), __LINE__, ("CU_ASSERT_TRUE(" #value ")"), __FILE__, "", CU_FALSE); }
S
S/** Asserts that value is CU_TRUE.
S *  Reports failure and causes test to abort.
S */
S#define CU_ASSERT_TRUE_FATAL(value) \
S  { CU_assertImplementation((value), __LINE__, ("CU_ASSERT_TRUE_FATAL(" #value ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_TRUE_FATAL(value)   { CU_assertImplementation((value), __LINE__, ("CU_ASSERT_TRUE_FATAL(" #value ")"), __FILE__, "", CU_TRUE); }
S
S/** Asserts that value is CU_FALSE.
S *  Reports failure with no other action.
S */
S#define CU_ASSERT_FALSE(value) \
S  { CU_assertImplementation(!(value), __LINE__, ("CU_ASSERT_FALSE(" #value ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_FALSE(value)   { CU_assertImplementation(!(value), __LINE__, ("CU_ASSERT_FALSE(" #value ")"), __FILE__, "", CU_FALSE); }
S
S/** Asserts that value is CU_FALSE.
S *  Reports failure and causes test to abort.
S */
S#define CU_ASSERT_FALSE_FATAL(value) \
S  { CU_assertImplementation(!(value), __LINE__, ("CU_ASSERT_FALSE_FATAL(" #value ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_FALSE_FATAL(value)   { CU_assertImplementation(!(value), __LINE__, ("CU_ASSERT_FALSE_FATAL(" #value ")"), __FILE__, "", CU_TRUE); }
S
S/** Asserts that actual == expected.
S *  Reports failure with no other action.
S */
S#define CU_ASSERT_EQUAL(actual, expected) \
S  { CU_assertImplementation(((actual) == (expected)), __LINE__, ("CU_ASSERT_EQUAL(" #actual "," #expected ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_EQUAL(actual, expected)   { CU_assertImplementation(((actual) == (expected)), __LINE__, ("CU_ASSERT_EQUAL(" #actual "," #expected ")"), __FILE__, "", CU_FALSE); }
S
S/** Asserts that actual == expected.
S *  Reports failure and causes test to abort.
S */
S#define CU_ASSERT_EQUAL_FATAL(actual, expected) \
S  { CU_assertImplementation(((actual) == (expected)), __LINE__, ("CU_ASSERT_EQUAL_FATAL(" #actual "," #expected ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_EQUAL_FATAL(actual, expected)   { CU_assertImplementation(((actual) == (expected)), __LINE__, ("CU_ASSERT_EQUAL_FATAL(" #actual "," #expected ")"), __FILE__, "", CU_TRUE); }
S
S/** Asserts that actual != expected.
S *  Reports failure with no other action.
S */
S#define CU_ASSERT_NOT_EQUAL(actual, expected) \
S  { CU_assertImplementation(((actual) != (expected)), __LINE__, ("CU_ASSERT_NOT_EQUAL(" #actual "," #expected ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_NOT_EQUAL(actual, expected)   { CU_assertImplementation(((actual) != (expected)), __LINE__, ("CU_ASSERT_NOT_EQUAL(" #actual "," #expected ")"), __FILE__, "", CU_FALSE); }
S
S/** Asserts that actual != expected.
S *  Reports failure and causes test to abort.
S */
S#define CU_ASSERT_NOT_EQUAL_FATAL(actual, expected) \
S  { CU_assertImplementation(((actual) != (expected)), __LINE__, ("CU_ASSERT_NOT_EQUAL_FATAL(" #actual "," #expected ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_NOT_EQUAL_FATAL(actual, expected)   { CU_assertImplementation(((actual) != (expected)), __LINE__, ("CU_ASSERT_NOT_EQUAL_FATAL(" #actual "," #expected ")"), __FILE__, "", CU_TRUE); }
S
S/** Asserts that pointers actual == expected.
S *  Reports failure with no other action.
S */
S#define CU_ASSERT_PTR_EQUAL(actual, expected) \
S  { CU_assertImplementation(((const void*)(actual) == (const void*)(expected)), __LINE__, ("CU_ASSERT_PTR_EQUAL(" #actual "," #expected ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_PTR_EQUAL(actual, expected)   { CU_assertImplementation(((const void*)(actual) == (const void*)(expected)), __LINE__, ("CU_ASSERT_PTR_EQUAL(" #actual "," #expected ")"), __FILE__, "", CU_FALSE); }
S
S/** Asserts that pointers actual == expected.
S * Reports failure and causes test to abort.
S */
S#define CU_ASSERT_PTR_EQUAL_FATAL(actual, expected) \
S  { CU_assertImplementation(((const void*)(actual) == (const void*)(expected)), __LINE__, ("CU_ASSERT_PTR_EQUAL_FATAL(" #actual "," #expected ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_PTR_EQUAL_FATAL(actual, expected)   { CU_assertImplementation(((const void*)(actual) == (const void*)(expected)), __LINE__, ("CU_ASSERT_PTR_EQUAL_FATAL(" #actual "," #expected ")"), __FILE__, "", CU_TRUE); }
S
S/** Asserts that pointers actual != expected.
S *  Reports failure with no other action.
S */
S#define CU_ASSERT_PTR_NOT_EQUAL(actual, expected) \
S  { CU_assertImplementation(((const void*)(actual) != (const void*)(expected)), __LINE__, ("CU_ASSERT_PTR_NOT_EQUAL(" #actual "," #expected ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_PTR_NOT_EQUAL(actual, expected)   { CU_assertImplementation(((const void*)(actual) != (const void*)(expected)), __LINE__, ("CU_ASSERT_PTR_NOT_EQUAL(" #actual "," #expected ")"), __FILE__, "", CU_FALSE); }
S
S/** Asserts that pointers actual != expected.
S *  Reports failure and causes test to abort.
S */
S#define CU_ASSERT_PTR_NOT_EQUAL_FATAL(actual, expected) \
S  { CU_assertImplementation(((const void*)(actual) != (const void*)(expected)), __LINE__, ("CU_ASSERT_PTR_NOT_EQUAL_FATAL(" #actual "," #expected ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_PTR_NOT_EQUAL_FATAL(actual, expected)   { CU_assertImplementation(((const void*)(actual) != (const void*)(expected)), __LINE__, ("CU_ASSERT_PTR_NOT_EQUAL_FATAL(" #actual "," #expected ")"), __FILE__, "", CU_TRUE); }
S
S/** Asserts that pointer value is NULL.
S *  Reports failure with no other action.
S */
S#define CU_ASSERT_PTR_NULL(value) \
S  { CU_assertImplementation((NULL == (const void*)(value)), __LINE__, ("CU_ASSERT_PTR_NULL(" #value")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_PTR_NULL(value)   { CU_assertImplementation((NULL == (const void*)(value)), __LINE__, ("CU_ASSERT_PTR_NULL(" #value")"), __FILE__, "", CU_FALSE); }
S
S/** Asserts that pointer value is NULL.
S *  Reports failure and causes test to abort.
S */
S#define CU_ASSERT_PTR_NULL_FATAL(value) \
S  { CU_assertImplementation((NULL == (const void*)(value)), __LINE__, ("CU_ASSERT_PTR_NULL_FATAL(" #value")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_PTR_NULL_FATAL(value)   { CU_assertImplementation((NULL == (const void*)(value)), __LINE__, ("CU_ASSERT_PTR_NULL_FATAL(" #value")"), __FILE__, "", CU_TRUE); }
S
S/** Asserts that pointer value is not NULL.
S *  Reports failure with no other action.
S */
S#define CU_ASSERT_PTR_NOT_NULL(value) \
S  { CU_assertImplementation((NULL != (const void*)(value)), __LINE__, ("CU_ASSERT_PTR_NOT_NULL(" #value")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_PTR_NOT_NULL(value)   { CU_assertImplementation((NULL != (const void*)(value)), __LINE__, ("CU_ASSERT_PTR_NOT_NULL(" #value")"), __FILE__, "", CU_FALSE); }
S
S/** Asserts that pointer value is not NULL.
S *  Reports failure and causes test to abort.
S */
S#define CU_ASSERT_PTR_NOT_NULL_FATAL(value) \
S  { CU_assertImplementation((NULL != (const void*)(value)), __LINE__, ("CU_ASSERT_PTR_NOT_NULL_FATAL(" #value")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_PTR_NOT_NULL_FATAL(value)   { CU_assertImplementation((NULL != (const void*)(value)), __LINE__, ("CU_ASSERT_PTR_NOT_NULL_FATAL(" #value")"), __FILE__, "", CU_TRUE); }
S
S/** Asserts that string actual == expected.
S *  Reports failure with no other action.
S */
S#define CU_ASSERT_STRING_EQUAL(actual, expected) \
S  { CU_assertImplementation(!(strcmp((const char*)(actual), (const char*)(expected))), __LINE__, ("CU_ASSERT_STRING_EQUAL(" #actual ","  #expected ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_STRING_EQUAL(actual, expected)   { CU_assertImplementation(!(strcmp((const char*)(actual), (const char*)(expected))), __LINE__, ("CU_ASSERT_STRING_EQUAL(" #actual ","  #expected ")"), __FILE__, "", CU_FALSE); }
S
S/** Asserts that string actual == expected.
S *  Reports failure and causes test to abort.
S */
S#define CU_ASSERT_STRING_EQUAL_FATAL(actual, expected) \
S  { CU_assertImplementation(!(strcmp((const char*)(actual), (const char*)(expected))), __LINE__, ("CU_ASSERT_STRING_EQUAL_FATAL(" #actual ","  #expected ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_STRING_EQUAL_FATAL(actual, expected)   { CU_assertImplementation(!(strcmp((const char*)(actual), (const char*)(expected))), __LINE__, ("CU_ASSERT_STRING_EQUAL_FATAL(" #actual ","  #expected ")"), __FILE__, "", CU_TRUE); }
S
S/** Asserts that string actual != expected.
S *  Reports failure with no other action.
S */
S#define CU_ASSERT_STRING_NOT_EQUAL(actual, expected) \
S  { CU_assertImplementation((strcmp((const char*)(actual), (const char*)(expected))), __LINE__, ("CU_ASSERT_STRING_NOT_EQUAL(" #actual ","  #expected ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_STRING_NOT_EQUAL(actual, expected)   { CU_assertImplementation((strcmp((const char*)(actual), (const char*)(expected))), __LINE__, ("CU_ASSERT_STRING_NOT_EQUAL(" #actual ","  #expected ")"), __FILE__, "", CU_FALSE); }
S
S/** Asserts that string actual != expected.
S *  Reports failure and causes test to abort.
S */
S#define CU_ASSERT_STRING_NOT_EQUAL_FATAL(actual, expected) \
S  { CU_assertImplementation((strcmp((const char*)(actual), (const char*)(expected))), __LINE__, ("CU_ASSERT_STRING_NOT_EQUAL_FATAL(" #actual ","  #expected ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_STRING_NOT_EQUAL_FATAL(actual, expected)   { CU_assertImplementation((strcmp((const char*)(actual), (const char*)(expected))), __LINE__, ("CU_ASSERT_STRING_NOT_EQUAL_FATAL(" #actual ","  #expected ")"), __FILE__, "", CU_TRUE); }
S
S/** Asserts that string actual == expected with length specified.
S *  The comparison is limited to count characters.
S *  Reports failure with no other action.
S */
S#define CU_ASSERT_NSTRING_EQUAL(actual, expected, count) \
S  { CU_assertImplementation(!(strncmp((const char*)(actual), (const char*)(expected), (size_t)(count))), __LINE__, ("CU_ASSERT_NSTRING_EQUAL(" #actual ","  #expected "," #count ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_NSTRING_EQUAL(actual, expected, count)   { CU_assertImplementation(!(strncmp((const char*)(actual), (const char*)(expected), (size_t)(count))), __LINE__, ("CU_ASSERT_NSTRING_EQUAL(" #actual ","  #expected "," #count ")"), __FILE__, "", CU_FALSE); }
S
S/** Asserts that string actual == expected with length specified.
S *  The comparison is limited to count characters.
S *  Reports failure and causes test to abort.
S */
S#define CU_ASSERT_NSTRING_EQUAL_FATAL(actual, expected, count) \
S  { CU_assertImplementation(!(strncmp((const char*)(actual), (const char*)(expected), (size_t)(count))), __LINE__, ("CU_ASSERT_NSTRING_EQUAL_FATAL(" #actual ","  #expected "," #count ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_NSTRING_EQUAL_FATAL(actual, expected, count)   { CU_assertImplementation(!(strncmp((const char*)(actual), (const char*)(expected), (size_t)(count))), __LINE__, ("CU_ASSERT_NSTRING_EQUAL_FATAL(" #actual ","  #expected "," #count ")"), __FILE__, "", CU_TRUE); }
S
S/** Asserts that string actual != expected with length specified.
S *  The comparison is limited to count characters.
S *  Reports failure with no other action.
S */
S#define CU_ASSERT_NSTRING_NOT_EQUAL(actual, expected, count) \
S  { CU_assertImplementation((strncmp((const char*)(actual), (const char*)(expected), (size_t)(count))), __LINE__, ("CU_ASSERT_NSTRING_NOT_EQUAL(" #actual ","  #expected "," #count ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_NSTRING_NOT_EQUAL(actual, expected, count)   { CU_assertImplementation((strncmp((const char*)(actual), (const char*)(expected), (size_t)(count))), __LINE__, ("CU_ASSERT_NSTRING_NOT_EQUAL(" #actual ","  #expected "," #count ")"), __FILE__, "", CU_FALSE); }
S
S/** Asserts that string actual != expected with length specified.
S *  The comparison is limited to count characters.
S *  Reports failure and causes test to abort.
S */
S#define CU_ASSERT_NSTRING_NOT_EQUAL_FATAL(actual, expected, count) \
S  { CU_assertImplementation((strncmp((const char*)(actual), (const char*)(expected), (size_t)(count))), __LINE__, ("CU_ASSERT_NSTRING_NOT_EQUAL_FATAL(" #actual ","  #expected "," #count ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_NSTRING_NOT_EQUAL_FATAL(actual, expected, count)   { CU_assertImplementation((strncmp((const char*)(actual), (const char*)(expected), (size_t)(count))), __LINE__, ("CU_ASSERT_NSTRING_NOT_EQUAL_FATAL(" #actual ","  #expected "," #count ")"), __FILE__, "", CU_TRUE); }
S
S/** Asserts that double actual == expected within the specified tolerance.
S *  If actual is within granularity of expected, the assertion passes.
S *  Reports failure with no other action.
S */
S#define CU_ASSERT_DOUBLE_EQUAL(actual, expected, granularity) \
S  { CU_assertImplementation(((fabs((double)(actual) - (expected)) <= fabs((double)(granularity)))), __LINE__, ("CU_ASSERT_DOUBLE_EQUAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_DOUBLE_EQUAL(actual, expected, granularity)   { CU_assertImplementation(((fabs((double)(actual) - (expected)) <= fabs((double)(granularity)))), __LINE__, ("CU_ASSERT_DOUBLE_EQUAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", CU_FALSE); }
S
S/** Asserts that double actual == expected within the specified tolerance.
S *  If actual is within granularity of expected, the assertion passes.
S *  Reports failure and causes test to abort.
S */
S#define CU_ASSERT_DOUBLE_EQUAL_FATAL(actual, expected, granularity) \
S  { CU_assertImplementation(((fabs((double)(actual) - (expected)) <= fabs((double)(granularity)))), __LINE__, ("CU_ASSERT_DOUBLE_EQUAL_FATAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_DOUBLE_EQUAL_FATAL(actual, expected, granularity)   { CU_assertImplementation(((fabs((double)(actual) - (expected)) <= fabs((double)(granularity)))), __LINE__, ("CU_ASSERT_DOUBLE_EQUAL_FATAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", CU_TRUE); }
S
S/** Asserts that double actual != expected within the specified tolerance.
S *  If actual is within granularity of expected, the assertion fails.
S *  Reports failure with no other action.
S */
S#define CU_ASSERT_DOUBLE_NOT_EQUAL(actual, expected, granularity) \
S  { CU_assertImplementation(((fabs((double)(actual) - (expected)) > fabs((double)(granularity)))), __LINE__, ("CU_ASSERT_DOUBLE_NOT_EQUAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_DOUBLE_NOT_EQUAL(actual, expected, granularity)   { CU_assertImplementation(((fabs((double)(actual) - (expected)) > fabs((double)(granularity)))), __LINE__, ("CU_ASSERT_DOUBLE_NOT_EQUAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", CU_FALSE); }
S
S/** Asserts that double actual != expected within the specified tolerance.
S *  If actual is within granularity of expected, the assertion fails.
S *  Reports failure and causes test to abort.
S */
S#define CU_ASSERT_DOUBLE_NOT_EQUAL_FATAL(actual, expected, granularity) \
S  { CU_assertImplementation(((fabs((double)(actual) - (expected)) > fabs((double)(granularity)))), __LINE__, ("CU_ASSERT_DOUBLE_NOT_EQUAL_FATAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_DOUBLE_NOT_EQUAL_FATAL(actual, expected, granularity)   { CU_assertImplementation(((fabs((double)(actual) - (expected)) > fabs((double)(granularity)))), __LINE__, ("CU_ASSERT_DOUBLE_NOT_EQUAL_FATAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", CU_TRUE); }
S
S#ifdef USE_DEPRECATED_CUNIT_NAMES
S
S#ifndef BOOL
S  /** Deprecated (version 2.0-2). @deprecated Use CU_BOOL. */
S  #define BOOL int
S#endif
S
S#ifndef TRUE
S  /** Deprecated (version 2.0-2). @deprecated Use CU_TRUE. */
S  #define TRUE 1
S#endif
S
S#ifndef FALSE
S  /** Deprecated (version 2.0-2). @deprecated Use CU_FALSE. */
S  #define FALSE	0
S#endif
S
S/** Deprecated (version 2.0-2). @deprecated Use CU_MAX_TEST_NAME_LENGTH. */
S#define MAX_TEST_NAME_LENGTH	256
S/** Deprecated (version 2.0-2). @deprecated Use CU_MAX_SUITE_NAME_LENGTH. */
S#define MAX_SUITE_NAME_LENGTH	256
S
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_FATAL. */
S#define ASSERT(value) { if (FALSE == (int)(value)) { CU_assertImplementation((BOOL)value, __LINE__, #value, __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_TRUE_FATAL. */
S#define ASSERT_TRUE(value) { if (FALSE == (value)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_TRUE(" #value ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_FALSE_FATAL. */
S#define ASSERT_FALSE(value) { if (FALSE != (value)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_FALSE(" #value ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_EQUAL_FATAL. */
S#define ASSERT_EQUAL(actual, expected) { if ((actual) != (expected)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_EQUAL(" #actual "," #expected ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_NOT_EQUAL_FATAL. */
S#define ASSERT_NOT_EQUAL(actual, expected) { if ((void*)(actual) == (void*)(expected)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_NOT_EQUAL(" #actual "," #expected ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_PTR_EQUAL_FATAL. */
S#define ASSERT_PTR_EQUAL(actual, expected) { if ((void*)(actual) != (void*)(expected)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_PTR_EQUAL(" #actual "," #expected ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_PTR_NOT_EQUAL_FATAL. */
S#define ASSERT_PTR_NOT_EQUAL(actual, expected) { if ((void*)(actual) == (void*)(expected)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_PTR_NOT_EQUAL(" #actual "," #expected ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_PTR_NULL_FATAL. */
S#define ASSERT_PTR_NULL(value)  { if (NULL != (void*)(value)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_PTR_NULL(" #value")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_PTR_NOT_NULL_FATAL. */
S#define ASSERT_PTR_NOT_NULL(value) { if (NULL == (void*)(value)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_PTR_NOT_NULL(" #value")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_STRING_EQUAL_FATAL. */
S#define ASSERT_STRING_EQUAL(actual, expected) { if (strcmp((const char*)actual, (const char*)expected)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_STRING_EQUAL(" #actual ","  #expected ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_STRING_NOT_EQUAL_FATAL. */
S#define ASSERT_STRING_NOT_EQUAL(actual, expected) { if (!strcmp((const char*)actual, (const char*)expected)) { CU_assertImplementation(TRUE, __LINE__, ("ASSERT_STRING_NOT_EQUAL(" #actual ","  #expected ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_NSTRING_EQUAL_FATAL. */
S#define ASSERT_NSTRING_EQUAL(actual, expected, count) { if (strncmp((const char*)actual, (const char*)expected, (size_t)count)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_NSTRING_EQUAL(" #actual ","  #expected "," #count ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_NSTRING_NOT_EQUAL_FATAL. */
S#define ASSERT_NSTRING_NOT_EQUAL(actual, expected, count) { if (!strncmp((const char*)actual, (const char*)expected, (size_t)count)) { CU_assertImplementation(TRUE, __LINE__, ("ASSERT_NSTRING_NOT_EQUAL(" #actual ","  #expected "," #count ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_DOUBLE_EQUAL_FATAL. */
S#define ASSERT_DOUBLE_EQUAL(actual, expected, granularity) { if ((fabs((double)actual - expected) > fabs((double)granularity))) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_DOUBLE_EQUAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_DOUBLE_NOT_EQUAL_FATAL. */
S#define ASSERT_DOUBLE_NOT_EQUAL(actual, expected, granularity) { if ((fabs((double)actual - expected) <= fabs((double)granularity))) { CU_assertImplementation(TRUE, __LINE__, ("ASSERT_DOUBLE_NOT_EQUAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", FALSE); return; }}
S#endif  /* USE_DEPRECATED_CUNIT_NAMES */
S
N#endif  /*  CUNIT_CUNIT_H_SEEN  */
N
N/** @} */
L 109 "..\..\Middleware\ut_manager\Cunit\Headers\CUError.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
NCU_EXPORT CU_ErrorCode   CU_get_error(void);
X CU_ErrorCode   CU_get_error(void);
N/**<
N *  Retrieves the current CUnit framework error code.
N *  CUnit implementation functions set the error code to indicate the
N *  status of the most recent operation.  In general, the CUnit functions
N *  will clear the code to CUE_SUCCESS, then reset it to a specific error
N *  code if an exception condition is encountered.  Some functions
N *  return the code, others leave it to the user to inspect if desired.
N *
N *  @return The current error condition code.
N *  @see CU_get_error_msg()
N *  @see CU_ErrorCode
N */
N
NCU_EXPORT const char*    CU_get_error_msg(void);
X const char*    CU_get_error_msg(void);
N/**<
N *  Retrieves a message corresponding to the current framework error code.
N *  CUnit implementation functions set the error code to indicate the
N *  of the most recent operation.  In general, the CUnit functions will
N *  clear the code to CUE_SUCCESS, then reset it to a specific error
N *  code if an exception condition is encountered.  This function allows
N *  the user to retrieve a descriptive error message corresponding to the
N *  error code set by the last operation.
N *
N *  @return A message corresponding to the current error condition.
N *  @see CU_get_error()
N *  @see CU_ErrorCode
N */
N
NCU_EXPORT void           CU_set_error_action(CU_ErrorAction action);
X void           CU_set_error_action(CU_ErrorAction action);
N/**<
N *  Sets the action to take when a framework error condition occurs.
N *  This function should be used to specify the action to take
N *  when an error condition is encountered.  The default action is
N *  CUEA_IGNORE, which results in errors being ignored and test runs
N *  being continued (if possible).  A value of CUEA_FAIL causes test
N *  runs to stop as soon as an error condition occurs, while
N *  CU_ABORT causes the application to exit on any error.
N *
N *  @param action CU_ErrorAction indicating the new error action.
N *  @see CU_get_error_action()
N *  @see CU_set_error()
N *  @see CU_ErrorAction
N */
N
NCU_EXPORT CU_ErrorAction CU_get_error_action(void);
X CU_ErrorAction CU_get_error_action(void);
N/**<
N *  Retrieves the current framework error action code.
N *
N *  @return The current error action code.
N *  @see CU_set_error_action()
N *  @see CU_set_error()
N *  @see CU_ErrorAction
N */
N
N#ifdef CUNIT_BUILD_TESTS
Svoid test_cunit_CUError(void);
N#endif
N
N/* Internal function - users should not generally call this function */
NCU_EXPORT void CU_set_error(CU_ErrorCode error);
X void CU_set_error(CU_ErrorCode error);
N/**<
N *  Sets the CUnit framework error code.
N *  This function is used internally by CUnit implementation functions
N *  when an error condition occurs within the framework.  It should
N *  not generally be called by user code.  NOTE that if the current
N *  error action is CUEA_ABORT, then calling this function will
N *  result in exit() being called for the current application.
N *
N *  @param error CU_ErrorCode indicating the current error condition.
N *  @see CU_get_error()
N *  @see CU_get_error_msg()
N *  @see CU_ErrorCode
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#ifdef USE_DEPRECATED_CUNIT_NAMES
S/** Deprecated (version 1). @deprecated Use CU_get_error_msg(). */
S#define get_error() CU_get_error_msg()
N#endif  /* USE_DEPRECATED_CUNIT_NAMES */
N
N#endif  /*  CUNIT_CUERROR_H_SEEN  */
N/** @} */
L 112 "..\..\Middleware\ut_manager\Cunit\Headers\CUnit.h" 2
N#include "TestDB.h"   /* not needed here - included for user convenience */
L 1 "..\..\Middleware\ut_manager\Cunit\Headers\TestDB.h" 1
N/*
N *  CUnit - A Unit testing framework library for C.
N *  Copyright (C) 2001       Anil Kumar
N *  Copyright (C) 2004-2006  Anil Kumar, Jerry St.Clair
N *
N *  This library is free software; you can redistribute it and/or
N *  modify it under the terms of the GNU Library General Public
N *  License as published by the Free Software Foundation; either
N *  version 2 of the License, or (at your option) any later version.
N *
N *  This library is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
N *  Library General Public License for more details.
N *
N *  You should have received a copy of the GNU Library General Public
N *  License along with this library; if not, write to the Free Software
N *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
N */
N
N/*
N *  Contains all the Type Definitions and functions declarations
N *  for the CUnit test database maintenance.
N *
N *  Aug 2001      Initial implementation. (AK)
N *
N *  09/Aug/2001   Added Preprocessor conditionals for the file. (AK)
N *
N *  24/aug/2001   Made the linked list from SLL to DLL(doubly linked list). (AK)
N *
N *  31-Aug-2004   Restructured to eliminate global variables error_number,
N *                g_pTestRegistry; new interface, support for deprecated
N *                version 1 interface, moved error handling code to
N *                CUError.[ch], moved test run counts and _TestResult out
N *                of TestRegistry to TestRun.h. (JDS)
N *
N *  01-Sep-2004   Added jmp_buf to CU_Test. (JDS)
N *
N *  05-Sep-2004   Added internal test interface. (JDS)
N *
N *  15-Apr-2006   Removed constraint that suites/tests be uniquely named.
N *                Added ability to turn individual tests/suites on or off.
N *                Moved doxygen comments for public API here to header. (JDS)
N *
N *  16-Avr-2007   Added setup and teardown functions. (CJN)
N *
N */
N
N/** @file
N *  Management functions for tests, suites, and the test registry.
N *  Unit testing in CUnit follows the common structure of unit
N *  tests aggregated in suites, which are themselves aggregated
N *  in a test registry.  This module provides functions and
N *  typedef's to support the creation, registration, and manipulation
N *  of test cases, suites, and the registry.
N */
N/** @addtogroup Framework
N *  @{
N */
N
N#ifndef CUNIT_TESTDB_H_SEEN
N#define CUNIT_TESTDB_H_SEEN
N
N#include <setjmp.h>   /* jmp_buf */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\setjmp.h" 1
N/* setjmp.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.6 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N
N
N/*
N * setjmp.h declares two functions and one type, for bypassing the normal
N * function call and return discipline (useful for dealing with unusual
N * conditions encountered in a low-level function of a program).
N */
N
N#ifndef __setjmp_h
N#define __setjmp_h
N#define __ARMCLIB_VERSION 5060019
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N
N  #ifndef __SETJMP_DECLS
N  #define __SETJMP_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
Stypedef __int64 jmp_buf[];      /* do not specify size at all */
N#else
N  #ifdef __TARGET_ARCH_AARCH64
S    typedef __int64 jmp_buf[48];
N  #else
N    typedef __int64 jmp_buf[20];    /* size as defined in the ATEPCS */
N  #endif
N                            /* an array type suitable for holding the data */
N                            /* needed to restore a calling environment.    */
N#endif
Nextern const int __aeabi_JMP_BUF_SIZE;
N              
N/* setjmp is a macro so that it cannot be used other than directly called. */
N/* NB that ANSI declare that anyone who undefines the setjmp macro or uses */
N/* (or defines) the name setjmp without including this header will get     */
N/* what they deserve.  In addition, C++ requires setjmp to be a macro.     */
N
Nextern _ARMABI int setjmp(jmp_buf /*env*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int setjmp(jmp_buf  ) __attribute__((__nonnull__(1)));
N   /* Saves its calling environment in its jmp_buf argument, for later use
N    * by the longjmp function.
N    * Returns: If the return is from a direct invocation, the setjmp function
N    *          returns the value zero. If the return from a call to the longjmp
N    *          function, the setjmp function returns a non zero value.
N    */
N#define setjmp(jmp_buf) (__CLIBNS setjmp(jmp_buf))
N
Nextern _ARMABI_NORETURN void longjmp(jmp_buf /*env*/, int /*val*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __declspec(__noreturn) void longjmp(jmp_buf  , int  ) __attribute__((__nonnull__(1)));
N   /* Restores the environment saved by the most recent call to setjmp in the
N    * same invocation of the program, with the corresponding jmp_buf argument.
N    * If there has been no such call, or if the function containing the call
N    * to setjmp has terminated execution (eg. with a return statement) in the
N    * interim, the behaviour is undefined.
N    * All accessible objects have values as of the time longjmp was called,
N    * except that the values of objects of automatic storage duration that do
N    * not have volatile type and have been changed between the setjmp and
N    * longjmp calls are indeterminate.
N    * As it bypasses the usual function call and return mechanism, the longjmp
N    * function shall execute correctly in contexts of interrupts, signals and
N    * any of their associated functions. However, if the longjmp function is
N    * invoked from a nested signal handler (that is, from a function invoked as
N    * a result of a signal raised during the handling of another signal), the
N    * behaviour is undefined.
N    * Returns: After longjmp is completed, program execution continues as if
N    *          the corresponding call to setjmp had just returned the value
N    *          specified by val. The longjmp function cannot cause setjmp to
N    *          return the value 0; if val is 0, setjmp returns the value 1.
N    */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */    
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __SETJMP_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __SETJMP_NO_EXPORTS
S      using ::std::jmp_buf;
S      using ::std::setjmp;
S      using ::std::longjmp;
S      using ::std::__aeabi_JMP_BUF_SIZE;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of setjmp.h */
N
L 65 "..\..\Middleware\ut_manager\Cunit\Headers\TestDB.h" 2
N
N#include "CUnit.h"
N#include "CUError.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*=================================================================
N *  Typedefs and Data Structures
N *=================================================================*/
N
Ntypedef int  (*CU_InitializeFunc)(void);  /**< Signature for suite initialization function. */
Ntypedef int  (*CU_CleanupFunc)(void);     /**< Signature for suite cleanup function. */
Ntypedef void (*CU_TestFunc)(void);        /**< Signature for a testing function in a test case. */
Ntypedef void (*CU_SetUpFunc)(void);       /**< Signature for a test SetUp function. */
Ntypedef void (*CU_TearDownFunc)(void);    /**< Signature for a test TearDown function. */
N
N/*-----------------------------------------------------------------
N * CU_Test, CU_pTest
N *-----------------------------------------------------------------*/
N/** CUnit test case data type.
N *  CU_Test is a double linked list of unit tests.  Each test has
N *  a name, a callable test function, and a flag for whether the
N *  test is active and thus executed during a  test run.  A test
N *  also holds links to the next and previous tests in the list,
N *  as well as a jmp_buf reference for use in implementing fatal
N *  assertions.<br /><br />
N *
N *  Generally, the linked list includes tests which are associated
N *  with each other in a CU_Suite.  As a result, tests are run in
N *  the order in which they are added to a suite (see CU_add_test()).
N *  <br /><br />
N *
N *  It is recommended that the name of each CU_Test in a suite have
N *  a unique name.  Otherwise, only the first-registered test having
N *  a given name will be accessible by that name.  There are no
N *  restrictions on the test function.  This means that the same
N *  function could, in principle, be called more than once from
N *  different tests.
N *
N *  @see CU_Suite
N *  @see CU_TestRegistry
N */
Ntypedef struct CU_Test
N{
N  char*           pName;      /**< Test name. */
N  CU_BOOL         fActive;    /**< Flag for whether test is executed during a run. */
X  int         fActive;     
N  CU_TestFunc     pTestFunc;  /**< Pointer to the test function. */
N  jmp_buf*        pJumpBuf;   /**< Jump buffer for setjmp/longjmp test abort mechanism. */
N
N  struct CU_Test* pNext;      /**< Pointer to the next test in linked list. */
N  struct CU_Test* pPrev;      /**< Pointer to the previous test in linked list. */
N
N} CU_Test;
Ntypedef CU_Test* CU_pTest;    /**< Pointer to a CUnit test case. */
N
N/*-----------------------------------------------------------------
N *  CU_Suite, CU_pSuite
N *-----------------------------------------------------------------*/
N/** CUnit suite data type.
N *  CU_Suite is a linked list of CU_Test containers.  Each suite has
N *  a name, a count of registered unit tests, and a flag for whether
N *  the suite is active during test runs. It also holds pointers to
N *  optional initialization and cleanup functions.  If non-NULL, these
N *  are called before and after running the suite's tests, respectively.
N *  In addition, the suite holds a pointer to the head of the linked
N *  list of associated CU_Test objects.  Finally, pointers to the next
N *  and previous suites in the linked list are maintained.<br /><br />
N *
N *  Generally, the linked list includes suites which are associated with
N *  each other in a CU_TestRegistry.  As a result, suites are run in the
N *  order in which they are registered (see CU_add_suite()).<br /><br />
N *
N *  It is recommended that name of each CU_Suite in a test registry have
N *  a unique name.  Otherwise, only the first-registered suite having a
N *  given name will be accessible by name.  There are no restrictions on
N *  the contained tests.  This means that the same CU_Test could, in
N *  principle, be run more than once fron different suites.
N *
N *  @see CU_Test
N *  @see CU_TestRegistry
N */
Ntypedef struct CU_Suite
N{
N  char*             pName;            /**< Suite name. */
N  CU_BOOL           fActive;          /**< Flag for whether suite is executed during a run. */
X  int           fActive;           
N  CU_pTest          pTest;            /**< Pointer to the 1st test in the suite. */
N  CU_InitializeFunc pInitializeFunc;  /**< Pointer to the suite initialization function. */
N  CU_CleanupFunc    pCleanupFunc;     /**< Pointer to the suite cleanup function. */
N  CU_SetUpFunc      pSetUpFunc;       /**< Pointer to the test SetUp function. */
N  CU_TearDownFunc   pTearDownFunc;    /**< Pointer to the test TearDown function. */
N
N  unsigned int      uiNumberOfTests;  /**< Number of tests in the suite. */
N  struct CU_Suite*  pNext;            /**< Pointer to the next suite in linked list. */
N  struct CU_Suite*  pPrev;            /**< Pointer to the previous suite in linked list. */
N
N  unsigned int      uiNumberOfTestsFailed;  /**< Number of failed tests in the suite. */
N  unsigned int      uiNumberOfTestsSuccess; /**< Number of success tests in the suite. */
N} CU_Suite;
Ntypedef CU_Suite* CU_pSuite;          /**< Pointer to a CUnit suite. */
N
N/*-----------------------------------------------------------------
N *  CU_TestRegistry, CU_pTestRegistry
N *-----------------------------------------------------------------*/
N/** CUnit test registry data type.
N *  CU_TestRegisty is the repository for suites containing unit tests.
N *  The test registry maintains a count of the number of CU_Suite
N *  objects contained in the registry, as well as a count of the total
N *  number of CU_Test objects associated with those suites.  It also
N *  holds a pointer to the head of the linked list of CU_Suite objects.
N *  <br /><br />
N *
N *  With this structure, the user will normally add suites implictly to
N *  the internal test registry using CU_add_suite(), and then add tests
N *  to each suite using CU_add_test().  Test runs are then initiated
N *  using one of the appropriate functions in TestRun.c via one of the
N *  user interfaces.<br /><br />
N *
N *  Automatic creation and destruction of the internal registry and its
N *  objects is available using CU_initialize_registry() and
N *  CU_cleanup_registry(), respectively.  For internal and testing
N *  purposes, the internal registry can be retrieved and assigned.
N *  Functions are also provided for creating and destroying independent
N *  registries.<br /><br />
N *
N *  Note that earlier versions of CUnit also contained a pointer to a
N *  linked list of CU_FailureRecord objects (termed _TestResults).
N *  This has been removed from theregistry and relocated to TestRun.c.
N *
N *  @see CU_Test
N *  @see CU_Suite
N *  @see CU_initialize_registry()
N *  @see CU_cleanup_registry()
N *  @see CU_get_registry()
N *  @see CU_set_registry()
N *  @see CU_create_new_registry()
N *  @see CU_destroy_existing_registry()
N */
Ntypedef struct CU_TestRegistry
N{
N#ifdef USE_DEPRECATED_CUNIT_NAMES
S  /** Union to support v1.1-1 member name. */
S  union {
S    unsigned int uiNumberOfSuites;  /**< Number of suites in the test registry. */
S    unsigned int uiNumberOfGroups;  /**< Deprecated (version 1). @deprecated Use uiNumberOfSuites. */
S  };
S  unsigned int uiNumberOfTests;     /**< Number of tests in the test registry. */
S  /** Union to support v1.1-1 member name. */
S  union {
S    CU_pSuite    pSuite;            /**< Pointer to the 1st suite in the test registry. */
S    CU_pSuite    pGroup;            /**< Deprecated (version 1). @deprecated Use pSuite. */
S  };
N#else
N  unsigned int uiNumberOfSuites;    /**< Number of registered suites in the registry. */
N  unsigned int uiNumberOfTests;     /**< Total number of registered tests in the registry. */
N  CU_pSuite    pSuite;              /**< Pointer to the 1st suite in the test registry. */
N#endif
N} CU_TestRegistry;
Ntypedef CU_TestRegistry* CU_pTestRegistry;  /**< Pointer to a CUnit test registry. */
N
N/*=================================================================
N *  Public interface functions
N *=================================================================*/
N
NCU_EXPORT
X
NCU_ErrorCode CU_initialize_registry(void);
N/**<
N *  Initializes the framework test registry.
N *  Any existing registry is freed, including all stored suites
N *  and associated tests.  It is not necessary to explicitly call
N *  CU_cleanup_registry() before reinitializing the framework.
N *  The most recent stored test results are also cleared.<br /><br />
N *
N *  <B>This function must not be called during a test run (checked
N *  by assertion)</B>
N *
N *  @return  CUE_NOMEMORY if memory for the new registry cannot
N *           be allocated, CUE_SUCCESS otherwise.
N *  @see CU_cleanup_registry
N *  @see CU_get_registry
N *  @see CU_set_registry
N *  @see CU_registry_initialized
N */
N
NCU_EXPORT
X
Nvoid CU_cleanup_registry(void);
N/**<
N *  Clears the test registry.
N *  The active test registry is freed, including all stored suites
N *  and associated tests.  The most recent stored test results are
N *  also cleared.  After calling this function, CUnit suites cannot
N *  be added until CU_initialize_registry() or CU_set_registry() is
N *  called.  Further, any pointers to suites or test cases held by
N *  the user will be invalidated by calling this function.<br /><br />
N *
N *  This function may be called multiple times without generating
N *  an error condition.  However, <B>this function must not be
N *  called during a test run (checked by assertion)</B></P>.
N *
N *  @see CU_initialize_registry
N *  @see CU_get_registry
N *  @see CU_set_registry
N */
N
NCU_EXPORT CU_BOOL CU_registry_initialized(void);
X int CU_registry_initialized(void);
N/**<
N *  Checks whether the test registry has been initialized.
N *
N *  @return  CU_TRUE if the registry has been initialized,
N *           CU_FALSE otherwise.
N *  @see CU_initialize_registry
N *  @see CU_cleanup_registry
N */
N
NCU_EXPORT
X
NCU_pSuite CU_add_suite(const char *strName,
N                       CU_InitializeFunc pInit,
N                       CU_CleanupFunc pClean);
N/**<
N *  Creates a new test suite and adds it to the test registry.
N *  This function creates a new test suite having the specified
N *  name and initialization/cleanup functions and adds it to the
N *  test registry.  The new suite will be active and able to be
N *  executed during a test run.  The test registry must be
N *  initialized before calling this function (checked by assertion).
N *  pInit and pClean may be NULL, in which case no corresponding
N *  initialization of cleanup function will be called when the suite
N *  is run.  strName may be empty ("") but may not be NULL.<br /><br />
N *
N *  The return value is a pointer to the newly-created suite, or
N *  NULL if there was a problem with the suite creation or addition.
N *  An error code is also set for the framework. Note that if the
N *  name specified for the new suite is a duplicate, the suite will
N *  be created and added but the error code will be set to CUE_DUP_SUITE.
N *  The duplicate suite will not be accessible by name.<br /><br />
N *
N *  NOTE - the CU_pSuite pointer returned should NOT BE FREED BY
N *  THE USER.  The suite is freed by the CUnit system when
N *  CU_cleanup_registry() is called.  <b>This function must not
N *  be called during a test run (checked by assertion)</b>. <br /><br />
N *
N *  CU_add_suite() sets the following error codes:
N *  - CUE_SUCCESS if no errors occurred.
N *  - CUE_NOREGISTRY if the registry has not been initialized.
N *  - CUE_NO_SUITENAME if strName is NULL.
N *  - CUE_DUP_SUITE if a suite having strName is already registered.
N *  - CUE_NOMEMORY if a memory allocation failed.
N *
N *  @param strName Name for the new test suite (non-NULL).
N *  @param pInit   Initialization function to call before running suite.
N *  @param pClean  Cleanup function to call after running suite.
N *  @return A pointer to the newly-created suite (NULL if creation failed)
N */
N
NCU_EXPORT
X
NCU_pSuite CU_add_suite_with_setup_and_teardown(const char *strName,
N                       CU_InitializeFunc pInit,
N                       CU_CleanupFunc pClean,
N                       CU_SetUpFunc pSetup,
N                       CU_TearDownFunc pTear);
N/**<
N *  The same as CU_add_suite but also adds setup and tear down callbacks for
N *  each test in this suite.
N *
N *  @param pSetup  SetUp function to call before running each test.
N *  @param pTear   TearDown function to call after running each test.
N */
N
NCU_EXPORT
X
NCU_ErrorCode CU_set_suite_active(CU_pSuite pSuite, CU_BOOL fNewActive);
XCU_ErrorCode CU_set_suite_active(CU_pSuite pSuite, int fNewActive);
N/**<
N *  Activates or deactivates a suite.
N *  Only activated suites can be executed during a test run.
N *  By default a suite is active upon creation, but can be deactivated
N *  by passing it along with CU_FALSE to this function.  The suite
N *  can be reactivated by passing it along with CU_TRUE.  The current
N *  value of the active flag is available as pSuite->fActive.  If pSuite
N *  is NULL then error code CUE_NOSUITE is returned.
N *
N *  @param pSuite     Pointer to the suite to modify (non-NULL).
N *  @param fNewActive If CU_TRUE then the suite will be activated;
N *                    if CU_FALSE it will be deactivated.
N *  @return Returns CUE_NOSUITE if pSuite is NULL, CUE_SUCCESS if all is well.
N */
N
NCU_EXPORT
X
NCU_ErrorCode CU_set_suite_name(CU_pSuite pSuite, const char *strNewName);
N/**<
N *  Modifies the name of a suite.
N *  This function allows the name associated with a suite to
N *  be changed.  It is not recommended that a suite name be changed,
N *  nor should it be necessary under most circumstances.  However,
N *  this function is provided for those clients who need to change
N *  a suite's name.  The current value of the suite's name
N *  is available as pSuite->pName.  CUE_SUCCESS is returned if the
N *  function succeeds in changing the name.  CUE_NOSUITE is returned if
N *  pSuite is NULL, and CUE_NO_SUITENAME if strNewName is NULL.
N *
N *  @param pSuite     Pointer to the suite to modify (non-NULL).
N *  @param strNewName Pointer to string containing new suite name (non-NULL).
N *  @return Returns CUE_NOSUITE if pSuite is NULL, CUE_NO_SUITENAME if
N *          strNewName is NULL, and CUE_SUCCESS if all is well.
N */
N
NCU_EXPORT
X
NCU_ErrorCode CU_set_suite_initfunc(CU_pSuite pSuite, CU_InitializeFunc pNewInit);
N/**<
N *  Modifies the initialization function of a suite.
N *  This function allows the initialization function associated with
N *  a suite to be changed.  This is neither recommended nor should it
N *  be necessary under most circumstances.  However, this function is
N *  provided for those clients who need to change the function.  The
N *  current value of the function is available as pSuite->pInitializeFunc.
N *  CUE_SUCCESS is returned if the function succeeds, or CUE_NOSUITE if
N *  pSuite is NULL.  pNewInit may be NULL, which indicates the suite has
N *  no initialization function.
N *
N *  @param pSuite   Pointer to the suite to modify (non-NULL).
N *  @param pNewInit Pointer to function to use to initialize suite.
N *  @return Returns CUE_NOSUITE if pSuite is NULL, and CUE_SUCCESS if
N *          all is well.
N */
N
NCU_EXPORT
X
NCU_ErrorCode CU_set_suite_cleanupfunc(CU_pSuite pSuite, CU_CleanupFunc pNewClean);
N/**<
N *  Modifies the cleanup function of a suite.
N *  This function allows the cleanup function associated with a suite to
N *  be changed.  This is neither recommended nor should it be necessary
N *  under most circumstances.  However, this function is provided for those
N *  clients who need to change the function.  The current value of the
N *  function is available as pSuite->pCleanupFunc.  CUE_SUCCESS is returned
N *  if the function succeeds, or CUE_NOSUITE if pSuite is NULL.  pNewClean
N *  may be NULL, which indicates the suite has no cleanup function.
N *
N *  @param pSuite    Pointer to the suite to modify (non-NULL).
N *  @param pNewClean Pointer to function to use to clean up suite.
N *  @return Returns CUE_NOSUITE if pSuite is NULL, and CUE_SUCCESS if
N *          all is well.
N */
N
NCU_EXPORT
X
NCU_pSuite CU_get_suite(const char* strName);
N/**<
N *  Retrieves the suite having the specified name.
N *  Searches the active test registry and returns a pointer to the 1st
N *  suite found.  NULL is returned if no suite having the specified name
N *  is found.  In addition, the framework error state is set to CUE_NOREGISTRY
N *  if the registry is not initialized or to CUE_NO_SUITENAME if strName is NULL.
N *  If the return value is NULL and framework error state is CUE_SUCCESS, then
N *  the search simply failed to find the specified name.
N *  Use CU_get_suite_at_pos() to retrieve a suite by position rather than name.
N *
N *  @param strName The name of the suite to search for (non-NULL).
N *  @return Returns a pointer to the suite, or NULL if not found or an error occurred.
N *  @see CU_get_suite_at_pos()
N */
N
NCU_EXPORT
X
NCU_pSuite CU_get_suite_at_pos(unsigned int pos);
N/**<
N *  Retrieves the suite at the specified position.
N *  Iterates the active test registry and returns a pointer to the suite at
N *  position pos.  pos is a 1-based index having valid values
N *  [1 .. CU_get_registry()->uiNumberOfSuites] and corresponds to the order in
N *  which suites were registered.  If pos is invalid or an error occurs, 0 is
N *  returned.  In addition, the framework error state is set to CUE_NOREGISTRY if
N *  the registry is not initialized, or CUE_SUCCESS if pos was invalid.  Use
N *  CU_get_suite() to retrieve a suite by name rather than position.
N *
N *  @param pos The 1-based position of the suite to fetch.
N *  @return Returns a pointer to the suite, or 0 if not found or an error occurred.
N *  @see CU_get_suite()
N */
N
NCU_EXPORT
X
Nunsigned int CU_get_suite_pos(CU_pSuite pSuite);
N/**<
N *  Looks up the position of the specified suite.
N *  The position is a 1-based index of suites in the active test registry which
N *  corresponds to the order in which suites were registered.  If pSuite is not
N *  found or an error occurs, 0 is returned.  In addition, the framework error
N *  state is set to CUE_NOREGISTRY if the registry is not initialized, or
N *  CUE_NOSUITE if pSuite is NULL.  The returned position may be used to retrieve
N *  the suite using CU_get_suite_by_pos().
N *
N *  @param pSuite Pointer to the suite to find (non-NULL).
N *  @return Returns the 1-based position of pSuite in the registry, or NULL if
N *         not found or an error occurred.
N *  @see CU_get_suite_by_pos()
N *  @see CU_get_suite_pos_by_name()
N */
N
NCU_EXPORT
X
Nunsigned int CU_get_suite_pos_by_name(const char* strName);
N/**<
N *  Looks up the position of the suite having the specified name.
N *  The position is a 1-based index of suites in the active test registry which
N *  corresponds to the order in which suites were registered.  If no suite has the
N *  specified name or an error occurs, 0 is returned.  In addition, the framework error
N *  state is set to CUE_NOREGISTRY if the registry is not initialized, or
N *  CUE_NO_SUITENAME if strName is NULL.  The search ends at the 1st suite found having
N *  name strName.  The returned position may be used to retrieve the suite using
N *  CU_get_suite_by_pos().
N *
N *  @param strName Name of the suite to find (non-NULL).
N *  @return Returns the 1-based position of pSuite in the registry, or NULL if
N *          not found or an error occurred.
N *  @see CU_get_suite_by_pos()
N *  @see CU_get_suite_pos_by_name()
N */
N
NCU_EXPORT
X
NCU_pTest CU_add_test(CU_pSuite pSuite, const char* strName, CU_TestFunc pTestFunc);
N/**<
N *  This function creates a new test having the specified name
N *  and function, and adds it to the specified suite.  The new test
N *  is active and able to be executed during a test run.  At present,
N *  there is no mechanism for creating a test case independent of a
N *  suite.  Neither pSuite, strName, nor pTestFunc may be NULL.
N *
N *  The return value is a pointer to the newly-created test, or
N *  NULL if there was a problem with the test creation or addition.
N *  An error code is also set for the framework. Note that if the
N *  name specified for the new test is a duplicate within pSuite,
N *  the test will be created and added but the error code will be
N *  set to CUE_DUP_TEST.  The duplicate test will not be accessible
N *  by name.<br /><br />
N *
N *  NOTE - the CU_pTest pointer returned should NOT BE FREED BY
N *  THE USER.  The test is freed by the CUnit system when
N *  CU_cleanup_registry() is called.  <b>This function must not
N *  be called during a test run (checked by assertion)</b>. <br /><br />
N
N *  CU_add_test() sets the following error codes:
N *  - CUE_SUCCESS if no errors occurred.
N *  - CUE_NOREGISTRY if the registry has not been initialized.
N *  - CUE_NOSUITE if pSuite is NULL.
N *  - CUE_NO_TESTNAME if strName is NULL.
N *  - CUE_NOTEST if pTestFunc is NULL.
N *  - CUE_DUP_TEST if a test having strName is already registered to pSuite.
N *  - CUE_NOMEMORY if a memory allocation failed.<br /><br />
N *
N *  @param pSuite  Test suite to which to add new test (non-NULL).
N *  @param strName Name for the new test case (non-NULL).
N *  @param pTest   Function to call when running the test (non-NULL).
N *  @return A pointer to the newly-created test (NULL if creation failed)
N */
N
NCU_EXPORT
X
NCU_ErrorCode CU_set_test_active(CU_pTest pTest, CU_BOOL fNewActive);
XCU_ErrorCode CU_set_test_active(CU_pTest pTest, int fNewActive);
N/**<
N *  Activates or deactivates a specific test.
N *  Only activated tests can be executed during a test run.
N *  By default a test is active upon creation, but can be deactvated
N *  by passing it along with CU_FALSE to this function.  The test
N *  can be reactivated by passing it along with CU_TRUE.
N *  The current value of the active flag is available as pTest->fActive.
N *  If pTest is NULL then error code CUE_NOTEST is returned.  Otherwise
N *  CUE_SUCCESS is returned.
N *
N *  @param pTest      Pointer to the test to modify (non-NULL).
N *  @param fNewActive If CU_TRUE then test will be activated;
N *                    if CU_FALSE it will be deactivated.
N *  @return Returns CUE_NOTEST if pTest is NULL, CUE_SUCCESS if all is well.
N*/
N
NCU_EXPORT
X
NCU_ErrorCode CU_set_test_name(CU_pTest pTest, const char *strNewName);
N/**<
N *  Modifies the name of a test.
N *  This function allows the name associated with a test to
N *  be changed.  It is not recommended that a test name be changed,
N *  nor should it be necessary under most circumstances.  However,
N *  this function is provided for those clients who need to change
N *  a test's name.  The current value of the test's name is
N *  available as pTest->pName.  CUE_SUCCESS is returned if the
N *  function succeeds in changing the name.  CUE_NOTEST is returned if
N *  pTest is NULL, and CUE_NO_TESTNAME if strNewName is NULL.
N *
N *  @param pTest      Pointer to the test to modify (non-NULL).
N *  @param strNewName Pointer to string containing new test name (non-NULL).
N *  @return Returns CUE_NOTEST if pTest is NULL, CUE_NO_TESTNAME if
N *          strNewName is NULL, and CUE_SUCCESS if all is well.
N */
N
NCU_EXPORT
X
NCU_ErrorCode CU_set_test_func(CU_pTest pTest, CU_TestFunc pNewFunc);
N/**<
N *  Modifies the test function of a test.
N *  This function allows the test function associated with a test to be
N *  changed.  This is neither recommended nor should it be necessary under
N *  most circumstances.  However, this function is provided for those
N *  clients who need to change the test function.  The current value of
N *  the test function is available as pTest->pTestFunc.  CUE_SUCCESS is
N *  returned if the function succeeds, or CUE_NOTEST if either pTest or
N *  pNewFunc is NULL.
N *
N *  @param pTest    Pointer to the test to modify (non-NULL).
N *  @param pNewFunc Pointer to function to use for test function (non-NULL).
N *  @return Returns CUE_NOTEST if pTest or pNewFunc is NULL, and CUE_SUCCESS
N *          if all is well.
N */
N
NCU_EXPORT
X
NCU_pTest CU_get_test(CU_pSuite pSuite, const char *strName);
N/**<
N *  Retrieves the test having the specified name.
N *  Searches pSuite and returns a pointer to the 1st test found named strName.
N *  NULL is returned if no test having the specified name is found in pSuite.
N *  In addition, the framework error state is set as follows:
N *    - CUE_NOREGISTRY if the registry is not initialized
N *    - CUE_NOSUITE if pSuite is NULL
N *    - CUE_NO_TESTNAME if strName is NULL.
N *
N *  If the return value is NULL and framework error state is CUE_SUCCESS, then
N *  the search simply failed to find the specified name.  Use CU_get_test_at_pos()
N *  to retrieve a test by position rather than name.
N *
N *  @param pSuite  Pointer to the suite to search (non-NULL).
N *  @param strName The name of the test to search for (non-NULL).
N *  @return Returns a pointer to the test, or NULL if not found or an error occurred.
N *  @see CU_get_test_at_pos()
N */
N
NCU_EXPORT
X
NCU_pTest CU_get_test_at_pos(CU_pSuite pSuite, unsigned int pos);
N/**<
N *  Retrieves the test at the specified position in pSuite.
N *  Iterates the tests registered in pSuite and returns a pointer to the
N *  test at position pos.  pos is a 1-based index having valid values
N *  [1 .. pSuite->uiNumberOfTests] and corresponds to the order in
N *  which tests were added to pSuite.  If pos is invalid or an error occurs, 0 is
N *  returned.  In addition, the framework error state is set as follows:
N *    - CUE_NOREGISTRY if the registry is not initialized
N *    - CUE_NOSUITE if pSuite is NULL
N *  Use CU_get_test() to retrieve a test by name rather than position.
N *
N *  @param pSuite  Pointer to the suite to search (non-NULL).
N *  @param pos     The 1-based position of the test to fetch.
N *  @return Returns a pointer to the test, or 0 if not found or an error occurred.
N *  @see CU_get_test()
N */
N
NCU_EXPORT
X
Nunsigned int CU_get_test_pos(CU_pSuite pSuite, CU_pTest pTest);
N/**<
N *  Looks up the position of the specified test in pSuite.
N *  The position is a 1-based index of tests in pSuite which corresponds to the
N *  order in which tests were added.  If pTest is not found or an error occurs,
N *  0 is returned.  In addition, the framework error state is set as follows:
N *    - CUE_NOREGISTRY if the registry is not initialized
N *    - CUE_NOSUITE if pSuite is NULL
N *    - CUE_NOTEST if pTest is NULL
N *
N *  The returned position may be used to retrieve the test using CU_get_test_by_pos().
N *
N *  @param pSuite Pointer to the suite to search (non-NULL).
N *  @param pTest  Pointer to the test to find (non-NULL).
N *  @return Returns the 1-based position of pTest in pSuite, or NULL if
N *         not found or an error occurred.
N *  @see CU_get_test_by_pos()
N *  @see CU_get_test_pos_by_name()
N */
N
NCU_EXPORT
X
Nunsigned int CU_get_test_pos_by_name(CU_pSuite pSuite, const char *strName);
N/**<
N *  Looks up the position of the test having the specified name in pSuite.
N *  The position is a 1-based index of tests in pSuite which corresponds to the order
N *  in which tests were added.  If no test has the specified name or an error occurs,
N *  0 is returned.  In addition, the framework error state is set as follows:
N *    - CUE_NOREGISTRY if the registry is not initialized
N *    - CUE_NOSUITE if pSuite is NULL
N *    - CUE_NO_TESTNAME if strName is NULL
N *  The search ends at the 1st test found having name strName.  The returned position
N *  may be used to retrieve the suite using CU_get_test_by_pos().
N *
N *  @param pSuite  Pointer to the suite to search (non-NULL).
N *  @param strName Name of the test to find (non-NULL).
N *  @return Returns the 1-based position of pTest in pSuite, or NULL if
N *          not found or an error occurred.
N *  @see CU_get_test_by_pos()
N *  @see CU_get_test_pos_by_name()
N */
N
N#define CU_ADD_TEST(suite, test) (CU_add_test(suite, #test, (CU_TestFunc)test))
N/**< Shortcut macro for adding a test to a suite. */
N
N/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
N/*  This section is based conceptually on code
N *  Copyright (C) 2004  Aurema Pty Ltd.
N *
N *  This library is free software; you can redistribute it and/or
N *  modify it under the terms of the GNU Library General Public
N *  License as published by the Free Software Foundation; either
N *  version 2 of the License, or (at your option) any later version.
N *
N *  This library is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
N *  Library General Public License for more details.
N *
N *  You should have received a copy of the GNU Library General Public
N *  License along with this library; if not, write to the Free Software
N *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
N *
N *  Derived from code contributed by K. Cheung and Aurema Pty Ltd. (thanks!)
N *    test_case_t, test_group_t, test_suite_t
N */
N
N/**
N *  Test case parameters structure.
N *  This data type is provided to assist CUnit users manage collections of
N *  tests and suites.  It is intended to be used to build arrays of test case
N *  parameters that can be then be referred to in a CU_suite_info_t variable.
N */
Ntypedef struct CU_TestInfo {
N	const char  *pName;      /**< Test name. */
N	CU_TestFunc pTestFunc;  /**< Test function. */
N} CU_TestInfo;
Ntypedef CU_TestInfo* CU_pTestInfo;  /**< Pointer to CU_TestInfo type. */
N
N/**
N *  Suite parameters.
N *  This data type is provided to assist CUnit users manage collections of
N *  tests and suites.  It is intended to be used to build arrays of suite
N *  parameters that can be passed to a bulk registration function such as
N *  CU_register_suite() or CU_register_suites().
N */
Ntypedef struct CU_SuiteInfo {
N    const char       *pName;         /**< Suite name. */
N    CU_InitializeFunc pInitFunc;     /**< Suite initialization function. */
N    CU_CleanupFunc    pCleanupFunc;  /**< Suite cleanup function */
N    CU_SetUpFunc      pSetUpFunc;    /**< Pointer to the test SetUp function. */
N    CU_TearDownFunc   pTearDownFunc; /**< Pointer to the test TearDown function. */
N    CU_TestInfo      *pTests;        /**< Test case array - must be NULL terminated. */
N} CU_SuiteInfo;
Ntypedef CU_SuiteInfo* CU_pSuiteInfo;  /**< Pointer to CU_SuiteInfo type. */
N
N#define CU_TEST_INFO_NULL { NULL, NULL }
N/**< NULL CU_test_info_t to terminate arrays of tests. */
N#define CU_SUITE_INFO_NULL { NULL, NULL, NULL, NULL, NULL, NULL }
N/**< NULL CU_suite_info_t to terminate arrays of suites. */
N
N
NCU_EXPORT CU_ErrorCode CU_register_suites(CU_SuiteInfo suite_info[]);
X CU_ErrorCode CU_register_suites(CU_SuiteInfo suite_info[]);
N/**<
N *  Registers the suites in a single CU_SuiteInfo array.
N *  Multiple arrays can be registered using CU_register_nsuites().
N *
N *  @param	suite_info NULL-terminated array of CU_SuiteInfo items to register.
N *  @return A CU_ErrorCode indicating the error status.
N *  @see CU_register_suites()
N */
NCU_EXPORT CU_ErrorCode CU_register_nsuites(int suite_count, ...);
X CU_ErrorCode CU_register_nsuites(int suite_count, ...);
N/**<
N *  Registers multiple suite arrays in CU_SuiteInfo format.
N *  The function accepts a variable number of suite arrays to be registered.
N *  The number of arrays is indicated by the value of the 1st argument,
N *  suite_count.  Each suite in each array is registered with the CUnit test
N *  registry, along with all of the associated tests.
N *
N *  @param	suite_count The number of CU_SuiteInfo* arguments to follow.
N *  @param ...          suite_count number of CU_SuiteInfo* arguments.  NULLs are ignored.
N *  @return A CU_ErrorCode indicating the error status.
N *  @see CU_register_suites()
N */
N
N#ifdef USE_DEPRECATED_CUNIT_NAMES
Stypedef CU_TestInfo test_case_t;    /**< Deprecated (version 1). @deprecated Use CU_TestInfo. */
Stypedef CU_SuiteInfo test_group_t;  /**< Deprecated (version 1). @deprecated Use CU_SuiteInfo. */
S
S/** Deprecated (version 1). @deprecated Use CU_SuiteInfo and CU_TestInfo. */
Stypedef struct test_suite {
S	char *name;            /**< Suite name.  Currently not used. */
S	test_group_t *groups;  /**< Test groups.  This must be a NULL terminated array. */
S} test_suite_t;
S
S/** Deprecated (version 1). @deprecated Use CU_TEST_INFO_NULL. */
S#define TEST_CASE_NULL { NULL, NULL }
S/** Deprecated (version 1). @deprecated Use CU_TEST_GROUP_NULL. */
S#define TEST_GROUP_NULL { NULL, NULL, NULL, NULL }
S
S/** Deprecated (version 1). @deprecated Use CU_register_suites(). */
S#define test_group_register(tg) CU_register_suites(tg)
S
S/** Deprecated (version 1). @deprecated Use CU_SuiteInfo and CU_register_suites(). */
SCU_EXPORT int test_suite_register(test_suite_t *ts)
S{
S	test_group_t *tg;
S	int error;
S
S	for (tg = ts->groups; tg->pName; tg++)
S		if ((error = CU_register_suites(tg)) != CUE_SUCCESS)
S			return error;
S
S	return CUE_SUCCESS;
S}
N#endif    /* USE_DEPRECATED_CUNIT_NAMES */
N/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
N
N#ifdef USE_DEPRECATED_CUNIT_NAMES
Stypedef CU_InitializeFunc InitializeFunc; /**< Deprecated (version 1). @deprecated Use CU_InitializeFunc. */
Stypedef CU_CleanupFunc CleanupFunc;       /**< Deprecated (version 1). @deprecated Use CU_CleanupFunc. */
Stypedef CU_TestFunc TestFunc;             /**< Deprecated (version 1). @deprecated Use CU_TestFunc. */
S
Stypedef CU_Test _TestCase;                /**< Deprecated (version 1). @deprecated Use CU_Test. */
Stypedef CU_pTest PTestCase;               /**< Deprecated (version 1). @deprecated Use CU_pTest. */
S
Stypedef CU_Suite  _TestGroup;             /**< Deprecated (version 1). @deprecated Use CU_Suite. */
Stypedef CU_pSuite PTestGroup;             /**< Deprecated (version 1). @deprecated Use CU_pSuite. */
S
Stypedef CU_TestRegistry  _TestRegistry;   /**< Deprecated (version 1). @deprecated Use CU_TestRegistry. */
Stypedef CU_pTestRegistry PTestRegistry;   /**< Deprecated (version 1). @deprecated Use CU_pTestRegistry. */
S
S/* Public interface functions */
S/** Deprecated (version 1). @deprecated Use CU_initialize_registry(). */
S#define initialize_registry() CU_initialize_registry()
S/** Deprecated (version 1). @deprecated Use CU_cleanup_registry(). */
S#define cleanup_registry() CU_cleanup_registry()
S/** Deprecated (version 1). @deprecated Use CU_add_suite(). */
S#define add_test_group(name, init, clean) CU_add_suite(name, init, clean)
S/** Deprecated (version 1). @deprecated Use CU_add_test(). */
S#define add_test_case(group, name, test) CU_add_test(group, name, test)
S
S/* private internal CUnit testing functions */
S/** Deprecated (version 1). @deprecated Use CU_get_registry(). */
S#define get_registry() CU_get_registry()
S/** Deprecated (version 1). @deprecated Use CU_set_registry(). */
S#define set_registry(reg) CU_set_registry((reg))
S
S/** Deprecated (version 1). @deprecated Use CU_get_suite_by_name(). */
S#define get_group_by_name(group, reg) CU_get_suite_by_name(group, reg)
S/** Deprecated (version 1). @deprecated Use CU_get_test_by_name(). */
S#define get_test_by_name(test, group) CU_get_test_by_name(test, group)
S
S/** Deprecated (version 1). @deprecated Use ADD_TEST_TO_SUITE. */
S#define ADD_TEST_TO_GROUP(group, test) (CU_add_test(group, #test, (CU_TestFunc)test))
N#endif  /* USE_DEPRECATED_CUNIT_NAMES */
N
N/*=================================================================
N *  Internal CUnit system functions.
N *  Should not be routinely called by users.
N *=================================================================*/
N
NCU_EXPORT CU_pTestRegistry CU_get_registry(void);
X CU_pTestRegistry CU_get_registry(void);
N/**<
N *  Retrieves a pointer to the current test registry.
N *  Returns NULL if the registry has not been initialized using
N *  CU_initialize_registry().  Directly accessing the registry
N *  should not be necessary for most users.  This function is
N *  provided primarily for internal and testing purposes.
N *
N *  @return A pointer to the current registry (NULL if uninitialized).
N *  @see CU_initialize_registry
N *  @see CU_set_registry
N */
N
NCU_EXPORT CU_pTestRegistry CU_set_registry(CU_pTestRegistry pTestRegistry);
X CU_pTestRegistry CU_set_registry(CU_pTestRegistry pTestRegistry);
N/**<
N *  Sets the registry to an existing CU_pTestRegistry instance.
N *  A pointer to the original registry is returned.  Note that the
N *  original registry is not freed, and it becomes the caller's
N *  responsibility to do so.  Directly accessing the registry
N *  should not be necessary for most users.  This function is
N *  provided primarily for internal and testing purposes.<br /><br />
N *
N *  <B>This function must not be called during a test run (checked
N *  by assertion)</B>.
N *
N *  @return A pointer to the original registry that was replaced.
N *  @see CU_initialize_registry
N *  @see CU_cleanup_registry
N *  @see CU_get_registry
N */
N
NCU_EXPORT CU_pTestRegistry CU_create_new_registry(void);
X CU_pTestRegistry CU_create_new_registry(void);
N/**<
N *  Creates and initializes a new test registry.
N *  Returns a pointer to a new, initialized registry (NULL if memory could
N *  not be allocated).  It is the caller's responsibility to destroy and free
N *  the new registry (unless it is made the active test registry using
N *  CU_set_registry()).
N */
N
NCU_EXPORT
X
Nvoid CU_destroy_existing_registry(CU_pTestRegistry* ppRegistry);
N/**<
N *  Destroys and frees all memory for an existing test registry.
N *  The active test registry is destroyed by the CUnit system in
N *  CU_cleanup_registry(), so only call this function on registries created
N *  or held independently of the internal CUnit system.<br /><br />
N *
N *  Once a registry is made the active test registry using CU_set_registry(),
N *  its destruction will be handled by the framework.  ppRegistry may not be
N *  NULL (checked by assertion), but *ppRegistry can be NULL (in which case the
N *  function has no effect).  Note that *ppRegistry will be set to NULL on return.
N *
N *  @param ppRegistry Address of a pointer to the registry to destroy (non-NULL).
N */
N
NCU_EXPORT
X
NCU_pSuite CU_get_suite_by_name(const char *szSuiteName, CU_pTestRegistry pRegistry);
N/**<
N *  Retrieves a pointer to the suite having the specified name.
N *  Scans the pRegistry and returns a pointer to the first suite located
N *  having the specified name.  Neither szSuiteName nor pRegistry may be
N *  NULL (checked by assertion).  Clients should normally use CU_get_suite()
N *  instead, which automatically searches the active test registry.
N *
N *  @param szSuiteName The name of the suite to locate (non-NULL).
N *  @param pRegistry   The registry to scan (non-NULL).
N *  @return Pointer to the first suite having the specified name,
N *          NULL if not found.
N *  @see CU_get_suite()
N */
N
NCU_EXPORT
X
NCU_pSuite CU_get_suite_by_index(unsigned int index, CU_pTestRegistry pRegistry);
N/**<
N *  Retrieves a pointer to the suite at the specified (1-based) index.
N *  Iterates pRegistry and returns a pointer to the suite located at the
N *  specified index.  pRegistry may not be NULL (checked by assertion).
N *  Clients should normally use CU_get_suite_at_pos() instead, which
N *  automatically searches the active test registry.
N *
N *  @param index     The 1-based index of the suite to find.
N *  @param pRegistry The registry to scan (non-NULL).
N *  @return Pointer to the suite at the specified index, or
N *          NULL if index is invalid.
N *  @see CU_get_suite_at_pos()
N */
N
NCU_EXPORT
X
NCU_pTest CU_get_test_by_name(const char* szTestName, CU_pSuite pSuite);
N/**<
N *  Retrieves a pointer to the test case in pSuite having the specified name.
N *  The first test case in pSuite having the specified name is returned, or
N *  NULL if not found.  Neither szSuiteName nor pSuite may be NULL (checked
N *  by assertion).  Clients should normally use CU_get_test() instead.
N *
N *  @param szTestName The name of the test case to locate (non-NULL).
N *  @param pSuite     The suite to scan (non-NULL).
N *  @return Pointer to the first test case having the specified name,
N *          NULL if not found.
N *  @see CU_get_test()
N */
N
NCU_EXPORT
X
NCU_pTest CU_get_test_by_index(unsigned int index, CU_pSuite pSuite);
N/**<
N *  Retrieves a pointer to the test at the specified (1-based) index.
N *  Iterates pSuite and returns a pointer to the test located at the
N *  specified index.  pSuite may not be NULL (checked by assertion).
N *  Clients should normally use CU_get_test_at_pos() instead, which
N *  automatically searches the active test registry.
N *
N *  @param index     The 1-based index of the test to find.
N *  @param pRegistry The registry to scan (non-NULL).
N *  @return Pointer to the test at the specified index, or
N *          NULL if index is invalid.
N *  @see CU_get_test_at_pos()
N */
N
N#ifdef CUNIT_BUILD_TESTS
Svoid test_cunit_TestDB(void);
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N#endif  /*  CUNIT_TESTDB_H_SEEN  */
N/** @} */
L 113 "..\..\Middleware\ut_manager\Cunit\Headers\CUnit.h" 2
N#include "TestRun.h"  /* not needed here - include (after BOOL define) for user convenience */
L 1 "..\..\Middleware\ut_manager\Cunit\Headers\TestRun.h" 1
N/*
N *  CUnit - A Unit testing framework library for C.
N *  Copyright (C) 2001       Anil Kumar
N *  Copyright (C) 2004-2006  Anil Kumar, Jerry St.Clair
N *
N *  This library is free software; you can redistribute it and/or
N *  modify it under the terms of the GNU Library General Public
N *  License as published by the Free Software Foundation; either
N *  version 2 of the License, or (at your option) any later version.
N *
N *  This library is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
N *  Library General Public License for more details.
N *
N *  You should have received a copy of the GNU Library General Public
N *  License along with this library; if not, write to the Free Software
N *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
N */
N
N/*
N *  Contains Interface to Run tests.
N *
N *  Aug 2001      Initial implementation. (AK)
N *
N *  09/Aug/2001   Contains generic run tests interface which can be used
N *                for any type of frontend interface framework. (AK)
N *
N *  24/Nov/2001   Added Handler for Group Initialization failure condition. (AK)
N *
N *  05-Aug-2004   New interface.  Since these should be internal functions,
N *                no support for deprecated version 1 names provided now,
N *                eliminated global variables for current test & suite,
N *                moved (renamed) _TestResult here from TestDB.h. (JDS)
N *
N *  05-Sep-2004   Added internal test interface. (JDS)
N *
N *  23-Apr-2006   Moved doxygen comments into header.
N *                Added type marker to CU_FailureRecord.
N *                Added support for tracking inactive suites/tests. (JDS)
N *
N *  08-May-2006   Moved CU_print_run_results() functionality from
N *                console/basic test complete handler.  (JDS)
N *
N *  24-May-2006   Added callbacks for suite start and complete events.
N *                Added tracking/reported of elapsed time.  (JDS)
N */
N
N/** @file
N *  Test run management functions (user interface).
N *  The TestRun module implements functions supporting the running
N *  of tests elements (suites and tests).  This includes functions for
N *  running suites and tests, retrieving the number of tests/suites run,
N *  and managing callbacks during the run process.<br /><br />
N *
N *  The callback mechanism works as follows.  The CUnit runtime system
N *  supports the registering and calling of functions at the start and end
N *  of each test, when all tests are complete, and when a suite
N *  initialialization function returns an error.  This allows clients to
N *  perform actions associated with these events such as output formatting
N *  and reporting.
N */
N/** @addtogroup Framework
N * @{
N */
N
N#ifndef CUNIT_TESTRUN_H_SEEN
N#define CUNIT_TESTRUN_H_SEEN
N
N#include "CUnit.h"
N#include "CUError.h"
N#include "TestDB.h"
N#include <stdio.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** Types of failures occurring during test runs. */
Ntypedef enum CU_FailureTypes
N{
N  CUF_SuiteInactive = 1,    /**< Inactive suite was run. */
N  CUF_SuiteInitFailed,      /**< Suite initialization function failed. */
N  CUF_SuiteCleanupFailed,   /**< Suite cleanup function failed. */
N  CUF_TestInactive,         /**< Inactive test was run. */
N  CUF_AssertFailed          /**< CUnit assertion failed during test run. */
N} CU_FailureType;           /**< Failure type. */
N
N/* CU_FailureRecord type definition. */
N/** Data type for holding assertion failure information (linked list). */
Ntypedef struct CU_FailureRecord
N{
N  CU_FailureType  type;           /**< Failure type. */
N  unsigned int    uiLineNumber;   /**< Line number of failure. */
N  char*           strFileName;    /**< Name of file where failure occurred. */
N  char*           strCondition;   /**< Test condition which failed. */
N  CU_pTest        pTest;          /**< Test containing failure. */
N  CU_pSuite       pSuite;         /**< Suite containing test having failure. */
N
N  struct CU_FailureRecord* pNext; /**< Pointer to next record in linked list. */
N  struct CU_FailureRecord* pPrev; /**< Pointer to previous record in linked list. */
N
N} CU_FailureRecord;
Ntypedef CU_FailureRecord* CU_pFailureRecord;  /**< Pointer to CU_FailureRecord. */
N
N/* CU_RunSummary type definition. */
N/** Data type for holding statistics and assertion failures for a test run. */
Ntypedef struct CU_RunSummary
N{
N  char PackageName[50];
N  unsigned int nSuitesRun;        /**< Number of suites completed during run. */
N  unsigned int nSuitesFailed;     /**< Number of suites for which initialization failed. */
N  unsigned int nSuitesInactive;   /**< Number of suites which were inactive. */
N  unsigned int nTestsRun;         /**< Number of tests completed during run. */
N  unsigned int nTestsFailed;      /**< Number of tests containing failed assertions. */
N  unsigned int nTestsInactive;    /**< Number of tests which were inactive (in active suites). */
N  unsigned int nAsserts;          /**< Number of assertions tested during run. */
N  unsigned int nAssertsFailed;    /**< Number of failed assertions. */
N  unsigned int nFailureRecords;   /**< Number of failure records generated. */
N  double       ElapsedTime;       /**< Elapsed time for run in seconds. */
N} CU_RunSummary;
Ntypedef CU_RunSummary* CU_pRunSummary;  /**< Pointer to CU_RunSummary. */
N
N/*--------------------------------------------------------------------
N * Type Definitions for Message Handlers.
N *--------------------------------------------------------------------*/
Ntypedef void (*CU_SuiteStartMessageHandler)(const CU_pSuite pSuite);
N/**< Message handler called at the start of a suite. pSuite will not be null. */
N
Ntypedef void (*CU_TestStartMessageHandler)(const CU_pTest pTest, const CU_pSuite pSuite);
N/**< Message handler called at the start of a test.
N *  The parameters are the test and suite being run.  The test run is
N *  considered in progress when the message handler is called.
N *  Neither pTest nor pSuite may be null.
N */
N
Ntypedef void (*CU_TestCompleteMessageHandler)(const CU_pTest pTest, const CU_pSuite pSuite,
N                                              const CU_pFailureRecord pFailure);
N/**< Message handler called at the completion of a test.
N *  The parameters are the test and suite being run, plus a pointer to
N *  the first failure record applicable to this test.  If the test did
N *  not have any assertion failures, pFailure will be NULL.  The test run
N *  is considered in progress when the message handler is called.
N */
N
Ntypedef void (*CU_SuiteCompleteMessageHandler)(const CU_pSuite pSuite,
N                                               const CU_pFailureRecord pFailure);
N/**< Message handler called at the completion of a suite.
N *  The parameters are suite being run, plus a pointer to the first failure
N *  record applicable to this suite.  If the suite and it's tests did not
N *  have any failures, pFailure will be NULL.  The test run is considered
N *  in progress when the message handler is called.
N */
N
Ntypedef void (*CU_AllTestsCompleteMessageHandler)(const CU_pFailureRecord pFailure);
N/**< Message handler called at the completion of a test run.
N *  The parameter is a pointer to the linked list holding the failure
N *  records for the test run.  The test run is considered completed
N *  when the message handler is called.
N */
N
Ntypedef void (*CU_SuiteInitFailureMessageHandler)(const CU_pSuite pSuite);
N/**< Message handler called when a suite initializer fails.
N *  The test run is considered in progress when the message handler is called.
N */
N
Ntypedef void (*CU_SuiteCleanupFailureMessageHandler)(const CU_pSuite pSuite);
N/**< Message handler called when a suite cleanup function fails.
N *  The test run is considered in progress when the message handler is called.
N */
N
N/*--------------------------------------------------------------------
N * Get/Set functions for Message Handlers
N *--------------------------------------------------------------------*/
NCU_EXPORT void CU_set_suite_start_handler(CU_SuiteStartMessageHandler pSuiteStartMessage);
X void CU_set_suite_start_handler(CU_SuiteStartMessageHandler pSuiteStartMessage);
N/**< Sets the message handler to call before each suite is run. */
NCU_EXPORT void CU_set_test_start_handler(CU_TestStartMessageHandler pTestStartMessage);
X void CU_set_test_start_handler(CU_TestStartMessageHandler pTestStartMessage);
N/**< Sets the message handler to call before each test is run. */
NCU_EXPORT void CU_set_test_complete_handler(CU_TestCompleteMessageHandler pTestCompleteMessage);
X void CU_set_test_complete_handler(CU_TestCompleteMessageHandler pTestCompleteMessage);
N/**< Sets the message handler to call after each test is run. */
NCU_EXPORT void CU_set_suite_complete_handler(CU_SuiteCompleteMessageHandler pSuiteCompleteMessage);
X void CU_set_suite_complete_handler(CU_SuiteCompleteMessageHandler pSuiteCompleteMessage);
N/**< Sets the message handler to call after each suite is run. */
NCU_EXPORT void CU_set_all_test_complete_handler(CU_AllTestsCompleteMessageHandler pAllTestsCompleteMessage);
X void CU_set_all_test_complete_handler(CU_AllTestsCompleteMessageHandler pAllTestsCompleteMessage);
N/**< Sets the message handler to call after all tests have been run. */
NCU_EXPORT void CU_set_suite_init_failure_handler(CU_SuiteInitFailureMessageHandler pSuiteInitFailureMessage);
X void CU_set_suite_init_failure_handler(CU_SuiteInitFailureMessageHandler pSuiteInitFailureMessage);
N/**< Sets the message handler to call when a suite initialization function returns an error. */
NCU_EXPORT void CU_set_suite_cleanup_failure_handler(CU_SuiteCleanupFailureMessageHandler pSuiteCleanupFailureMessage);
X void CU_set_suite_cleanup_failure_handler(CU_SuiteCleanupFailureMessageHandler pSuiteCleanupFailureMessage);
N/**< Sets the message handler to call when a suite cleanup function returns an error. */
N
NCU_EXPORT CU_SuiteStartMessageHandler          CU_get_suite_start_handler(void);
X CU_SuiteStartMessageHandler          CU_get_suite_start_handler(void);
N/**< Retrieves the message handler called before each suite is run. */
NCU_EXPORT CU_TestStartMessageHandler           CU_get_test_start_handler(void);
X CU_TestStartMessageHandler           CU_get_test_start_handler(void);
N/**< Retrieves the message handler called before each test is run. */
NCU_EXPORT CU_TestCompleteMessageHandler        CU_get_test_complete_handler(void);
X CU_TestCompleteMessageHandler        CU_get_test_complete_handler(void);
N/**< Retrieves the message handler called after each test is run. */
NCU_EXPORT CU_SuiteCompleteMessageHandler       CU_get_suite_complete_handler(void);
X CU_SuiteCompleteMessageHandler       CU_get_suite_complete_handler(void);
N/**< Retrieves the message handler called after each suite is run. */
NCU_EXPORT CU_AllTestsCompleteMessageHandler    CU_get_all_test_complete_handler(void);
X CU_AllTestsCompleteMessageHandler    CU_get_all_test_complete_handler(void);
N/**< Retrieves the message handler called after all tests are run. */
NCU_EXPORT CU_SuiteInitFailureMessageHandler    CU_get_suite_init_failure_handler(void);
X CU_SuiteInitFailureMessageHandler    CU_get_suite_init_failure_handler(void);
N/**< Retrieves the message handler called when a suite initialization error occurs. */
NCU_EXPORT CU_SuiteCleanupFailureMessageHandler CU_get_suite_cleanup_failure_handler(void);
X CU_SuiteCleanupFailureMessageHandler CU_get_suite_cleanup_failure_handler(void);
N/**< Retrieves the message handler called when a suite cleanup error occurs. */
N
N/*--------------------------------------------------------------------
N * Functions for running registered tests and suites.
N *--------------------------------------------------------------------*/
NCU_EXPORT CU_ErrorCode CU_run_all_tests(void);
X CU_ErrorCode CU_run_all_tests(void);
N/**<
N *  Runs all tests in all suites registered in the test registry.
N *  The suites are run in the order registered in the test registry.
N *  For each suite, it is first checked to make sure it is active.
N *  Any initialization function is then called, the suite is run
N *  using run_single_suite(), and finally any suite cleanup function
N *  is called.  If an error condition (other than CUE_NOREGISTRY)
N *  occurs during the run, the action depends on the current error
N *  action (see CU_set_error_action()).  An inactive suite is not
N *  considered an error for this function.  Note that the run
N *  statistics (counts of tests, successes, failures) are cleared
N *  each time this function is run, even if it is unsuccessful.
N *
N *  @return A CU_ErrorCode indicating the first error condition
N *          encountered while running the tests.
N *  @see CU_run_suite() to run the tests in a specific suite.
N *  @see CU_run_test() for run a specific test only.
N */
N
NCU_EXPORT CU_ErrorCode CU_run_suite(CU_pSuite pSuite);
X CU_ErrorCode CU_run_suite(CU_pSuite pSuite);
N/**<
N *  Runs all tests in a specified suite.
N *  The suite need not be registered in the test registry to be
N *  run.  It does, however, need to have its fActive flag set to
N *  CU_TRUE.<br /><br />
N *
N *  Any initialization function for the suite is first called,
N *  then the suite is run using run_single_suite(), and any suite
N *  cleanup function is called.  Note that the run statistics
N *  (counts of tests, successes, failures) are initialized each
N *  time this function is called even if it is unsuccessful.  If
N *  an error condition occurs during the run, the action depends
N *  on the  current error action (see CU_set_error_action()).
N *
N *  @param pSuite The suite containing the test (non-NULL)
N *  @return A CU_ErrorCode indicating the first error condition
N *          encountered while running the suite.  CU_run_suite()
N *          sets and returns CUE_NOSUITE if pSuite is NULL, or
N *          CUE_SUITE_INACTIVE if the requested suite is not
N *          activated.  Other error codes can be set during suite
N *          initialization or cleanup or during test runs.
N *  @see CU_run_all_tests() to run all suites.
N *  @see CU_run_test() to run a single test in a specific suite.
N */
N
NCU_EXPORT CU_ErrorCode CU_run_test(CU_pSuite pSuite, CU_pTest pTest);
X CU_ErrorCode CU_run_test(CU_pSuite pSuite, CU_pTest pTest);
N/**<
N *  Runs a specific test in a specified suite.
N *  The suite need not be registered in the test registry to be run,
N *  although the test must be registered in the specified suite.
N *  Any initialization function for the suite is first
N *  called, then the test is run using run_single_test(), and
N *  any suite cleanup function is called.  Note that the
N *  run statistics (counts of tests, successes, failures)
N *  will be initialized each time this function is called even
N *  if it is not successful.  Both the suite and test specified
N *  must be active for the test to be run.  The suite is not
N *  considered to be run, although it may be counted as a failed
N *  suite if the intialization or cleanup functions fail.
N *
N *  @param pSuite The suite containing the test (non-NULL)
N *  @param pTest  The test to run (non-NULL)
N *  @return A CU_ErrorCode indicating the first error condition
N *          encountered while running the suite.  CU_run_test()
N *          sets and returns CUE_NOSUITE if pSuite is NULL,
N *          CUE_NOTEST if pTest is NULL, CUE_SUITE_INACTIVE if
N *          pSuite is not active, CUE_TEST_NOT_IN_SUITE
N *          if pTest is not registered in pSuite, and CU_TEST_INACTIVE
N *          if pTest is not active.  Other error codes can be set during
N *          suite initialization or cleanup or during the test run.
N *  @see CU_run_all_tests() to run all tests/suites.
N *  @see CU_run_suite() to run all tests in a specific suite.
N */
N
N/*--------------------------------------------------------------------
N * Functions for setting runtime behavior.
N *--------------------------------------------------------------------*/
NCU_EXPORT void CU_set_fail_on_inactive(CU_BOOL new_inactive);
X void CU_set_fail_on_inactive(int new_inactive);
N/**<
N *  Sets whether an inactive suite or test is treated as a failure.
N *  If CU_TRUE, then failure records will be generated for inactive
N *  suites or tests encountered during a test run.  The default is
N *  CU_TRUE so that the client is reminded that the framewrork
N *  contains inactive suites/tests.  Set to CU_FALSE to turn off
N *  this behavior.
N *
N *  @param new_inactive New setting for whether to treat inactive
N *                      suites and tests as failures during a test
N *                      run (CU_TRUE) or not (CU_FALSE).
N *  @see CU_get_fail_on_failure()
N */
N
NCU_EXPORT CU_BOOL CU_get_fail_on_inactive(void);
X int CU_get_fail_on_inactive(void);
N/**<
N *  Retrieves the current setting for whether inactive suites/tests
N *  are treated as failures.  If CU_TRUE then failure records will
N *  be generated for inactive suites encountered during a test run.
N *
N *  @return CU_TRUE if inactive suites/tests are failures, CU_FALSE if not.
N *  @see CU_set_fail_on_inactive()
N */
N
N/*--------------------------------------------------------------------
N * Functions for getting information about the previous test run.
N *--------------------------------------------------------------------*/
NCU_EXPORT unsigned int CU_get_number_of_suites_run(void);
X unsigned int CU_get_number_of_suites_run(void);
N/**< Retrieves the number of suites completed during the previous run (reset each run). */
NCU_EXPORT unsigned int CU_get_number_of_suites_failed(void);
X unsigned int CU_get_number_of_suites_failed(void);
N/**< Retrieves the number of suites which failed to initialize during the previous run (reset each run). */
NCU_EXPORT unsigned int CU_get_number_of_suites_inactive(void);
X unsigned int CU_get_number_of_suites_inactive(void);
N/**< Retrieves the number of inactive suites found during the previous run (reset each run). */
NCU_EXPORT unsigned int CU_get_number_of_tests_run(void);
X unsigned int CU_get_number_of_tests_run(void);
N/**< Retrieves the number of tests completed during the previous run (reset each run). */
NCU_EXPORT unsigned int CU_get_number_of_tests_failed(void);
X unsigned int CU_get_number_of_tests_failed(void);
N/**< Retrieves the number of tests containing failed assertions during the previous run (reset each run). */
NCU_EXPORT unsigned int CU_get_number_of_tests_inactive(void);
X unsigned int CU_get_number_of_tests_inactive(void);
N/**< Retrieves the number of inactive tests found during the previous run (reset each run). */
NCU_EXPORT unsigned int CU_get_number_of_asserts(void);
X unsigned int CU_get_number_of_asserts(void);
N/**< Retrieves the number of assertions processed during the last run (reset each run). */
NCU_EXPORT unsigned int CU_get_number_of_successes(void);
X unsigned int CU_get_number_of_successes(void);
N/**< Retrieves the number of successful assertions during the last run (reset each run). */
NCU_EXPORT unsigned int CU_get_number_of_failures(void);
X unsigned int CU_get_number_of_failures(void);
N/**< Retrieves the number of failed assertions during the last run (reset each run). */
NCU_EXPORT unsigned int CU_get_number_of_failure_records(void);
X unsigned int CU_get_number_of_failure_records(void);
N/**<
N *  Retrieves the number failure records created during the previous run (reset each run).
N *  Note that this may be more than the number of failed assertions, since failure
N *  records may also be created for failed suite initialization and cleanup.
N */
NCU_EXPORT double CU_get_elapsed_time(void);
X double CU_get_elapsed_time(void);
N/**<
N *  Retrieves the elapsed time for the last run in seconds (reset each run).
N *  This function will calculate the current elapsed time if the test run has not
N *  yet completed.  This is in contrast to the run summary returned by
N *  CU_get_run_summary(), for which the elapsed time is not updated until the
N *  end of the run.
N */
NCU_EXPORT CU_pFailureRecord CU_get_failure_list(void);
X CU_pFailureRecord CU_get_failure_list(void);
N/**<
N *  Retrieves the head of the linked list of failures which occurred during the
N *  last run (reset each run).  Note that the pointer returned is invalidated
N *  when the client initiates a run using CU_run_all_tests(), CU_run_suite(),
N *  or CU_run_test().
N */
NCU_EXPORT CU_pRunSummary CU_get_run_summary(void);
X CU_pRunSummary CU_get_run_summary(void);
N/**<
N *  Retrieves the entire run summary for the last test run (reset each run).
N *  The run counts and stats contained in the run summary are updated
N *  throughout a test run.  Note, however, that the elapsed time is not
N *  updated until after all suites/tests are run but before the "all tests
N *  complete"  message handler is called (if any).  To get the elapsed
N *  time during a test run, use CU_get_elapsed_time() instead.
N */
N
NCU_EXPORT char * CU_get_run_results_string(void);
X char * CU_get_run_results_string(void);
N/**<
N *  Creates a string and fills it with a summary of the current run results.
N *  The run summary presents data for the suites, tests, and assertions
N *  encountered during the run, as well as the elapsed time.  The data
N *  presented include the number of registered, run, passed, failed, and
N *  inactive entities for each, as well as the elapsed time.  This function
N *  can be called at any time, although the test registry must have been
N *  initialized (checked by assertion).  The returned string is owned by
N *  the caller and should be deallocated using CU_FREE().  NULL is returned
N *  if there is an error allocating the new string.
N *
N *  @return A new string containing the run summary (owned by caller).
N */
N
NCU_EXPORT void CU_print_run_results(FILE *file);
X void CU_print_run_results(FILE *file);
N/**<
N *  Prints a summary of the current run results to file.
N *  The run summary is the same as returned by CU_get_run_results_string().
N *  Note that no newlines are printed before or after the report, so any
N *  positioning must be performed before/after calling this function.  The
N *  report itself extends over several lines broken by '\n' characters.
N *  file may not be NULL (checked by assertion).
N *
N *  @param file Pointer to stream to receive the printed summary (non-NULL).
N */
N
N/*--------------------------------------------------------------------
N * Functions for internal & testing use.
N *--------------------------------------------------------------------*/
NCU_EXPORT CU_pSuite CU_get_current_suite(void);
X CU_pSuite CU_get_current_suite(void);
N/**< Retrieves a pointer to the currently-running suite (NULL if none). */
NCU_EXPORT CU_pTest  CU_get_current_test(void);
X CU_pTest  CU_get_current_test(void);
N/**< Retrievea a pointer to the currently-running test (NULL if none). */
NCU_EXPORT CU_BOOL   CU_is_test_running(void);
X int   CU_is_test_running(void);
N/**< Returns <CODE>CU_TRUE</CODE> if a test run is in progress,
N *  <CODE>CU_TRUE</CODE> otherwise.
N */
N
NCU_EXPORT void      CU_clear_previous_results(void);
X void      CU_clear_previous_results(void);
N/**<
N *  Initializes the run summary information stored from the previous test run.
N *  Resets the run counts to zero, and frees any memory associated with
N *  failure records.  Calling this function multiple times, while inefficient,
N *  will not cause an error condition.
N *  @see clear_previous_results()
N */
N
NCU_EXPORT CU_BOOL CU_assertImplementation(CU_BOOL bValue,
X int CU_assertImplementation(int bValue,
N                                          unsigned int uiLine,
N                                          const char *strCondition,
N                                          const char *strFile,
N                                          const char *strFunction,
N                                          CU_BOOL bFatal);
X                                          int bFatal);
N/**<
N *  Assertion implementation function.
N *  All CUnit assertions reduce to a call to this function.  It should only be
N *  called during an active test run (checked by assertion).  This means that CUnit
N *  assertions should only be used in registered test functions during a test run.
N *
N *  @param bValue        Value of the assertion (CU_TRUE or CU_FALSE).
N *  @param uiLine        Line number of failed test statement.
N *  @param strCondition  String containing logical test that failed.
N *  @param strFile       Source file where test statement failed.
N *  @param strFunction   Function where test statement failed.
N *  @param bFatal        CU_TRUE to abort test (via longjmp()), CU_FALSE to continue test.
N *  @return As a convenience, returns the value of the assertion (i.e. bValue).
N */
N
N#ifdef USE_DEPRECATED_CUNIT_NAMES
Stypedef CU_FailureRecord  _TestResult;  /**< @deprecated Use CU_FailureRecord. */
Stypedef CU_pFailureRecord PTestResult;  /**< @deprecated Use CU_pFailureRecord. */
N#endif  /* USE_DEPRECATED_CUNIT_NAMES */
N
N#ifdef CUNIT_BUILD_TESTS
Svoid test_cunit_TestRun(void);
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N#endif  /*  CUNIT_TESTRUN_H_SEEN  */
N/** @} */
L 114 "..\..\Middleware\ut_manager\Cunit\Headers\CUnit.h" 2
N
N/** Record a pass condition without performing a logical test. */
N#define CU_PASS(msg) \
N  { CU_assertImplementation(CU_TRUE, __LINE__, ("CU_PASS(" #msg ")"), __FILE__, "", CU_FALSE); }
X#define CU_PASS(msg)   { CU_assertImplementation(CU_TRUE, __LINE__, ("CU_PASS(" #msg ")"), __FILE__, "", CU_FALSE); }
N
N/** Simple assertion.
N *  Reports failure with no other action.
N */
N#define CU_ASSERT(value) \
N  { CU_assertImplementation((value), __LINE__, #value, __FILE__, "", CU_FALSE); }
X#define CU_ASSERT(value)   { CU_assertImplementation((value), __LINE__, #value, __FILE__, "", CU_FALSE); }
N
N/** Simple assertion.
N *  Reports failure and causes test to abort.
N */
N#define CU_ASSERT_FATAL(value) \
N  { CU_assertImplementation((value), __LINE__, #value, __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_FATAL(value)   { CU_assertImplementation((value), __LINE__, #value, __FILE__, "", CU_TRUE); }
N
N/** Simple assertion.
N *  Reports failure with no other action.
N */
N#define CU_TEST(value) \
N  { CU_assertImplementation((value), __LINE__, #value, __FILE__, "", CU_FALSE); }
X#define CU_TEST(value)   { CU_assertImplementation((value), __LINE__, #value, __FILE__, "", CU_FALSE); }
N
N/** Simple assertion.
N *  Reports failure and causes test to abort.
N */
N#define CU_TEST_FATAL(value) \
N  { CU_assertImplementation((value), __LINE__, #value, __FILE__, "", CU_TRUE); }
X#define CU_TEST_FATAL(value)   { CU_assertImplementation((value), __LINE__, #value, __FILE__, "", CU_TRUE); }
N
N/** Record a failure without performing a logical test. */
N#define CU_FAIL(msg) \
N  { CU_assertImplementation(CU_FALSE, __LINE__, ("CU_FAIL(" #msg ")"), __FILE__, "", CU_FALSE); }
X#define CU_FAIL(msg)   { CU_assertImplementation(CU_FALSE, __LINE__, ("CU_FAIL(" #msg ")"), __FILE__, "", CU_FALSE); }
N
N/** Record a failure without performing a logical test, and abort test. */
N#define CU_FAIL_FATAL(msg) \
N  { CU_assertImplementation(CU_FALSE, __LINE__, ("CU_FAIL_FATAL(" #msg ")"), __FILE__, "", CU_TRUE); }
X#define CU_FAIL_FATAL(msg)   { CU_assertImplementation(CU_FALSE, __LINE__, ("CU_FAIL_FATAL(" #msg ")"), __FILE__, "", CU_TRUE); }
N
N/** Asserts that value is CU_TRUE.
N *  Reports failure with no other action.
N */
N#define CU_ASSERT_TRUE(value) \
N  { CU_assertImplementation((value), __LINE__, ("CU_ASSERT_TRUE(" #value ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_TRUE(value)   { CU_assertImplementation((value), __LINE__, ("CU_ASSERT_TRUE(" #value ")"), __FILE__, "", CU_FALSE); }
N
N/** Asserts that value is CU_TRUE.
N *  Reports failure and causes test to abort.
N */
N#define CU_ASSERT_TRUE_FATAL(value) \
N  { CU_assertImplementation((value), __LINE__, ("CU_ASSERT_TRUE_FATAL(" #value ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_TRUE_FATAL(value)   { CU_assertImplementation((value), __LINE__, ("CU_ASSERT_TRUE_FATAL(" #value ")"), __FILE__, "", CU_TRUE); }
N
N/** Asserts that value is CU_FALSE.
N *  Reports failure with no other action.
N */
N#define CU_ASSERT_FALSE(value) \
N  { CU_assertImplementation(!(value), __LINE__, ("CU_ASSERT_FALSE(" #value ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_FALSE(value)   { CU_assertImplementation(!(value), __LINE__, ("CU_ASSERT_FALSE(" #value ")"), __FILE__, "", CU_FALSE); }
N
N/** Asserts that value is CU_FALSE.
N *  Reports failure and causes test to abort.
N */
N#define CU_ASSERT_FALSE_FATAL(value) \
N  { CU_assertImplementation(!(value), __LINE__, ("CU_ASSERT_FALSE_FATAL(" #value ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_FALSE_FATAL(value)   { CU_assertImplementation(!(value), __LINE__, ("CU_ASSERT_FALSE_FATAL(" #value ")"), __FILE__, "", CU_TRUE); }
N
N/** Asserts that actual == expected.
N *  Reports failure with no other action.
N */
N#define CU_ASSERT_EQUAL(actual, expected) \
N  { CU_assertImplementation(((actual) == (expected)), __LINE__, ("CU_ASSERT_EQUAL(" #actual "," #expected ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_EQUAL(actual, expected)   { CU_assertImplementation(((actual) == (expected)), __LINE__, ("CU_ASSERT_EQUAL(" #actual "," #expected ")"), __FILE__, "", CU_FALSE); }
N
N/** Asserts that actual == expected.
N *  Reports failure and causes test to abort.
N */
N#define CU_ASSERT_EQUAL_FATAL(actual, expected) \
N  { CU_assertImplementation(((actual) == (expected)), __LINE__, ("CU_ASSERT_EQUAL_FATAL(" #actual "," #expected ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_EQUAL_FATAL(actual, expected)   { CU_assertImplementation(((actual) == (expected)), __LINE__, ("CU_ASSERT_EQUAL_FATAL(" #actual "," #expected ")"), __FILE__, "", CU_TRUE); }
N
N/** Asserts that actual != expected.
N *  Reports failure with no other action.
N */
N#define CU_ASSERT_NOT_EQUAL(actual, expected) \
N  { CU_assertImplementation(((actual) != (expected)), __LINE__, ("CU_ASSERT_NOT_EQUAL(" #actual "," #expected ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_NOT_EQUAL(actual, expected)   { CU_assertImplementation(((actual) != (expected)), __LINE__, ("CU_ASSERT_NOT_EQUAL(" #actual "," #expected ")"), __FILE__, "", CU_FALSE); }
N
N/** Asserts that actual != expected.
N *  Reports failure and causes test to abort.
N */
N#define CU_ASSERT_NOT_EQUAL_FATAL(actual, expected) \
N  { CU_assertImplementation(((actual) != (expected)), __LINE__, ("CU_ASSERT_NOT_EQUAL_FATAL(" #actual "," #expected ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_NOT_EQUAL_FATAL(actual, expected)   { CU_assertImplementation(((actual) != (expected)), __LINE__, ("CU_ASSERT_NOT_EQUAL_FATAL(" #actual "," #expected ")"), __FILE__, "", CU_TRUE); }
N
N/** Asserts that pointers actual == expected.
N *  Reports failure with no other action.
N */
N#define CU_ASSERT_PTR_EQUAL(actual, expected) \
N  { CU_assertImplementation(((const void*)(actual) == (const void*)(expected)), __LINE__, ("CU_ASSERT_PTR_EQUAL(" #actual "," #expected ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_PTR_EQUAL(actual, expected)   { CU_assertImplementation(((const void*)(actual) == (const void*)(expected)), __LINE__, ("CU_ASSERT_PTR_EQUAL(" #actual "," #expected ")"), __FILE__, "", CU_FALSE); }
N
N/** Asserts that pointers actual == expected.
N * Reports failure and causes test to abort.
N */
N#define CU_ASSERT_PTR_EQUAL_FATAL(actual, expected) \
N  { CU_assertImplementation(((const void*)(actual) == (const void*)(expected)), __LINE__, ("CU_ASSERT_PTR_EQUAL_FATAL(" #actual "," #expected ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_PTR_EQUAL_FATAL(actual, expected)   { CU_assertImplementation(((const void*)(actual) == (const void*)(expected)), __LINE__, ("CU_ASSERT_PTR_EQUAL_FATAL(" #actual "," #expected ")"), __FILE__, "", CU_TRUE); }
N
N/** Asserts that pointers actual != expected.
N *  Reports failure with no other action.
N */
N#define CU_ASSERT_PTR_NOT_EQUAL(actual, expected) \
N  { CU_assertImplementation(((const void*)(actual) != (const void*)(expected)), __LINE__, ("CU_ASSERT_PTR_NOT_EQUAL(" #actual "," #expected ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_PTR_NOT_EQUAL(actual, expected)   { CU_assertImplementation(((const void*)(actual) != (const void*)(expected)), __LINE__, ("CU_ASSERT_PTR_NOT_EQUAL(" #actual "," #expected ")"), __FILE__, "", CU_FALSE); }
N
N/** Asserts that pointers actual != expected.
N *  Reports failure and causes test to abort.
N */
N#define CU_ASSERT_PTR_NOT_EQUAL_FATAL(actual, expected) \
N  { CU_assertImplementation(((const void*)(actual) != (const void*)(expected)), __LINE__, ("CU_ASSERT_PTR_NOT_EQUAL_FATAL(" #actual "," #expected ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_PTR_NOT_EQUAL_FATAL(actual, expected)   { CU_assertImplementation(((const void*)(actual) != (const void*)(expected)), __LINE__, ("CU_ASSERT_PTR_NOT_EQUAL_FATAL(" #actual "," #expected ")"), __FILE__, "", CU_TRUE); }
N
N/** Asserts that pointer value is NULL.
N *  Reports failure with no other action.
N */
N#define CU_ASSERT_PTR_NULL(value) \
N  { CU_assertImplementation((NULL == (const void*)(value)), __LINE__, ("CU_ASSERT_PTR_NULL(" #value")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_PTR_NULL(value)   { CU_assertImplementation((NULL == (const void*)(value)), __LINE__, ("CU_ASSERT_PTR_NULL(" #value")"), __FILE__, "", CU_FALSE); }
N
N/** Asserts that pointer value is NULL.
N *  Reports failure and causes test to abort.
N */
N#define CU_ASSERT_PTR_NULL_FATAL(value) \
N  { CU_assertImplementation((NULL == (const void*)(value)), __LINE__, ("CU_ASSERT_PTR_NULL_FATAL(" #value")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_PTR_NULL_FATAL(value)   { CU_assertImplementation((NULL == (const void*)(value)), __LINE__, ("CU_ASSERT_PTR_NULL_FATAL(" #value")"), __FILE__, "", CU_TRUE); }
N
N/** Asserts that pointer value is not NULL.
N *  Reports failure with no other action.
N */
N#define CU_ASSERT_PTR_NOT_NULL(value) \
N  { CU_assertImplementation((NULL != (const void*)(value)), __LINE__, ("CU_ASSERT_PTR_NOT_NULL(" #value")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_PTR_NOT_NULL(value)   { CU_assertImplementation((NULL != (const void*)(value)), __LINE__, ("CU_ASSERT_PTR_NOT_NULL(" #value")"), __FILE__, "", CU_FALSE); }
N
N/** Asserts that pointer value is not NULL.
N *  Reports failure and causes test to abort.
N */
N#define CU_ASSERT_PTR_NOT_NULL_FATAL(value) \
N  { CU_assertImplementation((NULL != (const void*)(value)), __LINE__, ("CU_ASSERT_PTR_NOT_NULL_FATAL(" #value")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_PTR_NOT_NULL_FATAL(value)   { CU_assertImplementation((NULL != (const void*)(value)), __LINE__, ("CU_ASSERT_PTR_NOT_NULL_FATAL(" #value")"), __FILE__, "", CU_TRUE); }
N
N/** Asserts that string actual == expected.
N *  Reports failure with no other action.
N */
N#define CU_ASSERT_STRING_EQUAL(actual, expected) \
N  { CU_assertImplementation(!(strcmp((const char*)(actual), (const char*)(expected))), __LINE__, ("CU_ASSERT_STRING_EQUAL(" #actual ","  #expected ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_STRING_EQUAL(actual, expected)   { CU_assertImplementation(!(strcmp((const char*)(actual), (const char*)(expected))), __LINE__, ("CU_ASSERT_STRING_EQUAL(" #actual ","  #expected ")"), __FILE__, "", CU_FALSE); }
N
N/** Asserts that string actual == expected.
N *  Reports failure and causes test to abort.
N */
N#define CU_ASSERT_STRING_EQUAL_FATAL(actual, expected) \
N  { CU_assertImplementation(!(strcmp((const char*)(actual), (const char*)(expected))), __LINE__, ("CU_ASSERT_STRING_EQUAL_FATAL(" #actual ","  #expected ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_STRING_EQUAL_FATAL(actual, expected)   { CU_assertImplementation(!(strcmp((const char*)(actual), (const char*)(expected))), __LINE__, ("CU_ASSERT_STRING_EQUAL_FATAL(" #actual ","  #expected ")"), __FILE__, "", CU_TRUE); }
N
N/** Asserts that string actual != expected.
N *  Reports failure with no other action.
N */
N#define CU_ASSERT_STRING_NOT_EQUAL(actual, expected) \
N  { CU_assertImplementation((strcmp((const char*)(actual), (const char*)(expected))), __LINE__, ("CU_ASSERT_STRING_NOT_EQUAL(" #actual ","  #expected ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_STRING_NOT_EQUAL(actual, expected)   { CU_assertImplementation((strcmp((const char*)(actual), (const char*)(expected))), __LINE__, ("CU_ASSERT_STRING_NOT_EQUAL(" #actual ","  #expected ")"), __FILE__, "", CU_FALSE); }
N
N/** Asserts that string actual != expected.
N *  Reports failure and causes test to abort.
N */
N#define CU_ASSERT_STRING_NOT_EQUAL_FATAL(actual, expected) \
N  { CU_assertImplementation((strcmp((const char*)(actual), (const char*)(expected))), __LINE__, ("CU_ASSERT_STRING_NOT_EQUAL_FATAL(" #actual ","  #expected ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_STRING_NOT_EQUAL_FATAL(actual, expected)   { CU_assertImplementation((strcmp((const char*)(actual), (const char*)(expected))), __LINE__, ("CU_ASSERT_STRING_NOT_EQUAL_FATAL(" #actual ","  #expected ")"), __FILE__, "", CU_TRUE); }
N
N/** Asserts that string actual == expected with length specified.
N *  The comparison is limited to count characters.
N *  Reports failure with no other action.
N */
N#define CU_ASSERT_NSTRING_EQUAL(actual, expected, count) \
N  { CU_assertImplementation(!(strncmp((const char*)(actual), (const char*)(expected), (size_t)(count))), __LINE__, ("CU_ASSERT_NSTRING_EQUAL(" #actual ","  #expected "," #count ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_NSTRING_EQUAL(actual, expected, count)   { CU_assertImplementation(!(strncmp((const char*)(actual), (const char*)(expected), (size_t)(count))), __LINE__, ("CU_ASSERT_NSTRING_EQUAL(" #actual ","  #expected "," #count ")"), __FILE__, "", CU_FALSE); }
N
N/** Asserts that string actual == expected with length specified.
N *  The comparison is limited to count characters.
N *  Reports failure and causes test to abort.
N */
N#define CU_ASSERT_NSTRING_EQUAL_FATAL(actual, expected, count) \
N  { CU_assertImplementation(!(strncmp((const char*)(actual), (const char*)(expected), (size_t)(count))), __LINE__, ("CU_ASSERT_NSTRING_EQUAL_FATAL(" #actual ","  #expected "," #count ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_NSTRING_EQUAL_FATAL(actual, expected, count)   { CU_assertImplementation(!(strncmp((const char*)(actual), (const char*)(expected), (size_t)(count))), __LINE__, ("CU_ASSERT_NSTRING_EQUAL_FATAL(" #actual ","  #expected "," #count ")"), __FILE__, "", CU_TRUE); }
N
N/** Asserts that string actual != expected with length specified.
N *  The comparison is limited to count characters.
N *  Reports failure with no other action.
N */
N#define CU_ASSERT_NSTRING_NOT_EQUAL(actual, expected, count) \
N  { CU_assertImplementation((strncmp((const char*)(actual), (const char*)(expected), (size_t)(count))), __LINE__, ("CU_ASSERT_NSTRING_NOT_EQUAL(" #actual ","  #expected "," #count ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_NSTRING_NOT_EQUAL(actual, expected, count)   { CU_assertImplementation((strncmp((const char*)(actual), (const char*)(expected), (size_t)(count))), __LINE__, ("CU_ASSERT_NSTRING_NOT_EQUAL(" #actual ","  #expected "," #count ")"), __FILE__, "", CU_FALSE); }
N
N/** Asserts that string actual != expected with length specified.
N *  The comparison is limited to count characters.
N *  Reports failure and causes test to abort.
N */
N#define CU_ASSERT_NSTRING_NOT_EQUAL_FATAL(actual, expected, count) \
N  { CU_assertImplementation((strncmp((const char*)(actual), (const char*)(expected), (size_t)(count))), __LINE__, ("CU_ASSERT_NSTRING_NOT_EQUAL_FATAL(" #actual ","  #expected "," #count ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_NSTRING_NOT_EQUAL_FATAL(actual, expected, count)   { CU_assertImplementation((strncmp((const char*)(actual), (const char*)(expected), (size_t)(count))), __LINE__, ("CU_ASSERT_NSTRING_NOT_EQUAL_FATAL(" #actual ","  #expected "," #count ")"), __FILE__, "", CU_TRUE); }
N
N/** Asserts that double actual == expected within the specified tolerance.
N *  If actual is within granularity of expected, the assertion passes.
N *  Reports failure with no other action.
N */
N#define CU_ASSERT_DOUBLE_EQUAL(actual, expected, granularity) \
N  { CU_assertImplementation(((fabs((double)(actual) - (expected)) <= fabs((double)(granularity)))), __LINE__, ("CU_ASSERT_DOUBLE_EQUAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_DOUBLE_EQUAL(actual, expected, granularity)   { CU_assertImplementation(((fabs((double)(actual) - (expected)) <= fabs((double)(granularity)))), __LINE__, ("CU_ASSERT_DOUBLE_EQUAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", CU_FALSE); }
N
N/** Asserts that double actual == expected within the specified tolerance.
N *  If actual is within granularity of expected, the assertion passes.
N *  Reports failure and causes test to abort.
N */
N#define CU_ASSERT_DOUBLE_EQUAL_FATAL(actual, expected, granularity) \
N  { CU_assertImplementation(((fabs((double)(actual) - (expected)) <= fabs((double)(granularity)))), __LINE__, ("CU_ASSERT_DOUBLE_EQUAL_FATAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_DOUBLE_EQUAL_FATAL(actual, expected, granularity)   { CU_assertImplementation(((fabs((double)(actual) - (expected)) <= fabs((double)(granularity)))), __LINE__, ("CU_ASSERT_DOUBLE_EQUAL_FATAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", CU_TRUE); }
N
N/** Asserts that double actual != expected within the specified tolerance.
N *  If actual is within granularity of expected, the assertion fails.
N *  Reports failure with no other action.
N */
N#define CU_ASSERT_DOUBLE_NOT_EQUAL(actual, expected, granularity) \
N  { CU_assertImplementation(((fabs((double)(actual) - (expected)) > fabs((double)(granularity)))), __LINE__, ("CU_ASSERT_DOUBLE_NOT_EQUAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", CU_FALSE); }
X#define CU_ASSERT_DOUBLE_NOT_EQUAL(actual, expected, granularity)   { CU_assertImplementation(((fabs((double)(actual) - (expected)) > fabs((double)(granularity)))), __LINE__, ("CU_ASSERT_DOUBLE_NOT_EQUAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", CU_FALSE); }
N
N/** Asserts that double actual != expected within the specified tolerance.
N *  If actual is within granularity of expected, the assertion fails.
N *  Reports failure and causes test to abort.
N */
N#define CU_ASSERT_DOUBLE_NOT_EQUAL_FATAL(actual, expected, granularity) \
N  { CU_assertImplementation(((fabs((double)(actual) - (expected)) > fabs((double)(granularity)))), __LINE__, ("CU_ASSERT_DOUBLE_NOT_EQUAL_FATAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", CU_TRUE); }
X#define CU_ASSERT_DOUBLE_NOT_EQUAL_FATAL(actual, expected, granularity)   { CU_assertImplementation(((fabs((double)(actual) - (expected)) > fabs((double)(granularity)))), __LINE__, ("CU_ASSERT_DOUBLE_NOT_EQUAL_FATAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", CU_TRUE); }
N
N#ifdef USE_DEPRECATED_CUNIT_NAMES
S
S#ifndef BOOL
S  /** Deprecated (version 2.0-2). @deprecated Use CU_BOOL. */
S  #define BOOL int
S#endif
S
S#ifndef TRUE
S  /** Deprecated (version 2.0-2). @deprecated Use CU_TRUE. */
S  #define TRUE 1
S#endif
S
S#ifndef FALSE
S  /** Deprecated (version 2.0-2). @deprecated Use CU_FALSE. */
S  #define FALSE	0
S#endif
S
S/** Deprecated (version 2.0-2). @deprecated Use CU_MAX_TEST_NAME_LENGTH. */
S#define MAX_TEST_NAME_LENGTH	256
S/** Deprecated (version 2.0-2). @deprecated Use CU_MAX_SUITE_NAME_LENGTH. */
S#define MAX_SUITE_NAME_LENGTH	256
S
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_FATAL. */
S#define ASSERT(value) { if (FALSE == (int)(value)) { CU_assertImplementation((BOOL)value, __LINE__, #value, __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_TRUE_FATAL. */
S#define ASSERT_TRUE(value) { if (FALSE == (value)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_TRUE(" #value ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_FALSE_FATAL. */
S#define ASSERT_FALSE(value) { if (FALSE != (value)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_FALSE(" #value ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_EQUAL_FATAL. */
S#define ASSERT_EQUAL(actual, expected) { if ((actual) != (expected)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_EQUAL(" #actual "," #expected ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_NOT_EQUAL_FATAL. */
S#define ASSERT_NOT_EQUAL(actual, expected) { if ((void*)(actual) == (void*)(expected)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_NOT_EQUAL(" #actual "," #expected ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_PTR_EQUAL_FATAL. */
S#define ASSERT_PTR_EQUAL(actual, expected) { if ((void*)(actual) != (void*)(expected)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_PTR_EQUAL(" #actual "," #expected ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_PTR_NOT_EQUAL_FATAL. */
S#define ASSERT_PTR_NOT_EQUAL(actual, expected) { if ((void*)(actual) == (void*)(expected)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_PTR_NOT_EQUAL(" #actual "," #expected ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_PTR_NULL_FATAL. */
S#define ASSERT_PTR_NULL(value)  { if (NULL != (void*)(value)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_PTR_NULL(" #value")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_PTR_NOT_NULL_FATAL. */
S#define ASSERT_PTR_NOT_NULL(value) { if (NULL == (void*)(value)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_PTR_NOT_NULL(" #value")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_STRING_EQUAL_FATAL. */
S#define ASSERT_STRING_EQUAL(actual, expected) { if (strcmp((const char*)actual, (const char*)expected)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_STRING_EQUAL(" #actual ","  #expected ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_STRING_NOT_EQUAL_FATAL. */
S#define ASSERT_STRING_NOT_EQUAL(actual, expected) { if (!strcmp((const char*)actual, (const char*)expected)) { CU_assertImplementation(TRUE, __LINE__, ("ASSERT_STRING_NOT_EQUAL(" #actual ","  #expected ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_NSTRING_EQUAL_FATAL. */
S#define ASSERT_NSTRING_EQUAL(actual, expected, count) { if (strncmp((const char*)actual, (const char*)expected, (size_t)count)) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_NSTRING_EQUAL(" #actual ","  #expected "," #count ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_NSTRING_NOT_EQUAL_FATAL. */
S#define ASSERT_NSTRING_NOT_EQUAL(actual, expected, count) { if (!strncmp((const char*)actual, (const char*)expected, (size_t)count)) { CU_assertImplementation(TRUE, __LINE__, ("ASSERT_NSTRING_NOT_EQUAL(" #actual ","  #expected "," #count ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_DOUBLE_EQUAL_FATAL. */
S#define ASSERT_DOUBLE_EQUAL(actual, expected, granularity) { if ((fabs((double)actual - expected) > fabs((double)granularity))) { CU_assertImplementation(FALSE, __LINE__, ("ASSERT_DOUBLE_EQUAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", FALSE); return; }}
S/** Deprecated (version 1). @deprecated Use CU_ASSERT_DOUBLE_NOT_EQUAL_FATAL. */
S#define ASSERT_DOUBLE_NOT_EQUAL(actual, expected, granularity) { if ((fabs((double)actual - expected) <= fabs((double)granularity))) { CU_assertImplementation(TRUE, __LINE__, ("ASSERT_DOUBLE_NOT_EQUAL(" #actual ","  #expected "," #granularity ")"), __FILE__, "", FALSE); return; }}
N#endif  /* USE_DEPRECATED_CUNIT_NAMES */
N
N#endif  /*  CUNIT_CUNIT_H_SEEN  */
N
N/** @} */
L 46 "..\..\Middleware\ut_manager\Cunit\Sources\Basic\Basic.c" 2
N#include "TestDB.h"
N#include "Util.h"
L 1 "..\..\Middleware\ut_manager\Cunit\Headers\Util.h" 1
N/*
N *  CUnit - A Unit testing framework library for C.
N *  Copyright (C) 2001       Anil Kumar
N *  Copyright (C) 2004-2006  Anil Kumar, Jerry St.Clair
N *
N *  This library is free software; you can redistribute it and/or
N *  modify it under the terms of the GNU Library General Public
N *  License as published by the Free Software Foundation; either
N *  version 2 of the License, or (at your option) any later version.
N *
N *  This library is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
N *  Library General Public License for more details.
N *
N *  You should have received a copy of the GNU Library General Public
N *  License along with this library; if not, write to the Free Software
N *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
N */
N
N/*
N *  Contains Type Definitions for some generic functions used across
N *  CUnit project files.
N *
N *  13/Oct/2001   Moved some of the generic functions declarations from
N *                other files to this one so as to use the functions
N *                consitently. This file is not included in the distribution
N *                headers because it is used internally by CUnit. (AK)
N *
N *  20-Jul-2004   New interface, support for deprecated version 1 names. (JDS)
N *
N *  5-Sep-2004    Added internal test interface. (JDS)
N *
N *  17-Apr-2006   Added CU_translated_strlen() and CU_number_width().
N *                Removed CUNIT_MAX_STRING_LENGTH - dangerous since not enforced.
N *                Fixed off-by-1 error in CU_translate_special_characters(),
N *                modifying implementation & results in some cases.  User can
N *                now tell if conversion failed. (JDS)
N */
N
N/** @file
N *  Utility functions (user interface).
N */
N/** @addtogroup Framework
N * @{
N */
N
N#ifndef CUNIT_UTIL_H_SEEN
N#define CUNIT_UTIL_H_SEEN
N
N#include "CUnit.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define CUNIT_MAX_ENTITY_LEN 5
N/**< Maximum number of characters in a translated xml entity. */
N
NCU_EXPORT size_t CU_translate_special_characters(const char *szSrc, char *szDest, size_t maxlen);
X size_t CU_translate_special_characters(const char *szSrc, char *szDest, size_t maxlen);
N/**<
N *  Converts special characters in szSrc to xml entity codes and stores
N *  result in szDest.  Currently conversion of '&', '<', and '>' is supported.
N *  Note that conversion to entities increases the length of the converted
N *  string.  The greatest conversion size increase would be a string
N *  consisting entirely of entity characters of converted length
N *  CUNIT_MAX_ENTITY_LEN.  Neither szSrc nor szDest may be NULL
N *  (checked by assertion).<br /><br />
N *
N *  maxlen gives the maximum number of characters in the translated string.
N *  If szDest does not have enough room to hold the converted string, the
N *  return value will be zero and szDest will contain an empty string.
N *  If this occurs, the remaining characters in szDest may be overwritten
N *  in an unspecified manner.  It is the caller's responsibility to make
N *  sure there is sufficient room in szDest to hold the converted string.
N *  CU_translated_strlen() may be used to calculate the length of buffer
N *  required (remember to add 1 for the terminating \0).
N *
N *  @param szSrc  Source string to convert (non-NULL).
N *  @param szDest Location to hold the converted string (non-NULL).
N *  @param maxlen Maximum number of characters szDest can hold.
N *  @return   The number of special characters converted (always 0 if
N *            szDest did not have enough room to hold converted string).
N */
N
NCU_EXPORT size_t CU_translated_strlen(const char *szSrc);
X size_t CU_translated_strlen(const char *szSrc);
N/**<
N *  Calculates the length of a translated string.
N *  This function calculates the buffer length required to hold a string
N *  after processing with CU_translate_special_characters().  The returned
N *  length does not include space for the terminating '\0' character.
N *  szSrc may not be NULL (checked by assertion).
N *
N *  @param szSrc  Source string to analyze (non-NULL).
N *  @return The number of characters szSrc will expand to when converted.
N */
N
NCU_EXPORT int CU_compare_strings(const char *szSrc, const char *szDest);
X int CU_compare_strings(const char *szSrc, const char *szDest);
N/**<
N *  Case-insensitive string comparison.  Neither string pointer
N *  can be NULL (checked by assertion).
N *
N *  @param szSrc  1st string to compare (non-NULL).
N *  @param szDest 2nd string to compare (non-NULL).
N *  @return  0 if the strings are equal, non-zero otherwise.
N */
N
NCU_EXPORT void CU_trim_left(char *szString);
X void CU_trim_left(char *szString);
N/**<
N *  Trims leading whitespace from the specified string.
N *  @param szString  The string to trim.
N */
N
NCU_EXPORT void CU_trim_right(char *szString);
X void CU_trim_right(char *szString);
N/**<
N *  Trims trailing whitespace from the specified string.
N *  @param szString  The string to trim.
N */
N
NCU_EXPORT void CU_trim(char *szString);
X void CU_trim(char *szString);
N/**<
N *  Trims leading and trailing whitespace from the specified string.
N *  @param szString  The string to trim.
N */
N
NCU_EXPORT size_t CU_number_width(int number);
X size_t CU_number_width(int number);
N/**<
N *  Calulates the number of places required to display
N *  number in decimal.
N */
N
N#ifdef CUNIT_BUILD_TESTS
Svoid test_cunit_Util(void);
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#ifdef USE_DEPRECATED_CUNIT_NAMES
S#define CUNIT_MAX_STRING_LENGTH	1024
S/**< Maximum string length. */
S#define translate_special_characters(src, dest, len) CU_translate_special_characters(src, dest, len)
S/**< Deprecated (version 1). @deprecated Use CU_translate_special_characters(). */
S#define compare_strings(src, dest) CU_compare_strings(src, dest)
S/**< Deprecated (version 1). @deprecated Use CU_compare_strings(). */
S
S#define trim_left(str) CU_trim_left(str)
S/**< Deprecated (version 1). @deprecated Use CU_trim_left(). */
S#define trim_right(str) CU_trim_right(str)
S/**< Deprecated (version 1). @deprecated Use CU_trim_right(). */
S#define trim(str) CU_trim(str)
S/**< Deprecated (version 1). @deprecated Use CU_trim(). */
S
N#endif  /* USE_DEPRECATED_CUNIT_NAMES */
N
N#endif /* CUNIT_UTIL_H_SEEN */
N/** @} */
L 48 "..\..\Middleware\ut_manager\Cunit\Sources\Basic\Basic.c" 2
N#include "TestRun.h"
N#include "Basic.h"
L 1 "..\..\Middleware\ut_manager\Cunit\Headers\Basic.h" 1
N/*
N *  CUnit - A Unit testing framework library for C.
N *  Copyright (C) 2004-2006  Jerry St.Clair
N *
N *  This library is free software; you can redistribute it and/or
N *  modify it under the terms of the GNU Library General Public
N *  License as published by the Free Software Foundation; either
N *  version 2 of the License, or (at your option) any later version.
N *
N *  This library is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
N *  Library General Public License for more details.
N *
N *  You should have received a copy of the GNU Library General Public
N *  License along with this library; if not, write to the Free Software
N *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
N */
N
N/*
N *  Interface for simple test runner.
N *
N *  11-Aug-2004   Initial implementation of basic test runner interface. (JDS)
N */
N
N/** @file
N * Basic interface with output to stdout.
N */
N/** @addtogroup Basic
N * @{
N */
N
N#ifndef CUNIT_BASIC_H_SEEN
N#define CUNIT_BASIC_H_SEEN
N
N#include "CUnit.h"
N#include "TestDB.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** Run modes for the basic interface. */
Ntypedef enum {
N  CU_BRM_NORMAL = 0,  /**< Normal mode - failures and run summary are printed [default]. */
N  CU_BRM_SILENT,      /**< Silent mode - no output is printed except framework error messages. */
N  CU_BRM_VERBOSE      /**< Verbose mode - maximum output of run details. */
N} CU_BasicRunMode;
N
NCU_EXPORT CU_ErrorCode CU_basic_run_tests(void);
X CU_ErrorCode CU_basic_run_tests(void);
N/**<
N *  Runs all registered CUnit tests using the basic interface.
N *  The default CU_BasicRunMode is used unless it has been
N *  previously changed using CU_basic_set_mode().  The CUnit test
N *  registry must have been initialized before calling this function.
N *
N *  @return A CU_ErrorCode indicating the framework error condition, including
N *          CUE_NOREGISTRY - Registry has not been initialized.
N */
N
NCU_EXPORT CU_ErrorCode CU_basic_run_suite(CU_pSuite pSuite);
X CU_ErrorCode CU_basic_run_suite(CU_pSuite pSuite);
N/**<
N *  Runs all tests for a specific suite in the basic interface.
N *  If pSuite is NULL, the function returns without taking any
N *  action. The default CU_BasicRunMode is used unless it has
N *  been changed using CU_basic_set_mode().
N *
N *  @param pSuite The CU_Suite to run.
N *  @return A CU_ErrorCode indicating the framework error condition, including
N *          CUE_NOSUITE - pSuite was NULL.
N */
N
NCU_EXPORT CU_ErrorCode CU_basic_run_test(CU_pSuite pSuite, CU_pTest pTest);
X CU_ErrorCode CU_basic_run_test(CU_pSuite pSuite, CU_pTest pTest);
N/**<
N *  Runs a single test in a specific suite in the basic interface.
N *  If pSuite or pTest is NULL, the function returns without
N *  taking any action.  The default CU_BasicRunMode is used unless
N *  it has been changed using CU_basic_set_mode.
N *
N *  @param pSuite The CU_Suite holding the CU_Test to run.
N *  @param pTest  The CU_Test to run.
N *  @return A CU_ErrorCode indicating the framework error condition, including
N *          CUE_NOSUITE - pSuite was NULL.
N *          CUE_NOTEST  - pTest was NULL.
N */
N
NCU_EXPORT void CU_basic_set_mode(CU_BasicRunMode mode);
X void CU_basic_set_mode(CU_BasicRunMode mode);
N/**< Sets the run mode for the basic interface.
N *  @param mode The new CU_BasicRunMode for subsequent test
N *              runs using the basic interface.
N */
N
NCU_EXPORT CU_BasicRunMode CU_basic_get_mode(void);
X CU_BasicRunMode CU_basic_get_mode(void);
N/**< Retrieves the current run mode for the basic interface.
N *  @return The current CU_BasicRunMode setting for test
N *              runs using the basic interface.
N */
N
NCU_EXPORT void CU_basic_show_failures(CU_pFailureRecord pFailure);
X void CU_basic_show_failures(CU_pFailureRecord pFailure);
N/**<
N *  Prints a summary of run failures to stdout.
N *  This is provided for user convenience upon request, and does
N *  not take into account the current run mode.  The failures are
N *  printed to stdout independent of the most recent run mode.
N *
N *  @param pFailure List of CU_pFailureRecord's to output.
N */
N
N#ifdef __cplusplus
S}
N#endif
N#endif  /*  CUNIT_BASIC_H_SEEN  */
N/** @} */
L 50 "..\..\Middleware\ut_manager\Cunit\Sources\Basic\Basic.c" 2
N#include "CUnit_intl.h"
L 1 "..\..\Middleware\ut_manager\Cunit\Headers\CUnit_intl.h" 1
N/*
N *  CUnit - A Unit testing framework library for C.
N *  Copyright (C) 2006  Jerry St.Clair
N *
N *  This library is free software; you can redistribute it and/or
N *  modify it under the terms of the GNU Library General Public
N *  License as published by the Free Software Foundation; either
N *  version 2 of the License, or (at your option) any later version.
N *
N *  This library is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
N *  Library General Public License for more details.
N *
N *  You should have received a copy of the GNU Library General Public
N *  License along with this library; if not, write to the Free Software
N *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
N */
N
N/*
N *  Internationalization support
N *
N *  05-May-2006   Initial implementation.  (JDS)
N */
N
N/** @file
N *  Internal CUnit header supporting internationalization of
N *  CUnit framework & interfaces.
N */
N/** @addtogroup Framework
N * @{
N */
N
N#ifndef CUNIT_CUNIT_INTL_H_SEEN
N#define CUNIT_CUNIT_INTL_H_SEEN
N
N/* activate these when source preparation is complete
N#include <libintl.h>
N#ifndef _
N#  define _(String) gettext (String)
N#endif
N#ifndef gettext_noop
N#  define gettext_noop(String) String
N#endif
N#ifndef N_
N#  define N_(String) gettext_noop (String)
N#endif
N*/
N
N/* deactivate these when source preparation is complete */
N#undef _
N#define _(String) (String)
N#undef N_
N#define N_(String) String
N#undef textdomain
N#define textdomain(Domain)
N#undef bindtextdomain
N#define bindtextdomain(Package, Directory)
N
N#endif  /*  CUNIT_CUNIT_INTL_H_SEEN  */
N
N/** @} */
L 51 "..\..\Middleware\ut_manager\Cunit\Sources\Basic\Basic.c" 2
N
N/*=================================================================
N *  Global/Static Definitions
N *=================================================================*/
N/** Pointer to the currently running suite. */
Nstatic CU_pSuite f_pRunningSuite = NULL;
Xstatic CU_pSuite f_pRunningSuite = 0;
N/** Current run mode. */
Nstatic CU_BasicRunMode f_run_mode = CU_BRM_NORMAL;
N
N/*=================================================================
N *  Forward declaration of module functions *
N *=================================================================*/
Nstatic CU_ErrorCode basic_initialize(void);
Nstatic CU_ErrorCode basic_run_all_tests(CU_pTestRegistry pRegistry);
Nstatic CU_ErrorCode basic_run_suite(CU_pSuite pSuite);
Nstatic CU_ErrorCode basic_run_single_test(CU_pSuite pSuite, CU_pTest pTest);
N
Nstatic void basic_test_start_message_handler(const CU_pTest pTest, const CU_pSuite pSuite);
Nstatic void basic_test_complete_message_handler(const CU_pTest pTest, const CU_pSuite pSuite, const CU_pFailureRecord pFailureList);
Nstatic void basic_all_tests_complete_message_handler(const CU_pFailureRecord pFailure);
Nstatic void basic_suite_init_failure_message_handler(const CU_pSuite pSuite);
Nstatic void basic_suite_cleanup_failure_message_handler(const CU_pSuite pSuite);
N
N/*=================================================================
N *  Public Interface functions
N *=================================================================*/
NCU_ErrorCode CU_basic_run_tests(void)
N{
N  CU_ErrorCode error;
N
N  if (NULL == CU_get_registry()) {
X  if (0 == CU_get_registry()) {
N    if (CU_BRM_SILENT != f_run_mode) 
N	{
N#ifdef __CUNIT_USE_FILE_SYSTEM__
S      fprintf(stderr, );
N#else
N	  printf("\n\n%s\n", _("FATAL ERROR - Test registry is not initialized."));
X	  printf("\n\n%s\n", ("FATAL ERROR - Test registry is not initialized."));
N#endif
N	}
N    error = CUE_NOREGISTRY;
N  }
N  else if (CUE_SUCCESS == (error = basic_initialize()))
N    error = basic_run_all_tests(NULL);
X    error = basic_run_all_tests(0);
N
N  return error;
N}
N
N/*------------------------------------------------------------------------*/
NCU_ErrorCode CU_basic_run_suite(CU_pSuite pSuite)
N{
N  CU_ErrorCode error;
N
N  if (NULL == pSuite)
X  if (0 == pSuite)
N    error = CUE_NOSUITE;
N  else if (CUE_SUCCESS == (error = basic_initialize()))
N    error = basic_run_suite(pSuite);
N
N  return error;
N}
N
N/*------------------------------------------------------------------------*/
NCU_ErrorCode CU_basic_run_test(CU_pSuite pSuite, CU_pTest pTest)
N{
N  CU_ErrorCode error;
N
N  if (NULL == pSuite)
X  if (0 == pSuite)
N    error = CUE_NOSUITE;
N  else if (NULL == pTest)
X  else if (0 == pTest)
N    error = CUE_NOTEST;
N  else if (CUE_SUCCESS == (error = basic_initialize()))
N    error = basic_run_single_test(pSuite, pTest);
N
N  return error;
N}
N
N/*------------------------------------------------------------------------*/
Nvoid CU_basic_set_mode(CU_BasicRunMode mode)
N{
N  f_run_mode = mode;
N}
N
N/*------------------------------------------------------------------------*/
NCU_BasicRunMode CU_basic_get_mode(void)
N{
N  return f_run_mode;
N}
N
N/*------------------------------------------------------------------------*/
Nvoid CU_basic_show_failures(CU_pFailureRecord pFailure)
N{
N  int i;
N
N  for (i = 1 ; (NULL != pFailure) ; pFailure = pFailure->pNext, i++) {
X  for (i = 1 ; (0 != pFailure) ; pFailure = pFailure->pNext, i++) {
N#ifdef __CUNIT_USE_FILE_SYSTEM__
S    fprintf(stdout, "\n  %d. %s:%u  - %s", i,
S        (NULL != pFailure->strFileName) ? pFailure->strFileName : "",
S        pFailure->uiLineNumber,
S        (NULL != pFailure->strCondition) ? pFailure->strCondition : "");
N#else
N    printf( "\n  %d. %s:%u  - %s", i,
N        (NULL != pFailure->strFileName) ? pFailure->strFileName : "",
X        (0 != pFailure->strFileName) ? pFailure->strFileName : "",
N        pFailure->uiLineNumber,
N        (NULL != pFailure->strCondition) ? pFailure->strCondition : "");
X        (0 != pFailure->strCondition) ? pFailure->strCondition : "");
N#endif
N  }
N}
N
N/*=================================================================
N *  Static module functions
N *=================================================================*/
N/** Performs inialization actions for the basic interface.
N *  This includes setting output to unbuffered, printing a
N *  welcome message, and setting the test run handlers.
N *  @return An error code indicating the framework error condition.
N */
Nstatic CU_ErrorCode basic_initialize(void)
N{
N  /* Unbuffered output so everything reaches the screen */
N  setvbuf(stdout, NULL, _IONBF, 0);
X  setvbuf((& __stdout), 0, 0x400, 0);
N  setvbuf(stderr, NULL, _IONBF, 0);
X  setvbuf((& __stderr), 0, 0x400, 0);
N
N  CU_set_error(CUE_SUCCESS);
N
N  if (CU_BRM_SILENT != f_run_mode)
N#ifdef __CUNIT_USE_FILE_SYSTEM__
S    fprintf(stdout, "\n\n     %s" CU_VERSION
S                      "\n     %s\n\n",
S                    _("CUnit - A unit testing framework for C - Version "),
S                    _("http://cunit.sourceforge.net/"));
N#else
N    printf("\n\n     %s" CU_VERSION
X    printf("\n\n     %s" "@VERSION@-@RELEASE@"
N                      "\n     %s\n\n",
N                    _("CUnit - A unit testing framework for C - Version "),
X                    ("CUnit - A unit testing framework for C - Version "),
N                    _("http://cunit.sourceforge.net/"));
X                    ("http://cunit.sourceforge.net/"));
N#endif
N  CU_set_test_start_handler(basic_test_start_message_handler);
N  CU_set_test_complete_handler(basic_test_complete_message_handler);
N  CU_set_all_test_complete_handler(basic_all_tests_complete_message_handler);
N  CU_set_suite_init_failure_handler(basic_suite_init_failure_message_handler);
N  CU_set_suite_cleanup_failure_handler(basic_suite_cleanup_failure_message_handler);
N
N  return CU_get_error();
N}
N
N/*------------------------------------------------------------------------*/
N/** Runs all tests within the basic interface.
N *  If non-NULL, the test registry is changed to the specified registry
N *  before running the tests, and reset to the original registry when
N *  done.  If NULL, the default CUnit test registry will be used.
N *  @param pRegistry The CU_pTestRegistry containing the tests
N *                   to be run.  If NULL, use the default registry.
N *  @return An error code indicating the error status
N *          during the test run.
N */
Nstatic CU_ErrorCode basic_run_all_tests(CU_pTestRegistry pRegistry)
N{
N  CU_pTestRegistry pOldRegistry = NULL;
X  CU_pTestRegistry pOldRegistry = 0;
N  CU_ErrorCode result;
N
N  f_pRunningSuite = NULL;
X  f_pRunningSuite = 0;
N
N  if (NULL != pRegistry)
X  if (0 != pRegistry)
N    pOldRegistry = CU_set_registry(pRegistry);
N  result = CU_run_all_tests();
N  if (NULL != pRegistry)
X  if (0 != pRegistry)
N    CU_set_registry(pOldRegistry);
N  return result;
N}
N
N/*------------------------------------------------------------------------*/
N/** Runs a specified suite within the basic interface.
N *  @param pSuite The suite to be run (non-NULL).
N *  @return An error code indicating the error status
N *          during the test run.
N */
Nstatic CU_ErrorCode basic_run_suite(CU_pSuite pSuite)
N{
N  f_pRunningSuite = NULL;
X  f_pRunningSuite = 0;
N  return CU_run_suite(pSuite);
N}
N
N/*------------------------------------------------------------------------*/
N/** Runs a single test for the specified suite within
N *  the console interface.
N *  @param pSuite The suite containing the test to be run (non-NULL).
N *  @param pTest  The test to be run (non-NULL).
N *  @return An error code indicating the error status
N *          during the test run.
N */
Nstatic CU_ErrorCode basic_run_single_test(CU_pSuite pSuite, CU_pTest pTest)
N{
N  f_pRunningSuite = NULL;
X  f_pRunningSuite = 0;
N  return CU_run_test(pSuite, pTest);
N}
N
N/*------------------------------------------------------------------------*/
N/** Handler function called at start of each test.
N *  @param pTest  The test being run.
N *  @param pSuite The suite containing the test.
N */
Nstatic void basic_test_start_message_handler(const CU_pTest pTest, const CU_pSuite pSuite)
N{
N  assert(NULL != pSuite);
X  ((void)0);
N  assert(NULL != pTest);
X  ((void)0);
N
N  if (CU_BRM_VERBOSE == f_run_mode) {
N    assert(NULL != pTest->pName);
X    ((void)0);
N    if ((NULL == f_pRunningSuite) || (f_pRunningSuite != pSuite)) {
X    if ((0 == f_pRunningSuite) || (f_pRunningSuite != pSuite)) {
N      assert(NULL != pSuite->pName);
X      ((void)0);
N#ifdef __CUNIT_USE_FILE_SYSTEM__
S      fprintf(stdout, "\n%s: %s", _("Suite"), pSuite->pName);
S      fprintf(stdout, "\n  %s: %s ...", _("Test"), pTest->pName);
N#else
N	  printf("\n%s: %s", _("Suite"), pSuite->pName);
X	  printf("\n%s: %s", ("Suite"), pSuite->pName);
N      printf("\n  %s: %s ...", _("Test"), pTest->pName);	
X      printf("\n  %s: %s ...", ("Test"), pTest->pName);	
N#endif
N      f_pRunningSuite = pSuite;
N    }
N    else {
N#ifdef __CUNIT_USE_FILE_SYSTEM__
S      fprintf(stdout, "\n  %s: %s ...", _("Test"), pTest->pName);
N#else	
N      printf("\n  %s: %s ...", _("Test"), pTest->pName);	
X      printf("\n  %s: %s ...", ("Test"), pTest->pName);	
N#endif
N    }
N  }
N}
N
N/*------------------------------------------------------------------------*/
N/** Handler function called at completion of each test.
N *  @param pTest   The test being run.
N *  @param pSuite  The suite containing the test.
N *  @param pFailure Pointer to the 1st failure record for this test.
N */
Nstatic void basic_test_complete_message_handler(const CU_pTest pTest,
N                                                const CU_pSuite pSuite,
N                                                const CU_pFailureRecord pFailureList)
N{
N  CU_pFailureRecord pFailure = pFailureList;
N  int i;
N
N  assert(NULL != pSuite);
X  ((void)0);
N  assert(NULL != pTest);
X  ((void)0);
N
N  if (NULL == pFailure) {
X  if (0 == pFailure) {
N    if (CU_BRM_VERBOSE == f_run_mode) {
N#ifdef __CUNIT_USE_FILE_SYSTEM__
S      fprintf(stdout, _("passed"));
N#else
N	  printf(_("passed"));	
X	  printf(("passed"));	
N#endif
N    }
N  }
N  else {
N    switch (f_run_mode) {
N      case CU_BRM_VERBOSE:
N#ifdef __CUNIT_USE_FILE_SYSTEM__
S      fprintf(stdout, _("FAILED"));
N#else
N	  printf(_("FAILED"));	
X	  printf(("FAILED"));	
N#endif
N        break;
N      case CU_BRM_NORMAL:
N        assert(NULL != pSuite->pName);
X        ((void)0);
N        assert(NULL != pTest->pName);     
X        ((void)0);     
N#ifdef __CUNIT_USE_FILE_SYSTEM__
S	    fprintf(stdout, _("\nSuite %s, Test %s had failures:"), pSuite->pName, pTest->pName);
N#else
N		printf(_("\nSuite %s, Test %s had failures:"), pSuite->pName, pTest->pName);
X		printf(("\nSuite %s, Test %s had failures:"), pSuite->pName, pTest->pName);
N#endif	  
N        break;
N      default:  /* gcc wants all enums covered.  ok. */
N        break;
N    }
N    if (CU_BRM_SILENT != f_run_mode) {
N      for (i = 1 ; (NULL != pFailure) ; pFailure = pFailure->pNext, i++) {
X      for (i = 1 ; (0 != pFailure) ; pFailure = pFailure->pNext, i++) {
N#ifdef __CUNIT_USE_FILE_SYSTEM__
S        fprintf(stdout, "\n    %d. %s:%u  - %s", i,
S            (NULL != pFailure->strFileName) ? pFailure->strFileName : "",
S            pFailure->uiLineNumber,
S            (NULL != pFailure->strCondition) ? pFailure->strCondition : "");
N#else
N		printf("\n    %d. %s:%u  - %s", i,
N			(NULL != pFailure->strFileName) ? pFailure->strFileName : "",
X			(0 != pFailure->strFileName) ? pFailure->strFileName : "",
N			pFailure->uiLineNumber,
N			(NULL != pFailure->strCondition) ? pFailure->strCondition : ""); 
X			(0 != pFailure->strCondition) ? pFailure->strCondition : ""); 
N#endif
N      }
N    }
N  }
N}
N
N/*------------------------------------------------------------------------*/
N/** Handler function called at completion of all tests in a suite.
N *  @param pFailure Pointer to the test failure record list.
N */
Nstatic void basic_all_tests_complete_message_handler(const CU_pFailureRecord pFailure)
N{
N  CU_UNREFERENCED_PARAMETER(pFailure); /* not used in basic interface */
X  (void)pFailure;  
N  printf("\n\n");
N  CU_print_run_results(stdout);
X  CU_print_run_results((& __stdout));
N  printf("\n");
N}
N
N/*------------------------------------------------------------------------*/
N/** Handler function called when suite initialization fails.
N *  @param pSuite The suite for which initialization failed.
N */
Nstatic void basic_suite_init_failure_message_handler(const CU_pSuite pSuite)
N{
N  assert(NULL != pSuite);
X  ((void)0);
N  assert(NULL != pSuite->pName);
X  ((void)0);
N
N  if (CU_BRM_SILENT != f_run_mode)
N#ifdef __CUNIT_USE_FILE_SYSTEM__
S    fprintf(stdout, _("\nWARNING - Suite initialization failed for '%s'."), pSuite->pName);
N#else
N	printf(_("\nWARNING - Suite initialization failed for '%s'."), pSuite->pName);
X	printf(("\nWARNING - Suite initialization failed for '%s'."), pSuite->pName);
N#endif
N}
N
N/*------------------------------------------------------------------------*/
N/** Handler function called when suite cleanup fails.
N *  @param pSuite The suite for which cleanup failed.
N */
Nstatic void basic_suite_cleanup_failure_message_handler(const CU_pSuite pSuite)
N{
N  assert(NULL != pSuite);
X  ((void)0);
N  assert(NULL != pSuite->pName);
X  ((void)0);
N
N  if (CU_BRM_SILENT != f_run_mode)
N#ifdef __CUNIT_USE_FILE_SYSTEM__
S    fprintf(stdout, _("\nWARNING - Suite cleanup failed for '%s'."), pSuite->pName);
N#else
N	printf(_("\nWARNING - Suite cleanup failed for '%s'."), pSuite->pName);
X	printf(("\nWARNING - Suite cleanup failed for '%s'."), pSuite->pName);
N#endif
N}
N
N/** @} */
