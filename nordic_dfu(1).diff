diff --git a/example/nordic_dfu/nrf_dfu.c b/example/nordic_dfu/nrf_dfu.c
index c03ad0b9f..3b39fac55 100644
--- a/example/nordic_dfu/nrf_dfu.c
+++ b/example/nordic_dfu/nrf_dfu.c
@@ -42,37 +42,14 @@
 #include "nrf_dfu_utils.h"
 #include "nrf_dfu_transport.h"
 #include "nrf_dfu_req_handler.h"
+#include "nrf_dfu_ble.h"
 #include "nrf_log.h"
 
-static nrf_dfu_observer_t m_user_observer;                          //<! Observer callback set by the user.
-
-
-
-/**
- * @brief This function calls the user's observer (@ref m_observer) after it is done handling the event.
- */
-static void dfu_observer(nrf_dfu_evt_type_t event)
-{
-    switch (event)
-    {
-        case NRF_DFU_EVT_DFU_COMPLETED:
-        case NRF_DFU_EVT_DFU_ABORTED:
-#ifndef NRF_DFU_NO_TRANSPORT
-            UNUSED_RETURN_VALUE(nrf_dfu_transports_close(NULL));
-#endif
-            break;
-        default:
-            break;
-    }
-
-    /* Call user's observer if present. */
-    if (m_user_observer)
-    {
-        m_user_observer(event);
-    }
-}
-
-
+static nrf_dfu_observer_t m_user_observer; //<! Observer callback set by the user.
+static nrf_dfu_transport_t m_dfu_tran = {
+    .init_func = nrf_dfu_ble_init,
+    .close_func = NULL,
+};
 
 uint32_t nrf_dfu_init(nrf_dfu_observer_t observer)
 {
@@ -80,19 +57,17 @@ uint32_t nrf_dfu_init(nrf_dfu_observer_t observer)
 
     m_user_observer = observer;
 
-    NRF_LOG_INFO("Entering DFU mode.");
+    NRF_LOG_INFO("Entering DFU mode in application.");
 
-    dfu_observer(NRF_DFU_EVT_DFU_INITIALIZED);
+    m_user_observer(NRF_DFU_EVT_DFU_INITIALIZED, NULL, 0);
 
     // Initializing transports
-    ret_val = nrf_dfu_transports_init(dfu_observer);
+    ret_val = nrf_dfu_transports_init(observer, &m_dfu_tran);
     if (ret_val != NRF_SUCCESS)
     {
         NRF_LOG_ERROR("Could not initalize DFU transport: 0x%08x", ret_val);
         return ret_val;
     }
 
-    ret_val = nrf_dfu_req_handler_init(dfu_observer);
-
-    return ret_val;
+    return nrf_dfu_req_handler_init(observer);
 }
diff --git a/example/nordic_dfu/nrf_dfu_ble.c b/example/nordic_dfu/nrf_dfu_ble.c
index d18aa4431..c6903484a 100644
--- a/example/nordic_dfu/nrf_dfu_ble.c
+++ b/example/nordic_dfu/nrf_dfu_ble.c
@@ -60,6 +60,7 @@
 #include "nrf_dfu_req_handler.h"
 #include "nrf_dfu_handling_error.h"
 #include "nrf_assert.h"
+#include "nrf_dfu_validation.h"
 
 typedef struct {
 	uint16_t att_handle;
@@ -77,7 +78,7 @@ typedef struct {
 	uint32_t size;
 } nrf_dfu_indicate_request_context_t;
 
-static nrf_dfu_ble_packet_handler_t dfu_packet_handler;
+static nrf_dfu_observer_t m_dfu_observer;
 static att_service_handler_t  nrf_dfu_service;
 static btstack_context_callback_registration_t send_request;
 
@@ -136,17 +137,39 @@ static int nrf_dfu_ble_write_callback(hci_con_handle_t con_handle, uint16_t attr
 	return 0;
 }
 
+/** 
+ * @brief Queue send request. When called, one packet can be send via nrf_dfu_ble_send below
+ * @param request
+ * @param con_handle
+ */
+static void nrf_dfu_ble_notify_request(void (*cb)(void *context), void *context, hci_con_handle_t con_handle) {
+	send_request.callback = cb;
+	send_request.context = context;
+	att_server_request_to_send_notification(&send_request, con_handle);
+}
+
+/** 
+ * @brief Queue send request. When called, one packet can be send via nrf_dfu_ble_send below
+ * @param request
+ * @param con_handle
+ */
+static void nrf_dfu_ble_indicate_request(void (*cb)(void *context), void *context, hci_con_handle_t con_handle) {
+	send_request.callback = cb;
+	send_request.context = context;
+	att_server_request_to_send_indication(&send_request, con_handle);
+}
+
 /**
  * @brief Init nrf DFU Service Server with ATT DB
  * @param callback for events and data from dfu controller
  */
-void nrf_dfu_ble_init(nrf_dfu_ble_packet_handler_t packet_handler) {
+uint32_t nrf_dfu_ble_init(nrf_dfu_observer_t observer) {
 	static const uint16_t dfu_profile_uuid16      = 0xFE59;
 	static const uint8_t dfu_ctrl_point_uuid128[] = { 0x8E, 0xC9, 0x00, 0x01, 0xF3, 0x15, 0x4F, 0x60, 0x9F, 0xB8, 0x83, 0x88, 0x30, 0xDA, 0xEA, 0x50 };
 	static const uint8_t dfU_data_point_uuid128[] = { 0x8E, 0xC9, 0x00, 0x02, 0xF3, 0x15, 0x4F, 0x60, 0x9F, 0xB8, 0x83, 0x88, 0x30, 0xDA, 0xEA, 0x50 };
 	static const uint8_t dfu_buttonless_uuid128[] = { 0x8E, 0xC9, 0x00, 0x03, 0xF3, 0x15, 0x4F, 0x60, 0x9F, 0xB8, 0x83, 0x88, 0x30, 0xDA, 0xEA, 0x50 };
 
-	dfu_packet_handler = packet_handler;
+	m_dfu_observer = observer;
 
 	// get service handle range
 	uint16_t start_handle = 0;
@@ -174,28 +197,8 @@ void nrf_dfu_ble_init(nrf_dfu_ble_packet_handler_t packet_handler) {
 	nrf_dfu_service.read_callback  = &nrf_dfu_ble_read_callback;
 	nrf_dfu_service.write_callback = &nrf_dfu_ble_write_callback;
 	att_server_register_service_handler(&nrf_dfu_service);
-}
 
-/** 
- * @brief Queue send request. When called, one packet can be send via nrf_dfu_ble_send below
- * @param request
- * @param con_handle
- */
-void nrf_dfu_ble_notify_request(void (*cb)(void *context), void *context, hci_con_handle_t con_handle) {
-	send_request.callback = cb;
-	send_request.context = context;
-	att_server_request_to_send_notification(&send_request, con_handle);
-}
-
-/** 
- * @brief Queue send request. When called, one packet can be send via nrf_dfu_ble_send below
- * @param request
- * @param con_handle
- */
-void nrf_dfu_ble_indicate_request(void (*cb)(void *context), void *context, hci_con_handle_t con_handle) {
-	send_request.callback = cb;
-	send_request.context = context;
-	att_server_request_to_send_indication(&send_request, con_handle);
+    return NRF_SUCCESS;
 }
 
 /**@brief Function for encoding the beginning of a response.
@@ -277,6 +280,7 @@ static void nrf_dfu_req_response_send_cb(void *context) {
 	if (req_context->is_notify_en)
 		att_server_notify(req_context->con_handle, req_context->att_handle, req_context->data, req_context->size);
 
+    NRF_LOG_DEBUG("Freeing req context:%p", req_context);
     free((void *)req_context);
 }
 
@@ -472,11 +476,12 @@ static void nrf_dfu_buttonless_response_send_cb(void *context) {
     if (req_context->is_indicate_en) {
         att_server_indicate(req_context->con_handle, req_context->att_handle, req_context->data, req_context->size);
         if (req_context->data[1] == NRF_DFU_BUT_CMD_CHANGE_BOOTLOADER_NAME) {
-            dfu_packet_handler(NRF_DFU_EVT_CHANGE_BOOTLOADER_NAME, dfu_buttonless_bootloader_name, sizeof(dfu_buttonless_bootloader_name));
+            m_dfu_observer(NRF_DFU_EVT_CHANGE_BOOTLOADER_NAME, dfu_buttonless_bootloader_name, sizeof(dfu_buttonless_bootloader_name));
         } else if (req_context->data[1] == NRF_DFU_BUT_CMD_ENTR_BOOTLOADER) {
-            dfu_packet_handler(NRF_DFU_EVT_ENTER_BOOTLOADER_MODE, NULL, 0);
+            m_dfu_observer(NRF_DFU_EVT_ENTER_BOOTLOADER_MODE, NULL, 0);
         }
     }
+    NRF_LOG_DEBUG("Freeing req context:%p", req_context);
     free((void *)req_context);
 }
 
diff --git a/example/nordic_dfu/nrf_dfu_ble.h b/example/nordic_dfu/nrf_dfu_ble.h
index 80189b57b..7983d5f0a 100644
--- a/example/nordic_dfu/nrf_dfu_ble.h
+++ b/example/nordic_dfu/nrf_dfu_ble.h
@@ -46,7 +46,7 @@
 #include <stdint.h>
 #include "bluetooth.h"
 #include "btstack_defines.h"
-
+#include "nrf_dfu_types.h"
 #if defined __cplusplus
 extern "C" {
 #endif
@@ -60,13 +60,6 @@ extern "C" {
 
 #define NRF_DFU_BUTTONLESS_RSP     0x20
 
-typedef enum {
-    NRF_DFU_EVT_CHANGE_BOOTLOADER_NAME = 0,
-    NRF_DFU_EVT_ENTER_BOOTLOADER_MODE
-} nrf_dfu_ble_evt_t;
-
-typedef void (*nrf_dfu_ble_packet_handler_t)(nrf_dfu_ble_evt_t evt, uint8_t *packet, uint16_t size);
-
 typedef enum {
     NRF_DFU_BUT_CMD_ENTR_BOOTLOADER = 0x01,
     NRF_DFU_BUT_CMD_CHANGE_BOOTLOADER_NAME = 0x02
@@ -105,9 +98,7 @@ typedef struct {
  * @brief Init NRF DFU Service Server with ATT DB
  * @param packet_handler for events and data from dfu controller
  */
-void nrf_dfu_ble_init(nrf_dfu_ble_packet_handler_t packet_handler);
-
-
+uint32_t nrf_dfu_ble_init(nrf_dfu_observer_t observer);
 
 /* API_END */
 
diff --git a/example/nordic_dfu/nrf_dfu_req_handler.c b/example/nordic_dfu/nrf_dfu_req_handler.c
index 68d606a63..cc61d55a0 100644
--- a/example/nordic_dfu/nrf_dfu_req_handler.c
+++ b/example/nordic_dfu/nrf_dfu_req_handler.c
@@ -74,18 +74,16 @@
 static uint32_t m_firmware_start_addr;          /**< Start address of the current firmware image. */
 static uint32_t m_firmware_size_req;            /**< The size of the entire firmware image. Defined by the init command. */
 
-//static nrf_dfu_observer_t m_observer;
+static nrf_dfu_observer_t m_observer;
 
-#if 0
-static void on_dfu_complete(nrf_fstorage_evt_t * p_evt)
+static void on_dfu_complete(void * p_evt)
 {
     UNUSED_PARAMETER(p_evt);
 
     NRF_LOG_DEBUG("All flash operations have completed. DFU completed.");
 
-    m_observer(NRF_DFU_EVT_DFU_COMPLETED);
+    m_observer(NRF_DFU_EVT_DFU_COMPLETED, 0,.0);
 }
-#endif
 
 static nrf_dfu_result_t ext_err_code_handle(nrf_dfu_result_t ret_val)
 {
@@ -229,7 +227,7 @@ static void on_abort_request(nrf_dfu_request_t * p_req, nrf_dfu_response_t * p_r
     UNUSED_PARAMETER(p_res);
     NRF_LOG_DEBUG("Handle NRF_DFU_OP_ABORT");
 
-    //m_observer(NRF_DFU_EVT_DFU_ABORTED);
+    m_observer(NRF_DFU_EVT_DFU_ABORTED, 0, 0);
 }
 
 
@@ -261,12 +259,10 @@ static void on_cmd_obj_create_request(nrf_dfu_request_t * p_req, nrf_dfu_respons
 
     NRF_LOG_DEBUG("Handle NRF_DFU_OP_OBJECT_CREATE (command)");
 
-    //m_observer(NRF_DFU_EVT_DFU_STARTED);
+    m_observer(NRF_DFU_EVT_DFU_STARTED, 0, 0);
 
     nrf_dfu_result_t ret_val = NRF_DFU_RES_CODE_SUCCESS;
-#ifdef NRF_DFU_VALIDATION
     ret_val = nrf_dfu_validation_init_cmd_create(p_req->create.object_size);
-#endif
     p_res->result = ext_err_code_handle(ret_val);
 }
 
@@ -282,9 +278,7 @@ static void on_cmd_obj_write_request(nrf_dfu_request_t * p_req, nrf_dfu_response
 
     nrf_dfu_result_t ret_val;
 
-#ifdef NRF_DFU_VALIDATION
     ret_val = nrf_dfu_validation_init_cmd_append(p_req->write.p_data, p_req->write.len);
-#endif
     p_res->result = ext_err_code_handle(ret_val);
 
     /* Update response. This is only used when the PRN is triggered and the 'write' message
@@ -306,8 +300,8 @@ static void on_cmd_obj_execute_request(nrf_dfu_request_t const * p_req, nrf_dfu_
 
     NRF_LOG_DEBUG("Handle NRF_DFU_OP_OBJECT_EXECUTE (command)");
 
-    nrf_dfu_result_t ret_val;
-#ifdef NRF_DFU_VALIDATION
+    nrf_dfu_result_t ret_val = NRF_DFU_RES_CODE_SUCCESS;
+#if NRF_DFU_VALIDATION_EN
     ret_val = nrf_dfu_validation_init_cmd_execute(&m_firmware_start_addr, &m_firmware_size_req);
 #endif
     p_res->result = ext_err_code_handle(ret_val);
@@ -405,7 +399,7 @@ static void on_data_obj_create_request(nrf_dfu_request_t * p_req, nrf_dfu_respon
 {
     NRF_LOG_DEBUG("Handle NRF_DFU_OP_OBJECT_CREATE (data)");
 
-#ifdef NRF_DFU_VALIDATION
+#if NRF_DFU_VALIDATION_EN
     if (!nrf_dfu_validation_init_cmd_present())
     {
         /* Can't accept data because DFU isn't initialized by init command. */
@@ -456,7 +450,7 @@ static void on_data_obj_create_request(nrf_dfu_request_t * p_req, nrf_dfu_respon
     s_dfu_settings.progress.firmware_image_offset = s_dfu_settings.progress.firmware_image_offset_last;
     s_dfu_settings.write_offset                   = s_dfu_settings.progress.firmware_image_offset_last;
 
-#ifdef NRF_DFU_FLASH
+#ifdef NRF_DFU_FLASH_EN
     /* Erase the page we're at. */
     if (nrf_dfu_flash_erase((m_firmware_start_addr + s_dfu_settings.progress.firmware_image_offset),
                             CEIL_DIV(p_req->create.object_size, CODE_PAGE_SIZE), NULL) != NRF_SUCCESS)
@@ -477,7 +471,7 @@ static void on_data_obj_write_request(nrf_dfu_request_t * p_req, nrf_dfu_respons
 {
     NRF_LOG_DEBUG("Handle NRF_DFU_OP_OBJECT_WRITE (data)");
 
-#ifdef NRF_DFU_VALIDATION
+#if NRF_DFU_VALIDATION_EN
     if (!nrf_dfu_validation_init_cmd_present())
     {
         /* Can't accept data because DFU isn't initialized by init command. */
@@ -506,7 +500,7 @@ static void on_data_obj_write_request(nrf_dfu_request_t * p_req, nrf_dfu_respons
 
     ASSERT(p_req->callback.write);
 
-#ifdef NRF_DFU_FLASH
+#ifdef NRF_DFU_FLASH_EN
     ret_code_t ret =
         nrf_dfu_flash_store(write_addr, p_req->write.p_data, p_req->write.len, p_req->callback.write);
     if (ret != NRF_SUCCESS)
@@ -543,7 +537,6 @@ static void on_data_obj_crc_request(nrf_dfu_request_t * p_req, nrf_dfu_response_
     p_res->crc.offset = s_dfu_settings.progress.firmware_image_offset;
 }
 
-#if 0
 static void on_data_obj_execute_request_sched(void * p_evt, uint16_t event_length)
 {
     UNUSED_PARAMETER(event_length);
@@ -551,6 +544,7 @@ static void on_data_obj_execute_request_sched(void * p_evt, uint16_t event_lengt
     ret_code_t          ret;
     nrf_dfu_request_t * p_req = (nrf_dfu_request_t *)(p_evt);
 
+#if 0
     /* Wait for all buffers to be written in flash. */
     if (nrf_fstorage_is_busy(NULL))
     {
@@ -561,7 +555,7 @@ static void on_data_obj_execute_request_sched(void * p_evt, uint16_t event_lengt
         }
         return;
     }
-
+#endif
     nrf_dfu_response_t res =
     {
         .request = NRF_DFU_OP_OBJECT_EXECUTE,
@@ -602,7 +596,6 @@ static void on_data_obj_execute_request_sched(void * p_evt, uint16_t event_lengt
 
     NRF_LOG_DEBUG("Request handling complete. Result: 0x%x", res.result);
 }
-#endif
 
 static bool on_data_obj_execute_request(nrf_dfu_request_t * p_req, nrf_dfu_response_t * p_res)
 {
@@ -627,11 +620,8 @@ static bool on_data_obj_execute_request(nrf_dfu_request_t * p_req, nrf_dfu_respo
     s_dfu_settings.progress.firmware_image_crc_last    = s_dfu_settings.progress.firmware_image_crc;
     s_dfu_settings.progress.firmware_image_offset_last = s_dfu_settings.progress.firmware_image_offset;
 
-#if 0
     on_data_obj_execute_request_sched(p_req, 0);
-
-    //m_observer(NRF_DFU_EVT_OBJECT_RECEIVED);
-#endif
+    m_observer(NRF_DFU_EVT_OBJECT_RECEIVED, 0, 0);
     return false;
 }
 
@@ -803,53 +793,37 @@ static void nrf_dfu_req_handler_req_process(nrf_dfu_request_t * p_req)
 
         if (response.result != NRF_DFU_RES_CODE_SUCCESS)
         {
-            //m_observer(NRF_DFU_EVT_DFU_FAILED);
+            m_observer(NRF_DFU_EVT_DFU_FAILED, 0, 0);
         }
     }
 }
 
-
-static void nrf_dfu_req_handler_req(void * p_evt, uint16_t event_length)
-{
-    nrf_dfu_request_t * p_req = (nrf_dfu_request_t *)(p_evt);
-    nrf_dfu_req_handler_req_process(p_req);
-}
-
-
 ret_code_t nrf_dfu_req_handler_on_req(nrf_dfu_request_t * p_req)
 {
-    ret_code_t ret = 0;
-
     if (p_req->callback.response == NULL)
     {
         return NRF_ERROR_INVALID_PARAM;
     }
     nrf_dfu_req_handler_req_process(p_req);
-#if 0
-    ret = app_sched_event_put(p_req, sizeof(nrf_dfu_request_t), nrf_dfu_req_handler_req);
-    if (ret != NRF_SUCCESS)
-    {
-        NRF_LOG_WARNING("Scheduler ran out of space!");
-    }
-#endif
-    return ret;
-}
 
+    return NRF_SUCCESS;
+}
 
 ret_code_t nrf_dfu_req_handler_init(nrf_dfu_observer_t observer)
 {
-    ret_code_t       ret_val;
-    nrf_dfu_result_t result;
+    ret_code_t       ret_val = NRF_SUCCESS;
+    nrf_dfu_result_t result = NRF_DFU_RES_CODE_SUCCESS;
 
     if (observer == NULL)
     {
         return NRF_ERROR_INVALID_PARAM;
     }
-
+#ifdef NRF_DFU_FLASH_EN
 #if defined(BLE_STACK_SUPPORT_REQD) || defined(ANT_STACK_SUPPORT_REQD)
     ret_val  = nrf_dfu_flash_init(true);
 #else
     ret_val = nrf_dfu_flash_init(false);
+#endif
 #endif
     if (ret_val != NRF_SUCCESS)
     {
@@ -857,6 +831,7 @@ ret_code_t nrf_dfu_req_handler_init(nrf_dfu_observer_t observer)
     }
 
     nrf_dfu_validation_init();
+
     if (nrf_dfu_validation_init_cmd_present())
     {
         /* Execute a previously received init packed. Subsequent executes will have no effect. */
@@ -868,7 +843,7 @@ ret_code_t nrf_dfu_req_handler_init(nrf_dfu_observer_t observer)
         }
     }
 
-    //m_observer = observer;
+    m_observer = observer;
 
     /* Initialize extended error handling with "No error" as the most recent error. */
     result = ext_error_set(NRF_DFU_EXT_ERROR_NO_ERROR);
diff --git a/example/nordic_dfu/nrf_dfu_settings.c b/example/nordic_dfu/nrf_dfu_settings.c
index f2271464e..715c4da91 100644
--- a/example/nordic_dfu/nrf_dfu_settings.c
+++ b/example/nordic_dfu/nrf_dfu_settings.c
@@ -115,12 +115,6 @@
 
 uint8_t * mp_dfu_settings_backup_buffer = &m_mbr_params_page[0];
 
-
-#ifndef NRF_DFU_IN_APP
-#define NRF_DFU_IN_APP 0
-#endif
-
-
 #define UICR_PARAM_PAGE_ADDR 0x10001018
 
 #if !defined(BL_SETTINGS_ACCESS_ONLY) && !NRF_DFU_IN_APP
@@ -337,7 +331,7 @@ static ret_code_t settings_write(void                   * p_dst,
 
     // Not setting the callback function because ERASE is required before STORE
     // Only report completion on successful STORE.
-#ifdef NRF_DFU_FLASH
+#if NRF_DFU_FLASH
     err_code = nrf_dfu_flash_erase((uint32_t)p_dst, 1, NULL);
 #endif
     if (err_code != NRF_SUCCESS)
@@ -349,7 +343,7 @@ static ret_code_t settings_write(void                   * p_dst,
     ASSERT(p_dfu_settings_buffer != NULL);
     memcpy(p_dfu_settings_buffer, p_src, sizeof(nrf_dfu_settings_t));
 
-#ifdef NRF_DFU_FLASH
+#if NRF_DFU_FLASH
     err_code = nrf_dfu_flash_store((uint32_t)p_dst,
                                    p_dfu_settings_buffer,
                                    sizeof(nrf_dfu_settings_t),
diff --git a/example/nordic_dfu/nrf_dfu_transport.c b/example/nordic_dfu/nrf_dfu_transport.c
index cb6e9a49d..d0e7dbce6 100644
--- a/example/nordic_dfu/nrf_dfu_transport.c
+++ b/example/nordic_dfu/nrf_dfu_transport.c
@@ -40,51 +40,35 @@
 #include "nrf_dfu_transport.h"
 #include "nrf_log.h"
 
+static nrf_dfu_transport_t *m_dfu_tran;
 
-#define DFU_TRANS_SECTION_ITEM_GET(i)       NRF_SECTION_ITEM_GET(dfu_trans, nrf_dfu_transport_t, (i))
-#define DFU_TRANS_SECTION_ITEM_COUNT        NRF_SECTION_ITEM_COUNT(dfu_trans, nrf_dfu_transport_t)
-
-NRF_SECTION_DEF(dfu_trans, const nrf_dfu_transport_t);
-
-
-uint32_t nrf_dfu_transports_init(nrf_dfu_observer_t observer)
+uint32_t nrf_dfu_transports_init(nrf_dfu_observer_t observer, nrf_dfu_transport_t *p_dfu_tran)
 {
-    uint32_t const num_transports = DFU_TRANS_SECTION_ITEM_COUNT;
     uint32_t ret_val = NRF_SUCCESS;
 
-    NRF_LOG_DEBUG("Initializing transports (found: %d)", num_transports);
+    if (NULL == p_dfu_tran || NULL == observer) {
+        NRF_LOG_ERROR("Initializing transports fail!");
+        return NRF_ERROR_INVALID_PARAM;
+    }
+
+    m_dfu_tran = p_dfu_tran;
+    NRF_LOG_DEBUG("Initializing transports (found: %x)", m_dfu_tran);
 
-    for (uint32_t i = 0; i < num_transports; i++)
-    {
-        nrf_dfu_transport_t * const trans = DFU_TRANS_SECTION_ITEM_GET(i);
-        ret_val = trans->init_func(observer);
-        if (ret_val != NRF_SUCCESS)
-        {
-            NRF_LOG_DEBUG("Failed to initialize transport %d, error %d", i, ret_val);
-            break;
-        }
+    if (m_dfu_tran->init_func) {
+        ret_val = m_dfu_tran->init_func(observer);
     }
 
     return ret_val;
 }
 
-
 uint32_t nrf_dfu_transports_close(nrf_dfu_transport_t const * p_exception)
 {
-    uint32_t const num_transports = DFU_TRANS_SECTION_ITEM_COUNT;
     uint32_t ret_val = NRF_SUCCESS;
 
-    NRF_LOG_DEBUG("Shutting down transports (found: %d)", num_transports);
+    NRF_LOG_DEBUG("Shutting down transports (found: %x)", m_dfu_tran);
 
-    for (uint32_t i = 0; i < num_transports; i++)
-    {
-        nrf_dfu_transport_t * const trans = DFU_TRANS_SECTION_ITEM_GET(i);
-        ret_val = trans->close_func(p_exception);
-        if (ret_val != NRF_SUCCESS)
-        {
-            NRF_LOG_DEBUG("Failed to shutdown transport %d, error %d", i, ret_val);
-            break;
-        }
+    if (m_dfu_tran->close_func) {
+        ret_val = m_dfu_tran->close_func(p_exception);
     }
 
     return ret_val;
diff --git a/example/nordic_dfu/nrf_dfu_transport.h b/example/nordic_dfu/nrf_dfu_transport.h
index e10723ec5..9e3220e42 100644
--- a/example/nordic_dfu/nrf_dfu_transport.h
+++ b/example/nordic_dfu/nrf_dfu_transport.h
@@ -52,7 +52,6 @@
 #define NRF_DFU_TRANSPORT_H__
 
 #include <stdint.h>
-#include "nrf_section.h"
 #include "nrf_dfu_types.h"
 
 #ifdef __cplusplus
@@ -105,7 +104,7 @@ struct nrf_dfu_transport_s
  *                          Any other error code indicates that at least one DFU
  *                          transport could not be initialized.
  */
-uint32_t nrf_dfu_transports_init(nrf_dfu_observer_t observer);
+uint32_t nrf_dfu_transports_init(nrf_dfu_observer_t observer, nrf_dfu_transport_t *p_dfu_tran);
 
 /** @brief Function for closing down all (with optional exception) the registered DFU transports.
  *
diff --git a/example/nordic_dfu/nrf_dfu_types.h b/example/nordic_dfu/nrf_dfu_types.h
index 0471fa6c1..dc500d563 100644
--- a/example/nordic_dfu/nrf_dfu_types.h
+++ b/example/nordic_dfu/nrf_dfu_types.h
@@ -79,7 +79,7 @@ extern "C" {
 #elif defined(NRF52_SERIES)
     #define CODE_PAGE_SIZE            (MBR_PAGE_SIZE_IN_WORDS * sizeof(uint32_t))
 #else
-    #define CODE_PAGE_SIZE             0xFF
+    #define CODE_PAGE_SIZE            (1024 * 2)
 #endif
 
 /** @brief  Maximum size of a data object.*/
@@ -216,6 +216,8 @@ typedef struct
 typedef enum
 {
     NRF_DFU_EVT_DFU_INITIALIZED,        /**< Starting DFU. */
+    NRF_DFU_EVT_CHANGE_BOOTLOADER_NAME, /**< Change DFU bootloader name. */
+    NRF_DFU_EVT_ENTER_BOOTLOADER_MODE,  /**< Enter DUF bootloader mode. */
     NRF_DFU_EVT_TRANSPORT_ACTIVATED,    /**< Transport activated (e.g. BLE connected, USB plugged in). */
     NRF_DFU_EVT_TRANSPORT_DEACTIVATED,  /**< Transport deactivated (e.g. BLE disconnected, USB plugged out). */
     NRF_DFU_EVT_DFU_STARTED,            /**< DFU process started. */
@@ -228,7 +230,7 @@ typedef enum
 /**
  * @brief Function for notifying DFU state.
  */
-typedef void (*nrf_dfu_observer_t)(nrf_dfu_evt_type_t notification);
+typedef void (*nrf_dfu_observer_t)(nrf_dfu_evt_type_t evt, uint8_t *data, uint32_t size);
 
 #define NRF_DFU_PEER_DATA_LEN 64 /**< The length in bytes of nrf_dfu_peer_data_t expected by tools manipulating the settings page. Do not change without changing the settings page version. */
 #define NRF_DFU_ADV_NAME_LEN  28 /**< The length in bytes of nrf_dfu_adv_name_t expected by tools manipulating the settings page. Do not change without changing the settings page version. */
diff --git a/example/nordic_dfu/nrf_dfu_utils.c b/example/nordic_dfu/nrf_dfu_utils.c
index 978369a72..b5c0e6b6c 100644
--- a/example/nordic_dfu/nrf_dfu_utils.c
+++ b/example/nordic_dfu/nrf_dfu_utils.c
@@ -44,6 +44,7 @@
 #include "crc32.h"
 #include "nrf_log.h"
 #include "nrf_dfu_validation.h"
+#include "nrf_assert.h"
 
 void nrf_dfu_bank_invalidate(nrf_dfu_bank_t * const p_bank)
 {
@@ -59,13 +60,16 @@ void nrf_dfu_bank_invalidate(nrf_dfu_bank_t * const p_bank)
 void nrf_dfu_softdevice_invalidate(void)
 {
     static const uint32_t all_zero = 0UL;
+    ret_code_t err_code = NRF_SUCCESS;
 
     if (SD_PRESENT && !NRF_DFU_IN_APP)
     {
-        ret_code_t err_code = nrf_dfu_flash_store(SD_MAGIC_NUMBER_ABS_OFFSET_GET(MBR_SIZE), &all_zero, 4, NULL);
+#if NRF_DFU_FLASH
+        err_code = nrf_dfu_flash_store(SD_MAGIC_NUMBER_ABS_OFFSET_GET(MBR_SIZE), &all_zero, 4, NULL);
+#endif
         if (err_code != NRF_SUCCESS)
         {
-            NRF_LOG_ERROR("Could not invalidate SoftDevice.")
+            NRF_LOG_ERROR("Could not invalidate SoftDevice.");
         }
         else
         {
diff --git a/example/nordic_dfu/nrf_dfu_utils.h b/example/nordic_dfu/nrf_dfu_utils.h
index 715fa76fc..85b0fed23 100644
--- a/example/nordic_dfu/nrf_dfu_utils.h
+++ b/example/nordic_dfu/nrf_dfu_utils.h
@@ -57,6 +57,15 @@ extern "C"
 {
 #endif
 
+/**@brief Macro for increasing a number to the nearest (larger) multiple of another number.
+ *
+ * @param[in]  alignment  The number to align to.
+ * @param[in]  number     The number to align (increase).
+ *
+ * @return The aligned (increased) @p number.
+ */
+#define ALIGN_NUM(alignment, number) (((number) - 1) + (alignment) - (((number) - 1) % (alignment)))
+
 /**@brief Function for encoding a uint16 value.
  *
  * @param[in]   value            Value to be encoded.
diff --git a/example/nordic_dfu/nrf_dfu_validation.c b/example/nordic_dfu/nrf_dfu_validation.c
index 9cec15764..7608deb91 100644
--- a/example/nordic_dfu/nrf_dfu_validation.c
+++ b/example/nordic_dfu/nrf_dfu_validation.c
@@ -42,7 +42,7 @@
 #include "nrf_dfu_settings.h"
 #include "nrf_dfu_utils.h"
 #include "nrf_dfu_flash.h"
-//#include "nrf_bootloader_info.h"
+#include "nrf_bootloader_info.h"
 #include "pb.h"
 #include "pb_common.h"
 #include "pb_decode.h"
@@ -53,12 +53,9 @@
 #include "nrf_assert.h"
 #include "nrf_dfu_validation.h"
 #include "nrf_dfu_ver_validation.h"
-#include "nrf_strerror.h"
+//#include "nrf_strerror.h"
 
-#define NRF_LOG_MODULE_NAME nrf_dfu_validation
 #include "nrf_log.h"
-#include "nrf_log_ctrl.h"
-NRF_LOG_MODULE_REGISTER();
 
 #ifndef DFU_REQUIRES_SOFTDEVICE
 #if !defined(BLE_STACK_SUPPORT_REQD) && !defined(ANT_STACK_SUPPORT_REQD)
@@ -70,16 +67,20 @@ NRF_LOG_MODULE_REGISTER();
 
 #define EXT_ERR(err) (nrf_dfu_result_t)((uint32_t)NRF_DFU_RES_CODE_EXT_ERROR + (uint32_t)err)
 
+#define NRF_DFU_VALIDATION_CRYPTO_EN  0
 /* Whether a complete init command has been received and prevalidated, but the firmware
  * is not yet fully transferred. This value will also be correct after reset.
  */
+ 
 static bool               m_valid_init_cmd_present = false;
+
 static dfu_packet_t       m_packet                 = DFU_PACKET_INIT_DEFAULT;
 static uint8_t*           m_init_packet_data_ptr   = 0;
 static uint32_t           m_init_packet_data_len   = 0;
+static dfu_init_command_t const * mp_init = NULL;
 static pb_istream_t       m_pb_stream;
 
-static dfu_init_command_t const * mp_init = NULL;
+#if NRF_DFU_VALIDATION_CRYPTO_EN
 
 __ALIGN(4) extern const uint8_t pk[64];
 
@@ -105,6 +106,8 @@ static nrf_crypto_hash_sha256_digest_t              m_fw_hash;
  */
 static bool                                         m_crypto_initialized = false;
 
+#endif
+
 /** @brief Flag used by parser code to indicate that the init command has been found to be invalid.
  */
 static bool                                         m_init_packet_valid = false;
@@ -204,6 +207,7 @@ static bool stored_init_cmd_decode(void)
     return true;
 }
 
+#if NRF_DFU_VALIDATION_CRYPTO_EN
 
 static void crypto_init(void)
 {
@@ -231,13 +235,16 @@ static void crypto_init(void)
 
     m_crypto_initialized = true;
 }
-
+#endif
 
 void nrf_dfu_validation_init(void)
 {
     // If the command is stored to flash, init command was valid.
-    if ((s_dfu_settings.progress.command_size != 0) &&
-         stored_init_cmd_decode())
+    if ((s_dfu_settings.progress.command_size != 0)
+#if NRF_DFU_VALIDATION_CRYPTO_EN
+        && stored_init_cmd_decode()
+#endif
+    )
     {
         m_valid_init_cmd_present = true;
     }
@@ -314,6 +321,7 @@ bool nrf_dfu_validation_init_cmd_present(void)
 }
 
 
+#if NRF_DFU_VALIDATION_CRYPTO_EN
 // Function determines if init command signature is obligatory.
 static bool signature_required(dfu_fw_type_t fw_type_to_be_updated)
 {
@@ -399,7 +407,7 @@ static nrf_dfu_result_t nrf_dfu_validation_signature_check(dfu_signature_type_t
         NRF_LOG_HEXDUMP_DEBUG(m_sig_hash, hash_len);
         NRF_LOG_DEBUG("Public Key:");
         NRF_LOG_HEXDUMP_DEBUG(pk, sizeof(pk));
-        NRF_LOG_FLUSH();
+        //NRF_LOG_FLUSH();
 
         return NRF_DFU_RES_CODE_INVALID_OBJECT;
     }
@@ -407,7 +415,7 @@ static nrf_dfu_result_t nrf_dfu_validation_signature_check(dfu_signature_type_t
     NRF_LOG_INFO("Image verified");
     return NRF_DFU_RES_CODE_SUCCESS;
 }
-
+#endif
 
 // Function to calculate the total size of the firmware(s) in the update.
 static nrf_dfu_result_t update_data_size_get(dfu_init_command_t const * p_init, uint32_t * p_size)
@@ -543,7 +551,7 @@ nrf_dfu_result_t nrf_dfu_validation_prevalidate(void)
         p_signature    =  m_packet.signed_command.signature.bytes;
         signature_len  =  m_packet.signed_command.signature.size;
     }
-
+#if NRF_DFU_VALIDATION_CRYPTO_EN
     // Validate signature.
     if (signature_required(p_command->init.type))
     {
@@ -553,12 +561,12 @@ nrf_dfu_result_t nrf_dfu_validation_prevalidate(void)
                                                      m_init_packet_data_ptr,
                                                      m_init_packet_data_len);
     }
-
     // Validate versions.
     if (ret_val == NRF_DFU_RES_CODE_SUCCESS)
     {
         ret_val = nrf_dfu_ver_validation_check(&p_command->init);
     }
+#endif
 
     if (ret_val != NRF_DFU_RES_CODE_SUCCESS)
     {
@@ -570,12 +578,12 @@ nrf_dfu_result_t nrf_dfu_validation_prevalidate(void)
     return ret_val;
 }
 
-
 nrf_dfu_result_t nrf_dfu_validation_init_cmd_execute(uint32_t * p_dst_data_addr,
                                                      uint32_t * p_data_len)
 {
     nrf_dfu_result_t ret_val = NRF_DFU_RES_CODE_SUCCESS;
 
+#if 1
     if (s_dfu_settings.progress.command_offset != s_dfu_settings.progress.command_size)
     {
         // The object wasn't the right (requested) size.
@@ -623,11 +631,12 @@ nrf_dfu_result_t nrf_dfu_validation_init_cmd_execute(uint32_t * p_dst_data_addr,
         NRF_LOG_ERROR("Failed to decode init packet");
         ret_val = NRF_DFU_RES_CODE_INVALID_OBJECT;
     }
-
+#endif
     return ret_val;
 }
 
 
+#if NRF_DFU_VALIDATION_CRYPTO_EN
 // Function to check the hash received in the init command against the received firmware.
 // little_endian specifies the endianness of @p p_hash.
 static bool nrf_dfu_validation_hash_ok(uint8_t const * p_hash, uint32_t src_addr, uint32_t data_len, bool little_endian)
@@ -943,7 +952,7 @@ static bool postvalidate_sd_bl(dfu_init_command_t const  * p_init,
 
     return true;
 }
-
+#endif
 
 bool nrf_dfu_validation_boot_validate(boot_validation_t const * p_validation, uint32_t data_addr, uint32_t data_len)
 {
@@ -961,12 +970,12 @@ bool nrf_dfu_validation_boot_validate(boot_validation_t const * p_validation, ui
             if (crc != current_crc)
             {
                 // CRC does not match with what is stored.
-                NRF_LOG_DEBUG("CRC check of app failed. Return %d", NRF_DFU_DEBUG);
-                return NRF_DFU_DEBUG;
+                NRF_LOG_DEBUG("CRC check of app failed. Return %d", false);
+                return false;
             }
             return true;
         }
-
+#if NRF_DFU_VALIDATION_CRYPTO_EN
         case VALIDATE_SHA256:
             return nrf_dfu_validation_hash_ok(p_validation->bytes, data_addr, data_len, false);
 
@@ -980,7 +989,7 @@ bool nrf_dfu_validation_boot_validate(boot_validation_t const * p_validation, ui
                                             data_len);
             return (res_code == NRF_DFU_RES_CODE_SUCCESS);
         }
-
+#endif
         default:
             ASSERT(false);
             return false;
@@ -991,6 +1000,8 @@ bool nrf_dfu_validation_boot_validate(boot_validation_t const * p_validation, ui
 nrf_dfu_result_t postvalidate(uint32_t data_addr, uint32_t data_len, bool is_trusted)
 {
     nrf_dfu_result_t           ret_val = NRF_DFU_RES_CODE_SUCCESS;
+
+#if NRF_DFU_VALIDATION_CRYPTO_EN
     dfu_init_command_t const * p_init  = mp_init;
 
     if (!fw_hash_ok(p_init, data_addr, data_len))
@@ -1064,7 +1075,7 @@ nrf_dfu_result_t postvalidate(uint32_t data_addr, uint32_t data_len, bool is_tru
         nrf_dfu_settings_progress_reset();
         s_dfu_settings.progress.update_start_address = data_addr;
     }
-
+#endif
     return ret_val;
 }
 
diff --git a/example/nordic_dfu/nrf_log.h b/example/nordic_dfu/nrf_log.h
index f44addfd6..922db968f 100644
--- a/example/nordic_dfu/nrf_log.h
+++ b/example/nordic_dfu/nrf_log.h
@@ -52,6 +52,7 @@
 #include "sdk_config.h"
 #include <stdio.h>
 #include <stdio.h>
+#include "btstack_debug.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -100,10 +101,10 @@ extern "C" {
  *  @details This macro is compiled only if @ref NRF_LOG_LEVEL includes debug logs.
  */
 
-#define NRF_LOG_ERROR(format, ...)         {printf(format, ## __VA_ARGS__);printf("\n");}
-#define NRF_LOG_WARNING(format, ...)       {printf(format, ## __VA_ARGS__);printf("\n");}
-#define NRF_LOG_INFO(format, ...)          {printf(format, ## __VA_ARGS__);printf("\n");}
-#define NRF_LOG_DEBUG(format, ...)         {printf(format, ## __VA_ARGS__);printf("\n");}
+#define NRF_LOG_ERROR(format, ...)         log_error(format, ## __VA_ARGS__)
+#define NRF_LOG_WARNING(format, ...)       log_error(format, ## __VA_ARGS__)
+#define NRF_LOG_INFO(format, ...)          log_info (format, ## __VA_ARGS__)
+#define NRF_LOG_DEBUG(format, ...)         log_debug(format, ## __VA_ARGS__)
 
 /** @def NRF_LOG_INST_ERROR
  *  @brief Macro for logging error messages for a given module instance. It takes a printf-like, formatted
diff --git a/example/nordic_dfu/sdk_config.h b/example/nordic_dfu/sdk_config.h
index 01dc460c8..2f5c853c6 100644
--- a/example/nordic_dfu/sdk_config.h
+++ b/example/nordic_dfu/sdk_config.h
@@ -48,6 +48,10 @@
 #endif
 // <h> nRF_ANT 
 
+#define NRF_DFU_VALIDATION_EN   1
+#define NRF_DFU_FLASH           0
+
+
 #define NRF52_SERIES
 
 #define NRF_DFU_SETTINGS_VERSION    0x00000001
@@ -62,6 +66,26 @@
 #define NRF_DFU_SETTINGS_COMPATIBILITY_MODE 1
 #endif
 
+#ifndef NRF_DFU_IN_APP
+#define NRF_DFU_IN_APP 0
+#endif
+
+#ifndef NRF_DFU_SINGLE_BANK_APP_UPDATES
+#define NRF_DFU_SINGLE_BANK_APP_UPDATES 1
+#endif
+
+#ifndef NRF_DFU_FORCE_DUAL_BANK_APP_UPDATES
+#define NRF_DFU_FORCE_DUAL_BANK_APP_UPDATES 0
+#endif
+
+// <i> Save DFU progress to flash so that it can be resumed if interrupted, instead of being restarted.
+// <i> Keep this setting disabled to maximize transfer speed and minimize flash wear.
+// <i> The init packet is always saved in flash, regardless of this setting.
+
+#ifndef NRF_DFU_SAVE_PROGRESS_IN_FLASH
+#define NRF_DFU_SAVE_PROGRESS_IN_FLASH 0
+#endif
+
 //==========================================================
 // <e> ANTFS_ENABLED - ant_fs - ANT File Share module.
 //==========================================================
@@ -8645,7 +8669,7 @@
 // <4=> Debug 
 
 #ifndef NRF_LOG_DEFAULT_LEVEL
-#define NRF_LOG_DEFAULT_LEVEL 3
+#define NRF_LOG_DEFAULT_LEVEL 4
 #endif
 
 // <q> NRF_LOG_DEFERRED  - Enable deffered logger.
diff --git a/example/nordic_dfu_demo.c b/example/nordic_dfu_demo.c
index 2ee50060a..095c400f8 100644
--- a/example/nordic_dfu_demo.c
+++ b/example/nordic_dfu_demo.c
@@ -63,6 +63,7 @@
 #include "btstack.h"
 #include "nrf_dfu_ble.h"
 #include "nordic_dfu_demo.h"
+#include "nrf_dfu.h"
 
 uint8_t adv_data[] = {
     // Flags general discoverable, BR/EDR not supported
@@ -233,7 +234,7 @@ static void att_packet_handler (uint8_t packet_type, uint16_t channel, uint8_t *
 }
 /* LISTING_END */
 
-static void nordic_dfu_packet_handler(nrf_dfu_ble_evt_t evt, uint8_t *packet, uint16_t size) {
+static void nordic_dfu_evt_observer(nrf_dfu_evt_type_t evt, uint8_t *packet, uint32_t size) {
     printf("%s evt:%d \n", __func__, evt);
 
     switch (evt) {
@@ -268,7 +269,7 @@ int btstack_main(void){
     att_server_init(profile_data, NULL, NULL);
     
     // setup nordic dfu server
-    nrf_dfu_ble_init(nordic_dfu_packet_handler);
+    nrf_dfu_init(nordic_dfu_evt_observer);
 
     // register for ATT events
     att_server_register_packet_handler(att_packet_handler);
diff --git a/port/stm32-f103zet6-csr8x11-freertos/Makefile b/port/stm32-f103zet6-csr8x11-freertos/Makefile
index 27f3ff127..42f89397c 100644
--- a/port/stm32-f103zet6-csr8x11-freertos/Makefile
+++ b/port/stm32-f103zet6-csr8x11-freertos/Makefile
@@ -169,14 +169,24 @@ C_SOURCES += ${BTSTACK_ROOT}/3rd-party/lwip/dhcp-server/dhserver.c
 endif
 
 VPATH += ${BTSTACK_ROOT}/example/nordic_dfu
+VPATH += ${BTSTACK_ROOT}/example/nordic_dfu/nano-pb
+
+C_SOURCES += ${BTSTACK_ROOT}/example/nordic_dfu/nrf_dfu.c
+C_SOURCES += ${BTSTACK_ROOT}/example/nordic_dfu/nrf_dfu_transport.c
 C_SOURCES += ${BTSTACK_ROOT}/example/nordic_dfu/nrf_dfu_ble.c
 C_SOURCES += ${BTSTACK_ROOT}/example/nordic_dfu/nrf_dfu_req_handler.c
 C_SOURCES += ${BTSTACK_ROOT}/example/nordic_dfu/nrf_dfu_settings.c
+C_SOURCES += ${BTSTACK_ROOT}/example/nordic_dfu/nrf_dfu_utils.c
+C_SOURCES += ${BTSTACK_ROOT}/example/nordic_dfu/dfu-cc.pb.c
 #C_SOURCES += ${BTSTACK_ROOT}/example/nordic_dfu/nrf_dfu_flash.c
-#C_SOURCES += ${BTSTACK_ROOT}/example/nordic_dfu/nrf_dfu_validation.c
+C_SOURCES += ${BTSTACK_ROOT}/example/nordic_dfu/nrf_dfu_validation.c
 C_SOURCES += ${BTSTACK_ROOT}/example/nordic_dfu/nrf_dfu_handling_error.c
 C_SOURCES += ${BTSTACK_ROOT}/example/nordic_dfu/crc32.c
 
+C_SOURCES += ${BTSTACK_ROOT}/example/nordic_dfu/nano-pb/pb_common.c
+C_SOURCES += ${BTSTACK_ROOT}/example/nordic_dfu/nano-pb/pb_decode.c
+C_SOURCES += ${BTSTACK_ROOT}/example/nordic_dfu/nano-pb/pb_encode.c
+#C_SOURCES += ${BTSTACK_ROOT}/example/nordic_dfu/nano-pb/pb_common.c
 
 
 C_SOURCES += ${BTSTACK_ROOT}/example/sco_demo_util.c
@@ -349,6 +359,7 @@ C_INCLUDES += -I${BTSTACK_ROOT}/platform/lwip/port
 C_INCLUDES += -I${BTSTACK_ROOT}/chipset/csr
 C_INCLUDES += -I${BTSTACK_ROOT}/tool
 C_INCLUDES += -I${BTSTACK_ROOT}/example/nordic_dfu
+C_INCLUDES += -I${BTSTACK_ROOT}/example/nordic_dfu/nano-pb
 
 C_INCLUDES += -I Port
 C_INCLUDES += -I Src
diff --git a/port/stm32-f103zet6-csr8x11-freertos/Src/main.c b/port/stm32-f103zet6-csr8x11-freertos/Src/main.c
index 8c98d2450..58878571b 100644
--- a/port/stm32-f103zet6-csr8x11-freertos/Src/main.c
+++ b/port/stm32-f103zet6-csr8x11-freertos/Src/main.c
@@ -64,6 +64,9 @@ void SystemClock_Config(void);
   * @brief  The application entry point.
   * @retval int
   */
+
+extern void port_main(void);
+
 int main(void)
 {
   /* USER CODE BEGIN 1 */
diff --git a/port/stm32-f4discovery-usb/port/port.c b/port/stm32-f4discovery-usb/port/port.c
index 5ea3fae5b..e11196303 100644
--- a/port/stm32-f4discovery-usb/port/port.c
+++ b/port/stm32-f4discovery-usb/port/port.c
@@ -110,7 +110,7 @@ static void packet_handler (uint8_t packet_type, uint16_t channel, uint8_t *pack
     UNUSED(channel);
     bd_addr_t local_addr;
     if (packet_type != HCI_EVENT_PACKET) return;
-    switch(hci_event_packet_get_type(packet)){f
+    switch(hci_event_packet_get_type(packet)){
         case BTSTACK_EVENT_STATE:
             if (btstack_event_state_get_state(packet) != HCI_STATE_WORKING) return;
             gap_local_bd_addr(local_addr);
